diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/app/src/blinky.c ./app/src/blinky.c
--- a_tnusFF/app/src/blinky.c	1969-12-31 21:00:00.000000000 -0300
+++ ./app/src/blinky.c	2016-10-22 23:17:43.468840275 -0300
@@ -0,0 +1,75 @@
+/*
+ * @brief Blinky example using SysTick and interrupt
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "board.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define TICKRATE_HZ (10)	/* 10 ticks per second */
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Systick handler ISR */
+void SysTick_Handler(void)
+{
+	Board_LED_Toggle(0);
+}
+
+/* main function (C entry point) */
+int main(void)
+{
+	int loop = 1;	/* Used to fix the unreachable statement warning */
+	SystemCoreClockUpdate();
+	Board_Init();
+
+	Board_LED_Set(0, false);
+
+	/* Enable SysTick Timer */
+	SysTick_Config(SystemCoreClock / TICKRATE_HZ);
+
+	while (loop) {
+		__WFI();
+	}
+
+	return 0;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/base/inc/crp.h ./base/inc/crp.h
--- a_tnusFF/base/inc/crp.h	1969-12-31 21:00:00.000000000 -0300
+++ ./base/inc/crp.h	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,85 @@
+/****************************************************************************
+ *   Description:
+ *     Code Read Protection macros
+ ****************************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+****************************************************************************/
+#ifndef _CRP_H_INCLUDED_
+#define _CRP_H_INCLUDED_
+
+// A macro for placing data into the Code Read Protect (CRP) section,
+// which is then located at the correct address for the selected MCU
+// by the automatically generated linker script. The CRP section should
+// contain a single 32-bit value which is the CRP value. See appropriate
+// documentation for the MCU to determine CRP values.
+//
+// This feature is only available for NXP MCU targets with the Code Read
+// Protect Feature
+//
+// Example:
+//        __CRP const uint32_t CRP_WORD = CRP_NO_CRP ;
+//
+#define __CRP __attribute__ ((used,section(".crp")))
+
+#define CRP_NO_CRP          0xFFFFFFFF
+
+// Disables UART and USB In System Programming (reads and writes)
+// Leaves SWD debugging, with reads and writes, enabled
+#define CRP_NO_ISP    0x4E697370
+
+// Disables SWD debugging & JTAG, leaves ISP with with reads and writes enabled
+// You will need UART connectivity and FlashMagic (flashmagictool.com) to reverse
+// this. Don't even try this without these tools; most likely the SWD flash
+// programming will not even complete.
+// Allows reads and writes only to RAM above 0x10000300 and flash other than
+// sector 0 (the first 4 kB). Full erase also allowed- again only through UART
+// and FlashMagic (NO JTAG/SWD)
+#define CRP_CRP1      0x12345678
+
+// Disables SWD debugging & JTAG, leaves UART ISP with with only full erase
+// enabled. You must have UART access and FlashMagic before setting this
+// option.
+// Don't even try this without these tools; most likely the SWD flash
+// programming will not even complete.
+#define CRP_CRP2      0x87654321
+
+/************************************************************/
+/**** DANGER CRP3 WILL LOCK PART TO ALL READS and WRITES ****/
+#define CRP_CRP3_CONSUME_PART 0x43218765
+/************************************************************/
+
+#if CONFIG_CRP_SETTING_NO_CRP == 1
+#define CURRENT_CRP_SETTING CRP_NO_CRP
+#endif
+
+#if CONFIG_CRP_SETTING_NOISP == 1
+#define CURRENT_CRP_SETTING CRP_NO_ISP
+#endif
+
+#if CONFIG_CRP_SETTING_CRP1 == 1
+#define CURRENT_CRP_SETTING CRP_CRP1
+#endif
+
+#if CONFIG_CRP_SETTING_CRP2 == 1
+#define CURRENT_CRP_SETTING CRP_CRP2
+#endif
+
+#if CONFIG_CRP_SETTING_CRP3_CONSUME_PART == 1
+#define CURRENT_CRP_SETTING CRP_CRP3_CONSUME_PART
+#endif
+
+#ifndef CURRENT_CRP_SETTING
+#define CURRENT_CRP_SETTING CRP_NO_CRP
+#endif
+
+
+#endif /* _CRP_H_INCLUDED_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/base/Makefile ./base/Makefile
--- a_tnusFF/base/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ ./base/Makefile	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,39 @@
+# Copyright 2016, Pablo Ridolfi
+# All rights reserved.
+#
+# This file is part of Workspace.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its
+#    contributors may be used to endorse or promote products derived from this
+#    software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+base_PATH := modules/lpc54102_m4/base
+
+base_SRC_FILES := $(wildcard $(base_PATH)/src/*.c) \
+                  $(wildcard $(base_PATH)/src/*.S)
+
+base_INC_FOLDERS := $(base_PATH)/inc
+
+base_SRC_FOLDERS := $(base_PATH)/src
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/base/src/cr_startup_lpc5410x.c ./base/src/cr_startup_lpc5410x.c
--- a_tnusFF/base/src/cr_startup_lpc5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./base/src/cr_startup_lpc5410x.c	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,532 @@
+//*****************************************************************************
+// LPC5410x Microcontroller Startup code for use with LPCXpresso IDE
+//
+// Version : 150723
+//*****************************************************************************
+//
+// Copyright(C) NXP Semiconductors, 2014-15
+// All rights reserved.
+//
+// Software that is described herein is for illustrative purposes only
+// which provides customers with programming information regarding the
+// LPC products.  This software is supplied "AS IS" without any warranties of
+// any kind, and NXP Semiconductors and its licensor disclaim any and
+// all warranties, express or implied, including all implied warranties of
+// merchantability, fitness for a particular purpose and non-infringement of
+// intellectual property rights.  NXP Semiconductors assumes no responsibility
+// or liability for the use of the software, conveys no license or rights under any
+// patent, copyright, mask work right, or any other intellectual property rights in
+// or to any products. NXP Semiconductors reserves the right to make changes
+// in the software without notification. NXP Semiconductors also makes no
+// representation or warranty that such application will be suitable for the
+// specified use without further testing or modification.
+//
+// Permission to use, copy, modify, and distribute this software and its
+// documentation is hereby granted, under NXP Semiconductors' and its
+// licensor's relevant copyrights in the software, without fee, provided that it
+// is used in conjunction with NXP Semiconductors microcontrollers.  This
+// copyright, permission, and disclaimer notice must appear in all copies of
+// this code.
+//*****************************************************************************
+
+#if defined (__cplusplus)
+#ifdef __REDLIB__
+#error Redlib does not support C++
+#else
+//*****************************************************************************
+//
+// The entry point for the C++ library startup
+//
+//*****************************************************************************
+extern "C" {
+    extern void __libc_init_array(void);
+}
+#endif
+#endif
+
+#define WEAK __attribute__ ((weak))
+#define ALIAS(f) __attribute__ ((weak, alias (#f)))
+
+//*****************************************************************************
+#if defined (__cplusplus)
+extern "C" {
+#endif
+
+//*****************************************************************************
+#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
+// Declaration of external SystemInit function
+extern void SystemInit(void);
+#endif
+
+//*****************************************************************************
+#if !defined (DONT_ENABLE_SWVTRACECLK) && !defined (CORE_M0PLUS)
+// Allow confirmation that SWV trace has been enabled
+unsigned int __SWVtrace_Enabled;
+#endif
+
+//*****************************************************************************
+//
+// Forward declaration of the default handlers. These are aliased.
+// When the application defines a handler (with the same name), this will
+// automatically take precedence over these weak definitions
+//
+//*****************************************************************************
+void ResetISR(void);
+#if defined (__MULTICORE_MASTER)
+void ResetISR2(void);
+#endif
+WEAK void NMI_Handler(void);
+WEAK void HardFault_Handler(void);
+WEAK void MemManage_Handler(void);
+WEAK void BusFault_Handler(void);
+WEAK void UsageFault_Handler(void);
+WEAK void SVC_Handler(void);
+WEAK void DebugMon_Handler(void);
+WEAK void PendSV_Handler(void);
+WEAK void SysTick_Handler(void);
+WEAK void IntDefaultHandler(void);
+
+//*****************************************************************************
+//
+// Forward declaration of the specific IRQ handlers. These are aliased
+// to the IntDefaultHandler, which is a 'forever' loop. When the application
+// defines a handler (with the same name), this will automatically take
+// precedence over these weak definitions
+//
+//*****************************************************************************
+// External Interrupts - Available on M0/M4
+void WDT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void BOD_IRQHandler(void) ALIAS(IntDefaultHandler);
+void Reserved_IRQHandler(void) ALIAS(IntDefaultHandler);
+void DMA_IRQHandler(void) ALIAS(IntDefaultHandler);
+void GINT0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UTICK_IRQHandler(void) ALIAS(IntDefaultHandler);
+void MRT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CT32B0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CT32B1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CT32B2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CT32B3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void CT32B4_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SCT0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void UART3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void I2C2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI0_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC_SEQA_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC_SEQB_IRQHandler(void) ALIAS(IntDefaultHandler);
+void ADC_THCMP_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RTC_IRQHandler(void) ALIAS(IntDefaultHandler);
+void IOH_IRQHandler(void) ALIAS(IntDefaultHandler);
+void MAILBOX_IRQHandler(void) ALIAS(IntDefaultHandler);
+// External Interrupts - For M4 only
+void GINT1_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT4_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT5_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT6_IRQHandler(void) ALIAS(IntDefaultHandler);
+void PIN_INT7_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI2_IRQHandler(void) ALIAS(IntDefaultHandler);
+void SPI3_IRQHandler(void) ALIAS(IntDefaultHandler);
+void RIT_IRQHandler(void) ALIAS(IntDefaultHandler);
+void Reserved41_IRQHandler(void) ALIAS(IntDefaultHandler);
+void Reserved42_IRQHandler(void) ALIAS(IntDefaultHandler);
+void Reserved43_IRQHandler(void) ALIAS(IntDefaultHandler);
+void Reserved44_IRQHandler(void) ALIAS(IntDefaultHandler);
+
+//*****************************************************************************
+//
+// The entry point for the application.
+// __main() is the entry point for Redlib based applications
+// main() is the entry point for Newlib based applications
+//
+//*****************************************************************************
+#if defined (__REDLIB__)
+extern void __main(void);
+#endif
+extern int main(void);
+//*****************************************************************************
+//
+// External declaration for the pointer to the stack top from the Linker Script
+//
+//*****************************************************************************
+extern void _vStackTop(void);
+
+//*****************************************************************************
+//
+// External declaration for LPC MCU vector table checksum from  Linker Script
+//
+//*****************************************************************************
+WEAK extern void __valid_user_code_checksum();
+
+// Variable to store CRP value in. Will be placed automatically
+// by the linker when "Enable Code Read Protect" selected.
+// See crp.h header for more information
+#include "crp.h"
+
+__CRP const unsigned int CRP_WORD = CRP_NO_CRP;
+
+//*****************************************************************************
+#if defined (__cplusplus)
+} // extern "C"
+#endif
+//*****************************************************************************
+//
+// The vector table.
+// This relies on the linker script to place at correct location in memory.
+//
+//*****************************************************************************
+extern void (* const g_pfnVectors[])(void);
+__attribute__ ((used, section(".isr_vector")))
+void (* const g_pfnVectors[])(void) = {
+    // Core Level - CM4
+        &_vStackTop,            // The initial stack pointer
+        ResetISR,               // The reset handler
+        NMI_Handler,            // The NMI handler
+        HardFault_Handler,      // The hard fault handler
+        MemManage_Handler,      // The MPU fault handler
+        BusFault_Handler,       // The bus fault handler
+        UsageFault_Handler,     // The usage fault handler
+        __valid_user_code_checksum, // LPC MCU Checksum
+        0,                      // Reserved
+        0,                      // Reserved
+        0,                      // Reserved
+        SVC_Handler,            // SVCall handler
+        DebugMon_Handler,       // Debug monitor handler
+        0,                      // Reserved
+        PendSV_Handler,         // The PendSV handler
+        SysTick_Handler,        // The SysTick handler
+
+        // External Interrupts - Available on M0/M4
+        WDT_IRQHandler,         // Watchdog
+        BOD_IRQHandler,         // Brown Out Detect
+        Reserved_IRQHandler,    // Reserved
+        DMA_IRQHandler,         // DMA Controller
+        GINT0_IRQHandler,       // GPIO Group0 Interrupt
+        PIN_INT0_IRQHandler,    // PIO INT0
+        PIN_INT1_IRQHandler,    // PIO INT1
+        PIN_INT2_IRQHandler,    // PIO INT2
+        PIN_INT3_IRQHandler,    // PIO INT3
+        UTICK_IRQHandler,       // UTICK timer
+        MRT_IRQHandler,         // Multi-Rate Timer
+        CT32B0_IRQHandler,      // Counter Timer 0
+        CT32B1_IRQHandler,      // Counter Timer 1
+        CT32B2_IRQHandler,      // Counter Timer 2
+        CT32B3_IRQHandler,      // Counter Timer 3
+        CT32B4_IRQHandler,      // Counter Timer 4
+        SCT0_IRQHandler,        // Smart Counter Timer
+        UART0_IRQHandler,       // UART0
+        UART1_IRQHandler,       // UART1
+        UART2_IRQHandler,       // UART2
+        UART3_IRQHandler,       // UART3
+        I2C0_IRQHandler,        // I2C0 controller
+        I2C1_IRQHandler,        // I2C1 controller
+        I2C2_IRQHandler,        // I2C2 controller
+        SPI0_IRQHandler,        // SPI0 controller
+        SPI1_IRQHandler,        // SPI1 controller
+        ADC_SEQA_IRQHandler,    // ADC SEQA
+        ADC_SEQB_IRQHandler,    // ADC SEQB
+        ADC_THCMP_IRQHandler,   // ADC THCMP and OVERRUN ORed
+        RTC_IRQHandler,         // RTC Timer
+        IOH_IRQHandler,         // IOH Handler
+        MAILBOX_IRQHandler,     // Mailbox
+
+        // External Interrupts - For M4 only
+        GINT1_IRQHandler,       // GPIO Group1 Interrupt
+        PIN_INT4_IRQHandler,    // PIO INT4
+        PIN_INT5_IRQHandler,    // PIO INT5
+        PIN_INT6_IRQHandler,    // PIO INT6
+        PIN_INT7_IRQHandler,    // PIO INT7
+        SPI2_IRQHandler,        // SPI2 controller
+        SPI3_IRQHandler,        // SPI3 controller
+        0,                      // Reserved
+        RIT_IRQHandler,         // RIT Timer
+        Reserved41_IRQHandler,  // Reserved
+        Reserved42_IRQHandler,  // Reserved
+        Reserved43_IRQHandler,  // Reserved
+        Reserved44_IRQHandler,  // Reserved
+
+}; /* End of g_pfnVectors */
+
+//*****************************************************************************
+// Functions to carry out the initialization of RW and BSS data sections. These
+// are written as separate functions rather than being inlined within the
+// ResetISR() function in order to cope with MCUs with multiple banks of
+// memory.
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void data_init(unsigned int romstart, unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int *pulSrc = (unsigned int*) romstart;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = *pulSrc++;
+}
+
+__attribute__ ((section(".after_vectors")))
+void bss_init(unsigned int start, unsigned int len) {
+    unsigned int *pulDest = (unsigned int*) start;
+    unsigned int loop;
+    for (loop = 0; loop < len; loop = loop + 4)
+        *pulDest++ = 0;
+}
+
+//*****************************************************************************
+// The following symbols are constructs generated by the linker, indicating
+// the location of various points in the "Global Section Table". This table is
+// created by the linker via the Code Red managed linker script mechanism. It
+// contains the load address, execution address and length of each RW data
+// section and the execution and length of each BSS (zero initialized) section.
+//*****************************************************************************
+extern unsigned int __data_section_table;
+extern unsigned int __data_section_table_end;
+extern unsigned int __bss_section_table;
+extern unsigned int __bss_section_table_end;
+
+//*****************************************************************************
+// Reset entry point for your code.
+// Sets up a simple runtime environment and initializes the C/C++
+// library.
+//*****************************************************************************
+
+#if defined (__MULTICORE_MASTER)
+//#define  cpu_ctrl 0x40000300
+//#define coproc_boot	0x40000304
+//#define set coproc_stack	0x40000308
+__attribute__ ((naked, section(".after_vectors.reset")))
+void ResetISR(void) {
+    asm volatile(
+        ".set   cpu_ctrl,       0x40000300\t\n"
+        ".set   coproc_boot,    0x40000304\t\n"
+        ".set   coproc_stack,   0x40000308\t\n"
+        "MOVS   R5, #1\t\n"
+        "LDR    R0, =0xE000ED00\t\n"
+        "LDR    R1, [R0]\t\n"           // READ CPUID register
+        "LDR    R2,=0x410CC601\t\n"     // CM0 R0p1 identifier
+        "EORS   R1,R1,R2\t\n"           // XOR to see if we are C0
+        "LDR    R3, =cpu_ctrl\t\n"      // get address of CPU_CTRL
+        "LDR    R1,[R3]\t\n"            // read cpu_ctrl reg into R1
+        "BEQ.N  cm0_boot\t\n"
+    "cm4_boot:\t\n"
+        "LDR    R0,=coproc_boot\t\n"    // coproc boot address
+        "LDR    R0,[R0]\t\n"            // get address to branch to
+        "MOVS   R0,R0\t\n"              // Check if 0
+        "BEQ.N  check_master_m4\t\n"    // if zero in boot reg, we just branch to  real reset
+        "BX     R0\t\n"                 // otherwise, we branch to boot address
+    "commonboot:\t\n"
+        "LDR    R0, =ResetISR2\t\n"     // Jump to 'real' reset handler
+        "BX     R0\t\n"
+    "cm0_boot:\t\n"
+        "LDR    R0,=coproc_boot\t\n"    // coproc boot address
+        "LDR    R0,[R0]\t\n"            // get address to branch to
+        "MOVS   R0,R0\t\n"              // Check if 0
+        "BEQ.N  check_master_m0\t\n"    // if zero in boot reg, we just branch to  real reset
+        "LDR    R1,=coproc_stack\t\n"   // pickup coprocesor stackpointer (from syscon CPSTACK)
+        "LDR    R1,[R1]\t\n"
+        "MOV    SP,R1\t\n"
+        "BX     R0\t\n"                 // goto boot address
+    "check_master_m0:\t\n"
+        "ANDS   R1,R1,R5\t\n"           // bit test bit0
+        "BEQ.N  commonboot\t\n"         // if we get 0, that means we are masters
+        "B.N    goto_sleep_pending_reset\t\n"   // Otherwise, there is no startup vector for slave, so we go to sleep
+    "check_master_m4:\t\n"
+        "ANDS   R1,R1,R5\t\n"           // bit test bit0
+        "BNE.N  commonboot\t\n"         // if we get 1, that means we are masters
+    "goto_sleep_pending_reset:\t\n"
+        "MOV     SP,R5\t\n"             // load 0x1 into SP so that any stacking (eg on NMI) will not cause us to wakeup
+            // and write to uninitialised Stack area (instead it will LOCK us up before we cause damage)
+            // this code should only be reached if debugger bypassed ROM or we changed master without giving
+            // correct start address, the only way out of this is through a debugger change of SP and PC
+    "sleepo:\t\n"
+        "WFI\t\n"                       // go to sleep
+        "B.N    sleepo\t\n"
+    );
+}
+
+void ResetISR2(void) {
+
+#else
+__attribute__ ((section(".after_vectors.reset")))
+void ResetISR(void) {
+#endif
+
+    // If this is not the CM0+ core...
+#if !defined (CORE_M0PLUS)
+    // If this is not a slave project...
+#if !defined (__MULTICORE_M0SLAVE) && \
+    !defined (__MULTICORE_M4SLAVE)
+    // Optionally enable RAM banks that may be off by default at reset
+#if !defined (DONT_ENABLE_DISABLED_RAMBANKS)
+    volatile unsigned int *SYSCON_SYSAHBCLKCTRL0 = (unsigned int *) 0x400000c0;
+    // Ensure that SRAM2(4) bit in SYSAHBCLKCTRL0 are set
+    *SYSCON_SYSAHBCLKCTRL0 |= (1 << 4);
+#endif
+#endif
+#endif
+
+    //
+    // Copy the data sections from flash to SRAM.
+    //
+    unsigned int LoadAddr, ExeAddr, SectionLen;
+    unsigned int *SectionTableAddr;
+
+    // Load base address of Global Section Table
+    SectionTableAddr = &__data_section_table;
+
+    // Copy the data sections from flash to SRAM.
+    while (SectionTableAddr < &__data_section_table_end) {
+        LoadAddr = *SectionTableAddr++;
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        data_init(LoadAddr, ExeAddr, SectionLen);
+    }
+    // At this point, SectionTableAddr = &__bss_section_table;
+    // Zero fill the bss segment
+    while (SectionTableAddr < &__bss_section_table_end) {
+        ExeAddr = *SectionTableAddr++;
+        SectionLen = *SectionTableAddr++;
+        bss_init(ExeAddr, SectionLen);
+    }
+
+	// Optionally enable Cortex-M4 SWV trace (off by default at reset)
+    // Note - your board support must also set up pinmuxing such that
+    // SWO is output on GPIO PIO0-15 (FUNC2) or PIO1_1 (FUNC2).
+#if !defined (DONT_ENABLE_SWVTRACECLK) && !defined (CORE_M0PLUS)
+	volatile unsigned int *TRACECLKDIV = (unsigned int *) 0x400000E4;
+	volatile unsigned int *SYSAHBCLKCTRLSET = (unsigned int *) 0x400000C8;
+	volatile unsigned int *SYSAHBCLKCTRL = (unsigned int *) 0x400000C0;
+	// Write 0x00000001 to TRACECLKDIV (0x400000E4) â€“ Trace divider
+	*TRACECLKDIV = 1;
+	// Enable IOCON peripheral clock (for SWO on PIO0-15 or PIO1_1)
+	// by setting bit13 via SYSAHBCLKCTRLSET[0] (0x400000C8)
+	*SYSAHBCLKCTRLSET = 1 << 13; // 0x2000
+	// Read  SYSAHBCLKCTRL[0] (0x400000C0) and check bit 13
+	__SWVtrace_Enabled = ((*SYSAHBCLKCTRL & 1 << 13) == 1 << 13);
+#endif
+
+#if !defined (__USE_LPCOPEN)
+// LPCOpen init code deals with FP and VTOR initialisation
+#if defined (__VFP_FP__) && !defined (__SOFTFP__)
+    /*
+     * Code to enable the Cortex-M4 FPU only included
+     * if appropriate build options have been selected.
+     * Code taken from Section 7.1, Cortex-M4 TRM (DDI0439C)
+     */
+    // CPACR is located at address 0xE000ED88
+    asm("LDR.W R0, =0xE000ED88");
+    // Read CPACR
+    asm("LDR R1, [R0]");
+    // Set bits 20-23 to enable CP10 and CP11 coprocessors
+    asm(" ORR R1, R1, #(0xF << 20)");
+    // Write back the modified value to the CPACR
+    asm("STR R1, [R0]");
+#endif // (__VFP_FP__) && !(__SOFTFP__)
+    // ******************************
+    // Check to see if we are running the code from a non-zero
+    // address (eg RAM, external flash), in which case we need
+    // to modify the VTOR register to tell the CPU that the
+    // vector table is located at a non-0x0 address.
+
+    // Note that we do not use the CMSIS register access mechanism,
+    // as there is no guarantee that the project has been configured
+    // to use CMSIS.
+    unsigned int * pSCB_VTOR = (unsigned int *) 0xE000ED08;
+    if ((unsigned int *) g_pfnVectors != (unsigned int *) 0x00000000) {
+        // CMSIS : SCB->VTOR = <address of vector table>
+        *pSCB_VTOR = (unsigned int) g_pfnVectors;
+    }
+#endif
+
+#if defined (__USE_CMSIS) || defined (__USE_LPCOPEN)
+    SystemInit();
+#endif
+
+#if defined (__cplusplus)
+    //
+    // Call C++ library initialisation
+    //
+    __libc_init_array();
+#endif
+
+#if defined (__REDLIB__)
+    // Call the Redlib library, which in turn calls main()
+    __main();
+#else
+    main();
+#endif
+
+    //
+    // main() shouldn't return, but if it does, we'll just enter an infinite loop
+    //
+    while (1) {
+        ;
+    }
+}
+
+//*****************************************************************************
+// Default exception handlers. Override the ones here by defining your own
+// handler routines in your application code.
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void NMI_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void HardFault_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void MemManage_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void BusFault_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void UsageFault_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void SVC_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void DebugMon_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void PendSV_Handler(void)
+{ while(1) {}
+}
+
+__attribute__ ((section(".after_vectors")))
+void SysTick_Handler(void)
+{ while(1) {}
+}
+
+//*****************************************************************************
+//
+// Processor ends up here if an unexpected interrupt occurs or a specific
+// handler is not present in the application code.
+//
+//*****************************************************************************
+__attribute__ ((section(".after_vectors")))
+void IntDefaultHandler(void) {
+    while (1) {}
+}
+
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/base/src/sysinit.c ./base/src/sysinit.c
--- a_tnusFF/base/src/sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./base/src/sysinit.c	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,84 @@
+/*
+ * @brief Common SystemInit function for LPC54xxx chips
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+ #if defined(NO_BOARD_LIB)
+ #include "chip.h"
+ #else
+ #include "board.h"
+ #endif
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+#if defined(NO_BOARD_LIB)
+const uint32_t ExtClockIn = 0;
+#endif
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set up and initialize hardware prior to call to main */
+void SystemInit(void)
+{
+#if defined(__CODE_RED)
+	extern void(*const g_pfnVectors[]) (void);
+	SCB->VTOR = (uint32_t) &g_pfnVectors;
+#else
+	extern void *__Vectors;
+	SCB->VTOR = (uint32_t) &__Vectors;
+#endif
+
+#if defined(CORE_M4)
+#if defined(__FPU_PRESENT) && __FPU_PRESENT == 1
+	fpuInit();
+#endif
+#endif
+
+#if !defined(__MULTICORE_M0SLAVE) && !defined(__MULTICORE_M4SLAVE)
+#if defined(NO_BOARD_LIB)
+	/* Chip specific SystemInit */
+	Chip_SystemInit();
+#else
+	/* Board specific SystemInit */
+	Board_SystemInit();
+#endif
+#endif
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/inc/board_api.h ./board/inc/board_api.h
--- a_tnusFF/board/inc/board_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./board/inc/board_api.h	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,187 @@
+/*
+ * @brief Common board API functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __BOARD_API_H_
+#define __BOARD_API_H_
+
+#include "lpc_types.h"
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BOARD_COMMON_API BOARD: Common board functions
+ * @ingroup BOARD_Common
+ * This file contains common board definitions that are shared across
+ * boards and devices. All of these functions do not need to be
+ * implemented for a specific board, but if they are implemented, they
+ * should use this API standard.
+ * @{
+ */
+
+/**
+ * @brief	Setup and initialize hardware prior to call to main()
+ * @return	None
+ * @note	Board_SystemInit() is called prior to the application and sets up system
+ * clocking, memory, and any resources needed prior to the application
+ * starting.
+ */
+void Board_SystemInit(void);
+
+/**
+ * @brief	Setup pin multiplexer per board schematics
+ * @return	None
+ * @note	Board_SetupMuxing() should be called from SystemInit() prior to application
+ * main() is called. So that the PINs are set in proper state.
+ */
+void Board_SetupMuxing(void);
+
+/**
+ * @brief	Setup system clocking
+ * @return	None
+ * @note	This sets up board clocking.
+ */
+void Board_SetupClocking(void);
+
+/**
+ * @brief	Setup external system memory
+ * @return	None
+ * @note	This function is typically called after pin mux setup and clock setup and
+ * sets up any external memory needed by the system (DRAM, SRAM, etc.). Not all
+ * boards need this function.
+ */
+void Board_SetupExtMemory(void);
+
+/**
+ * @brief	Set up and initialize all required blocks and functions related to the board hardware.
+ * @return	None
+ */
+void Board_Init(void);
+
+/**
+ * @brief	Initializes board UART for output, required for printf redirection
+ * @return	None
+ */
+void Board_Debug_Init(void);
+
+/**
+ * @brief	Sends a single character on the UART, required for printf redirection
+ * @param	ch	: character to send
+ * @return	None
+ */
+void Board_UARTPutChar(char ch);
+
+/**
+ * @brief	Get a single character from the UART, required for scanf input
+ * @return	EOF if not character was received, or character value
+ */
+int Board_UARTGetChar(void);
+
+/**
+ * @brief	Prints a string to the UART
+ * @param	str	: Terminated string to output
+ * @return	None
+ */
+void Board_UARTPutSTR(char *str);
+
+/**
+ * @brief	Sets the state of a board LED to on or off
+ * @param	LEDNumber	: LED number to set state for
+ * @param	State		: true for on, false for off
+ * @return	None
+ */
+void Board_LED_Set(uint8_t LEDNumber, bool State);
+
+/**
+ * @brief	Returns the current state of a board LED
+ * @param	LEDNumber	: LED number to set state for
+ * @return	true if the LED is on, otherwise false
+ */
+bool Board_LED_Test(uint8_t LEDNumber);
+
+/**
+ * @brief	Toggles the current state of a board LED
+ * @param	LEDNumber	: LED number to change state for
+ * @return	None
+ */
+void Board_LED_Toggle(uint8_t LEDNumber);
+
+/**
+ * @brief	Turn on Board LCD Backlight
+ * @param	Intensity	: Backlight intensity (0 = off, >=1 = on)
+ * @return	None
+ * @note	On boards where a GPIO is used to control backlight on/off state, a '0' or '1'
+ * value will turn off or on the backlight. On some boards, a non-0 value will
+ * control backlight intensity via a PWN. For PWM systems, the intensity value
+ * is a percentage value between 0 and 100%.
+ */
+void Board_SetLCDBacklight(uint8_t Intensity);
+
+/**
+ * @brief Function prototype for a MS delay function. Board layers or example code may
+ *        define this function as needed.
+ */
+typedef void (*p_msDelay_func_t)(uint32_t);
+
+/* The DEBUG* functions are selected based on system configuration.
+   Code that uses the DEBUG* functions will have their I/O routed to
+   the UART, semihosting, or nowhere. */
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+#define DEBUGINIT()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) printf(str)
+#define DEBUGIN() (int) EOF
+
+#else
+#define DEBUGINIT() Board_Debug_Init()
+#define DEBUGOUT(...) printf(__VA_ARGS__)
+#define DEBUGSTR(str) Board_UARTPutSTR(str)
+#define DEBUGIN() Board_UARTGetChar()
+#endif /* defined(DEBUG_SEMIHOSTING) */
+
+#else
+#define DEBUGINIT()
+#define DEBUGOUT(...)
+#define DEBUGSTR(str)
+#define DEBUGIN() (int) EOF
+#endif /* defined(DEBUG_ENABLE) */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_API_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/inc/board.h ./board/inc/board.h
--- a_tnusFF/board/inc/board.h	1969-12-31 21:00:00.000000000 -0300
+++ ./board/inc/board.h	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,113 @@
+/*
+ * @brief NXP LPCXpresso LPC54102 board file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __BOARD_H_
+#define __BOARD_H_
+
+#include "chip.h"
+/* board_api.h is included at the bottom of this file after DEBUG setup */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup BOARD_LPCXPRESSO_54102 LPC54102 LPCXpresso LQFP board support software API functions
+ * @ingroup LPCOPEN_5410X_BOARD_LPCXPRESSO_54102
+ * The board support software API functions provide some simple abstracted
+ * functions used across multiple LPCOpen board examples. See @ref BOARD_COMMON_API
+ * for the functions defined by this board support layer.<br>
+ * @{
+ */
+
+/** @defgroup BOARD_LPCXPRESSO_54102_OPTIONS BOARD: LPC54102 LPCXpresso LQFP board build options
+ * This board has options that configure its operation at build-time.<br>
+ * @{
+ */
+
+/** Define DEBUG_ENABLE to enable IO via the DEBUGSTR, DEBUGOUT, and
+    DEBUGIN macros. If not defined, DEBUG* functions will be optimized
+    out of the code at build time.
+ */
+#define DEBUG_ENABLE
+
+/** Define DEBUG_SEMIHOSTING along with DEBUG_ENABLE to enable IO support
+    via semihosting. You may need to use a C library that supports
+    semihosting with this option.
+ */
+// #define DEBUG_SEMIHOSTING
+
+/** Board UART used for debug output and input using the DEBUG* macros. This
+    is also the port used for Board_UARTPutChar, Board_UARTGetChar, and
+    Board_UARTPutSTR functions. Although you can setup multiple UARTs here,
+    the board code only supports UART0 in the Board_UART_Init() function,
+    so be sure to change it there too if not using UART0.
+ */
+#define DEBUG_UART                      LPC_USART0
+
+/** Bit rate for the debug UART in Hz */
+#define DEBUGBAUDRATE       (115200)
+
+/** Main system clock rate in Hz for this board. Select a clock rate between
+    1500000Hz and 150000000Hz for the main system (CPU) clock for this board. */
+#define BOARD_MAINCLOCKRATE     (96000000)
+
+/** External clock rate on the CLKIN pin in Hz for this board. If not used,
+    set this to 0. Otherwise, set it to the exact rate in Hz this pin is
+    being driven at. */
+#define BOARD_EXTCLKINRATE      (0)
+
+/** Set the BOARD_USECLKINSRC definition to (1) to use the external clock
+    input pin as the PLL source. The BOARD_ECTCLKINRATE definition must
+    be setup with the correct rate in the CLKIN pin. Set this to (0) to
+    use the IRC for the PLL source. */
+#define BOARD_USECLKINSRC       (0)
+
+/**
+ * @}
+ */
+
+/* Board name */
+#define BOARD_NXP_LPCXPRESSO_54102
+
+/** Board version definition, supports LQFP version of the board */
+#define BOARD_REV1_LQFP
+
+/**
+ * @}
+ */
+
+#include "board_api.h"
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __BOARD_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/inc/retarget.h ./board/inc/retarget.h
--- a_tnusFF/board/inc/retarget.h	1969-12-31 21:00:00.000000000 -0300
+++ ./board/inc/retarget.h	2016-10-22 23:17:43.472840275 -0300
@@ -0,0 +1,251 @@
+/*
+ * @brief	IO redirection support
+ *
+ * This file adds re-direction support to the library for various
+ * projects. It can be configured in one of 3 ways - no redirection,
+ * redirection via a UART, or redirection via semihosting. If DEBUG
+ * is not defined, all printf statements will do nothing with the
+ * output being throw away. If DEBUG is defined, then the choice of
+ * output is selected by the DEBUG_SEMIHOSTING define. If the
+ * DEBUG_SEMIHOSTING is not defined, then output is redirected via
+ * the UART. If DEBUG_SEMIHOSTING is defined, then output will be
+ * attempted to be redirected via semihosting. If the UART method
+ * is used, then the Board_UARTPutChar and Board_UARTGetChar
+ * functions must be defined to be used by this driver and the UART
+ * must already be initialized to the correct settings.
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "board.h"
+
+/* Keil (Realview) support */
+#if defined(__CC_ARM)
+
+#include <stdio.h>
+#include <rt_misc.h>
+
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+#define ITM_Port8(n)    (*((volatile unsigned char *) (0xE0000000 + 4 * n)))
+#define ITM_Port16(n)   (*((volatile unsigned short *) (0xE0000000 + 4 * n)))
+#define ITM_Port32(n)   (*((volatile unsigned long *) (0xE0000000 + 4 * n)))
+
+#define DEMCR           (*((volatile unsigned long *) (0xE000EDFC)))
+#define TRCENA          0x01000000
+
+/* Write to SWO */
+void _ttywrch(int ch)
+{
+	if (DEMCR & TRCENA) {
+		while (ITM_Port32(0) == 0) {}
+		ITM_Port8(0) = ch;
+	}
+}
+
+#else
+static INLINE void BoardOutChar(char ch)
+{
+	Board_UARTPutChar(ch);
+}
+
+#endif /* defined(DEBUG_SEMIHOSTING) */
+#endif /* defined(DEBUG_ENABLE) */
+
+struct __FILE {
+	int handle;
+};
+
+FILE __stdout;
+FILE __stdin;
+FILE __stderr;
+
+void *_sys_open(const char *name, int openmode)
+{
+	return 0;
+}
+
+int fputc(int c, FILE *f)
+{
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+	_ttywrch(c);
+#else
+	BoardOutChar((char) c);
+#endif
+#endif
+	return 0;
+}
+
+int fgetc(FILE *f)
+{
+#if defined(DEBUG_ENABLE) && !defined(DEBUG_SEMIHOSTING)
+	return Board_UARTGetChar();
+#else
+	return 0;
+#endif
+}
+
+int ferror(FILE *f)
+{
+	return EOF;
+}
+
+void _sys_exit(int return_code)
+{
+label:
+	__WFI();
+	goto label;	/* endless loop */
+}
+
+#endif /* defined (__CC_ARM) */
+
+/* IAR support */
+#if defined(__ICCARM__)
+/*******************
+ *
+ * Copyright 1998-2003 IAR Systems.  All rights reserved.
+ *
+ * $Revision: 30870 $
+ *
+ * This is a template implementation of the "__write" function used by
+ * the standard library.  Replace it with a system-specific
+ * implementation.
+ *
+ * The "__write" function should output "size" number of bytes from
+ * "buffer" in some application-specific way.  It should return the
+ * number of characters written, or _LLIO_ERROR on failure.
+ *
+ * If "buffer" is zero then __write should perform flushing of
+ * internal buffers, if any.  In this case "handle" can be -1 to
+ * indicate that all handles should be flushed.
+ *
+ * The template implementation below assumes that the application
+ * provides the function "MyLowLevelPutchar".  It should return the
+ * character written, or -1 on failure.
+ *
+ ********************/
+
+#include <yfuns.h>
+
+#if defined(DEBUG_ENABLE) && !defined(DEBUG_SEMIHOSTING)
+
+_STD_BEGIN
+
+#pragma module_name = "?__write"
+
+/*
+   If the __write implementation uses internal buffering, uncomment
+   the following line to ensure that we are called with "buffer" as 0
+   (i.e. flush) when the application terminates. */
+size_t __write(int handle, const unsigned char *buffer, size_t size)
+{
+#if defined(DEBUG_ENABLE)
+	size_t nChars = 0;
+
+	if (buffer == 0) {
+		/*
+		   This means that we should flush internal buffers.  Since we
+		   don't we just return.  (Remember, "handle" == -1 means that all
+		   handles should be flushed.)
+		 */
+		return 0;
+	}
+
+	/* This template only writes to "standard out" and "standard err",
+	   for all other file handles it returns failure. */
+	if (( handle != _LLIO_STDOUT) && ( handle != _LLIO_STDERR) ) {
+		return _LLIO_ERROR;
+	}
+
+	for ( /* Empty */; size != 0; --size) {
+		Board_UARTPutChar(*buffer++);
+		++nChars;
+	}
+
+	return nChars;
+#else
+	return size;
+#endif /* defined(DEBUG_ENABLE) */
+}
+
+_STD_END
+#endif
+
+#endif /* defined (__ICCARM__) */
+
+#if defined( __GNUC__ )
+/* Include stdio.h to pull in __REDLIB_INTERFACE_VERSION__ */
+#include <stdio.h>
+
+#if (__REDLIB_INTERFACE_VERSION__ >= 20000)
+/* We are using new Redlib_v2 semihosting interface */
+	#define WRITEFUNC __sys_write
+	#define READFUNC __sys_readc
+#else
+/* We are using original Redlib semihosting interface */
+	#define WRITEFUNC __write
+	#define READFUNC __readc
+#endif
+
+#if defined(DEBUG_ENABLE)
+#if defined(DEBUG_SEMIHOSTING)
+/* Do nothing, semihosting is enabled by default in LPCXpresso */
+#endif /* defined(DEBUG_SEMIHOSTING) */
+#endif /* defined(DEBUG_ENABLE) */
+
+#if !defined(DEBUG_SEMIHOSTING)
+int WRITEFUNC(int iFileHandle, char *pcBuffer, int iLength)
+{
+#if defined(DEBUG_ENABLE)
+	unsigned int i;
+	for (i = 0; i < iLength; i++) {
+		Board_UARTPutChar(pcBuffer[i]);
+	}
+#endif
+
+	return iLength;
+}
+
+/* Called by bottom level of scanf routine within RedLib C library to read
+   a character. With the default semihosting stub, this would read the character
+   from the debugger console window (which acts as stdin). But this version reads
+   the character from the LPC1768/RDB1768 UART. */
+int READFUNC(void)
+{
+#if defined(DEBUG_ENABLE)
+	int c = Board_UARTGetChar();
+	return c;
+
+#else
+	return (int) -1;
+#endif
+}
+
+#endif /* !defined(DEBUG_SEMIHOSTING) */
+#endif /* defined ( __GNUC__ ) */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/Makefile ./board/Makefile
--- a_tnusFF/board/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ ./board/Makefile	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,39 @@
+# Copyright 2016, Pablo Ridolfi
+# All rights reserved.
+#
+# This file is part of Workspace.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its
+#    contributors may be used to endorse or promote products derived from this
+#    software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+
+board_PATH := modules/lpc54102_m4/board
+
+board_SRC_FILES := $(wildcard $(board_PATH)/src/*.c) \
+                   $(wildcard $(board_PATH)/src/*.S)
+
+board_INC_FOLDERS := $(board_PATH)/inc
+
+board_SRC_FOLDERS := $(board_PATH)/src
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/src/board.c ./board/src/board.c
--- a_tnusFF/board/src/board.c	1969-12-31 21:00:00.000000000 -0300
+++ ./board/src/board.c	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,163 @@
+/*
+ * @brief LPCXpresso LPC54102 board file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include <string.h>
+#include "board.h"
+#include "retarget.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Be careful that these pins are set to output now once Board_LED_Init() is
+   called. */
+static const uint8_t ledBits[] = {29, 30, 31};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/* Clock rate on the CLKIN pin */
+const uint32_t ExtClockIn = BOARD_EXTCLKINRATE;
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+#define ABS(x) ((int) (x) < 0 ? -(x) : (x))
+
+/* Initialize the LEDs on the NXP LPC54000 LPCXpresso Board */
+static void Board_LED_Init(void)
+{
+	int i;
+
+	/* Pin muxing setup as part of board_sysinit */
+	for (i = 0; i < sizeof(ledBits); i++) {
+		Chip_GPIO_SetPinDIROutput(LPC_GPIO, 0, ledBits[i]);
+		Chip_GPIO_SetPinState(LPC_GPIO, 0, ledBits[i], true);
+	}
+}
+
+/* Board Debug UART Initialisation function */
+static void Board_UART_Init(void)
+{
+#if defined(DEBUG_UART)
+	Chip_UART_Init(DEBUG_UART);
+	Chip_UART_ConfigData(DEBUG_UART, UART_CFG_DATALEN_8 | UART_CFG_STOPLEN_1 | UART_CFG_PARITY_NONE);
+	Chip_UART_Enable(DEBUG_UART);
+	Chip_UART_TXEnable(DEBUG_UART);
+	Chip_UART_SetBaud(DEBUG_UART, DEBUGBAUDRATE);
+#endif
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set the LED to the state of "On" */
+void Board_LED_Set(uint8_t LEDNumber, bool On)
+{
+	if (LEDNumber < sizeof(ledBits)) {
+		Chip_GPIO_SetPinState(LPC_GPIO, 0, ledBits[LEDNumber], (bool) !On);
+	}
+}
+
+/* Return the state of LEDNumber */
+bool Board_LED_Test(uint8_t LEDNumber)
+{
+	if (LEDNumber < sizeof(ledBits)) {
+		return (bool) !Chip_GPIO_GetPinState(LPC_GPIO, 0, ledBits[LEDNumber]);
+	}
+
+	return false;
+}
+
+/* Toggles the current state of a board LED */
+void Board_LED_Toggle(uint8_t LEDNumber)
+{
+	if (LEDNumber < sizeof(ledBits)) {
+		Chip_GPIO_SetPinToggle(LPC_GPIO, 0, ledBits[LEDNumber]);
+	}
+}
+
+/* Sends a character on the UART */
+void Board_UARTPutChar(char ch)
+{
+#if defined(DEBUG_UART)
+	Chip_UART_SendBlocking(DEBUG_UART, &ch, 1);
+#endif
+}
+
+/* Gets a character from the UART, returns EOF if no character is ready */
+int Board_UARTGetChar(void)
+{
+#if defined(DEBUG_UART)
+	uint8_t ch;
+	if (Chip_UART_Read(DEBUG_UART, &ch, 1) == 1) {
+		return (int) ch;
+	}
+#endif
+	return EOF;
+}
+
+/* Outputs a string on the debug UART */
+void Board_UARTPutSTR(char *str)
+{
+#if defined(DEBUG_UART)
+	Chip_UART_SendBlocking(DEBUG_UART, str, strlen(str));
+#endif
+}
+
+/* Initialize debug output via UART for board */
+void Board_Debug_Init(void)
+{
+#if defined(DEBUG_UART)
+	Board_UART_Init();
+#endif
+}
+
+/* Set up and initialize all required blocks and functions related to the
+   board hardware */
+void Board_Init(void)
+{
+	/* INMUX and IOCON are used by many apps, enable both INMUX and IOCON clock bits here. */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_INPUTMUX);
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_IOCON);
+
+	/* Sets up DEBUG UART */
+	DEBUGINIT();
+
+	/* Initialize GPIO */
+	Chip_GPIO_Init(LPC_GPIO);
+
+	/* Initialize the LEDs. Be careful with below routine, once it's called some of the I/O will be set to output. */
+	Board_LED_Init();
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/board/src/board_sysinit.c ./board/src/board_sysinit.c
--- a_tnusFF/board/src/board_sysinit.c	1969-12-31 21:00:00.000000000 -0300
+++ ./board/src/board_sysinit.c	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,216 @@
+/*
+ * @brief NXP LPCXpresso 54102 Sysinit file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+ #include "board.h"
+
+/* The System initialization code is called prior to the application and
+   initializes the board for run-time operation. Board initialization
+   for the NXP LPC54102 board includes default pin muxing and clock setup
+   configuration. */
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Pin muxing table, only items that need changing from their default pin
+   state are in this table. Not every pin is mapped. */
+STATIC const PINMUX_GRP_T pinmuxing[] = {
+	/* UART0 */
+	{0, 0,  (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART0 RX */
+	{0, 1,  (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART0 TX */
+
+	/* UART1 */
+	{0, 5,  (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART1 RX */
+	{0, 25, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART1 CTS */
+	{1, 10, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART1 TX */
+	{1, 11, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART1 RTS */
+
+	/* UART3 */
+	{1, 12, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART3 TX */
+	{1, 13, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* UART3 RX */
+
+	/* SPI0 (bridge) */
+	{0, 12, (IOCON_FUNC1 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* BRIDGE_MOSI (SPI MOSI) */
+	{0, 13, (IOCON_FUNC1 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* BRIDGE_MISO (MISO) */
+	/* 0, 14 BRIDGE_SSEL is configured in ConfigureBridgeSSEL() */
+	{1, 3,  (IOCON_FUNC5 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* BRIDGE_SCK (SCK) */
+	{0, 19, (IOCON_FUNC0 | IOCON_MODE_PULLUP | IOCON_DIGITAL_EN)},	/* BRIDGE_INTR (GPIO) */
+	{0, 20, (IOCON_FUNC0 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* BRIDGE_GPIO (GPIO) */
+
+	/* SPI1 (master) */
+	{1, 6,  (IOCON_FUNC2 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* SPI1_SCK */
+	{1, 7,  (IOCON_FUNC2 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* SPI1_MOSI */
+	{1, 14, (IOCON_FUNC4 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* SPI1_MISO */
+	{1, 15, (IOCON_FUNC4 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* SPI1_SSEL0 */
+
+	/* I2C0 standard/fast (master) */
+	{0, 23, (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN | IOCON_STDI2C_EN)},	/* I2C0_SCL (SCL) */
+	{0, 24, (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN | IOCON_STDI2C_EN)},	/* I2C0_SDA-WAKEUP (SDA) */
+
+	/* I2C1 standard/fast (bridge) */
+	{0, 27, (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN | IOCON_STDI2C_EN)},	/* BRIDGE_SCL (SCL) */
+	{0, 28, (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN | IOCON_STDI2C_EN)},	/* BRIDGE_SDA (SDA) */
+
+	/* ADC inputs */
+	{1, 0,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC3 */
+	{1, 1,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC4 */
+	{1, 2,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC5 */
+	{1, 4,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC7 */
+	{1, 5,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC8 */
+	{1, 8,  (IOCON_FUNC0 | IOCON_MODE_INACT)},	/* ADC11 */
+
+	/* Misc */
+	{0, 2,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* ARDUINO_INT */
+	{0, 3,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B1_MAT3 */
+	{0, 6,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B0_MAT1 */
+	{0, 7,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B0_MAT2 */
+	{0, 8,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B0_MAT3 */
+	{0, 9,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* DMIC_DATA */
+	{0, 10, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* BTLE_CONN */
+	{0, 11, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* DMIC_CLKIN */
+	{0, 21, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CLKOUT-CT32B3_MAT0 */
+	{0, 26, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* I2C1_SDA-CT32B0_CAP3 */
+	{1, 9,  (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* BTLE_CMD_DAT */
+	{1, 16, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B0_MAT0 */
+	{1, 17, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* IR_LEARN_EN */
+
+	/* Debugger signals */
+	{0, 15, (IOCON_FUNC2 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* SWO */
+#if 0
+	/* Not setup by SystemInit(), since default state after reset is already correct */
+	{0, 16, (IOCON_FUNC5 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* SWCLK_TCK */
+	{0, 17, (IOCON_FUNC5 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* SWDIO */
+#endif
+
+	/* Sensor related */
+	{0, 4,  (IOCON_FUNC0 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* GYR_INT1 (GPIO input) */
+	{0, 18, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)},	/* CT32B0_MAT0-ACCL_INT1 */
+	{0, 22, (IOCON_FUNC0 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN)},/* MAG_DRDY_INT (GPIO input) */
+
+	/* LEDs on P0.29, P0.30, and P0.31 are set as part of Board_LED_Init(), left in GPIO state */
+};
+
+#ifndef BOARD_USECLKINSRC
+#define BOARD_USECLKINSRC   (0)
+#endif
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+#define BRIDGE_SSEL_PORT 0
+#define BRIDGE_SSEL_PIN 14
+static void ConfigureBridgeSSEL(void)
+{
+	PINMUX_GRP_T pinMuxBridgeSSEL[] = {
+		{BRIDGE_SSEL_PORT, BRIDGE_SSEL_PIN, (IOCON_FUNC0 | IOCON_MODE_INACT | IOCON_DIGITAL_EN)}
+	};
+	/* Default bits to Link processor powered down. */
+	uint32_t functionBits = (IOCON_FUNC1 | IOCON_MODE_PULLDOWN | IOCON_DIGITAL_EN);
+
+	/* Set the bridge SSEL pin to GPIO pull down so we can read the state */
+	Chip_IOCON_SetPinMuxing(LPC_IOCON, pinMuxBridgeSSEL, sizeof(pinMuxBridgeSSEL) / sizeof(PINMUX_GRP_T));
+
+	/* Drive the bridge SSEL pin low and then read it back */
+	Chip_GPIO_SetPinDIROutput(LPC_GPIO, BRIDGE_SSEL_PORT, BRIDGE_SSEL_PIN);
+	Chip_GPIO_SetPinState(LPC_GPIO, BRIDGE_SSEL_PORT, BRIDGE_SSEL_PIN, false);
+
+	/* Set direction back to input and if the pin reads high, we know the link processor is powered */
+	Chip_GPIO_SetPinDIRInput(LPC_GPIO, BRIDGE_SSEL_PORT, BRIDGE_SSEL_PIN);
+	if (Chip_GPIO_GetPinState(LPC_GPIO, BRIDGE_SSEL_PORT, BRIDGE_SSEL_PIN)) {
+
+		/* Set function bits when Link processor present */
+		functionBits = (IOCON_FUNC1 | IOCON_MODE_INACT | IOCON_DIGITAL_EN);
+	}
+
+	pinMuxBridgeSSEL[0].modefunc = functionBits;
+	Chip_IOCON_SetPinMuxing(LPC_IOCON, pinMuxBridgeSSEL, sizeof(pinMuxBridgeSSEL) / sizeof(PINMUX_GRP_T));
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Sets up system pin muxing */
+void Board_SetupMuxing(void)
+{
+	/* Enable IOCON clock */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_IOCON);
+
+	Chip_IOCON_SetPinMuxing(LPC_IOCON, pinmuxing, sizeof(pinmuxing) / sizeof(PINMUX_GRP_T));
+
+	/* Bridge SSEL requires detection to set state correctly */
+	ConfigureBridgeSSEL();
+
+	/* IOCON clock left on, this is needed if CLKIN is used. */
+}
+
+/* Set up and initialize clocking prior to call to main */
+void Board_SetupClocking(void)
+{
+	uint32_t freq = BOARD_MAINCLOCKRATE;
+
+	/* The IRC is always the first clock source even if CLK_IN is used later.
+	   Once CLK_IN is selected as the clock source. We can turned off the IRC later.
+	   Turn on the IRC by clearing the power down bit */
+	Chip_SYSCON_PowerUp(SYSCON_PDRUNCFG_PD_IRC_OSC | SYSCON_PDRUNCFG_PD_IRC);
+
+#if BOARD_USECLKINSRC == (0)
+
+	/* Check if the Chip can support higher frequency */
+#if (BOARD_MAINCLOCKRATE > 96000000)
+	if (LPC_SYSCON->DEVICE_ID1 < V4_UID) {
+		/* Older version of chips does not support > 96MHz (see errata) */
+		freq = 96000000;
+	}
+#endif
+	/* Setup PLL based on (internal) IRC clocking */
+	Chip_SetupIrcClocking(freq);
+
+#else
+	/* Setup PLL based on (external) CLKIN clocking */
+	Chip_SetupExtInClocking(freq);
+#endif
+
+	/* Select the CLKOUT clocking source */
+	Chip_Clock_SetCLKOUTSource(SYSCON_CLKOUTSRC_MAINCLK, 1);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Board_SystemInit(void)
+{
+	/* Setup system clocking and muxing */
+	Board_SetupMuxing();
+	Board_SetupClocking();
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/adc_5410x.h ./chip/inc/adc_5410x.h
--- a_tnusFF/chip/inc/adc_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/adc_5410x.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,637 @@
+/*
+ * @brief LPC5410X ADC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ADC_5410X_H_
+#define __ADC_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ADC_5410X CHIP:  LPC5410X A/D conversion driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/** Sequence index enumerations, used in various parts of the code for
+    register indexing and sequencer selection */
+typedef enum {
+	ADC_SEQA_IDX = 0,
+	ADC_SEQB_IDX
+} ADC_SEQ_IDX_T;
+
+/**
+ * @brief ADC register block structure
+ */
+typedef struct {	/*!< ADCn Structure */
+	__IO uint32_t CTRL;
+	__O uint32_t RESERVED0;
+	__IO uint32_t SEQ_CTRL[2];
+	__IO uint32_t SEQ_GDAT[2];
+	__IO uint32_t RESERVED1[2];
+	__IO uint32_t DAT[12];
+	__IO uint32_t THR_LOW[2];
+	__IO uint32_t THR_HIGH[2];
+	__IO uint32_t CHAN_THRSEL;
+	__IO uint32_t INTEN;
+	__IO uint32_t FLAGS;
+	__IO uint32_t STARTUP;
+	__IO uint32_t CALIBR;
+} LPC_ADC_T;
+
+/** Maximum sample rate in Hz (12-bit conversions) */
+#define ADC_MAX_SAMPLE_RATE 48000000
+#define ADC_MAX_CHANNEL_NUM 12
+
+/**
+ * @brief ADC register support bitfields and mask
+ */
+/** ADC Control register bit fields */
+#define ADC_CR_CLKDIV_MASK      (0xFF << 0)				/*!< Mask for Clock divider value */
+#define ADC_CR_CLKDIV_BITPOS    (0)						/*!< Bit position for Clock divider value */
+#define ADC_CR_ASYNC_MODE       (1 << 8)				/*!< Asynchronous mode enable bit */
+#define ADC_CR_RESOL(n)         ((n) << 9)				/*!< 2-bits, 6(0x0),8(0x1),10(0x2),12(0x3)-bit mode enable bit */
+#define ADC_CR_LPWRMODEBIT      (1 << 10)				/*!< Low power mode enable bit */
+#define ADC_CR_BYPASS           (1 << 11)				/*!< Bypass mode */
+#define ADC_CR_TSAMP(n)         ((n) << 12)				/*!< 3-bits, 2.5(0x0),3.5(0x1),4.5(0x2),5.5(0x3),6.5(0x4),7.5(0x5),8.5(0x6),9.5(0x7) ADC clocks sampling time */
+#define ADC_CR_CALMODEBIT       (1 << 30)				/*!< Self calibration cycle enable bit */
+#define ADC_CR_BITACC(n)        ((((n) & 0x1) << 9))	/*!< 12-bit or 10-bit ADC accuracy */
+#define ADC_CR_CLKDIV(n)        ((((n) & 0xFF) << 0))	/*!< The APB clock (PCLK) is divided by (this value plus one) to produce the clock for the A/D */
+#define ADC_SAMPLE_RATE_CONFIG_MASK (ADC_CR_CLKDIV(0xFF) | ADC_CR_BITACC(0x01))
+
+/** ADC Sequence Control register bit fields */
+#define ADC_SEQ_CTRL_CHANSEL(n)             (1 << (n))		/*!< Channel select macro */
+#define ADC_SEQ_CTRL_CHANSEL_BITPOS(n)      ((n) << 0)				/*!< Channel select macro */
+#define ADC_SEQ_CTRL_CHANSEL_MASK           (0xFFF)				/*!< Channel select mask */
+
+/**
+ * @brief ADC sampling time bits 12, 13 and 14
+ */
+typedef enum _ADC_TSAMP_T {
+	ADC_TSAMP_2CLK5 = 0,
+	ADC_TSAMP_3CLK5,
+	ADC_TSAMP_4CLK5,
+	ADC_TSAMP_5CLK5,
+	ADC_TSAMP_6CLK5,
+	ADC_TSAMP_7CLK5,
+	ADC_TSAMP_8CLK5,
+	ADC_TSAMP_9CLK5,
+} ADC_TSAMP_T;
+
+/** SEQ_CTRL register bit fields */
+// #define ADC_SEQ_CTRL_TRIGGER(n)          ((n)<<12)
+#define ADC_SEQ_CTRL_HWTRIG_POLPOS       (1 << 18)		/*!< HW trigger polarity - positive edge */
+#define ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS   (1 << 19)		/*!< HW trigger bypass synchronisation */
+#define ADC_SEQ_CTRL_START               (1 << 26)		/*!< Start conversion enable bit */
+#define ADC_SEQ_CTRL_BURST               (1 << 27)		/*!< Repeated conversion enable bit */
+#define ADC_SEQ_CTRL_SINGLESTEP          (1 << 28)		/*!< Single step enable bit */
+#define ADC_SEQ_CTRL_LOWPRIO             (1 << 29)		/*!< High priority enable bit (regardless of name) */
+#define ADC_SEQ_CTRL_MODE_EOS            (1 << 30)		/*!< Mode End of sequence enable bit */
+#define ADC_SEQ_CTRL_SEQ_ENA             (1UL << 31)	/*!< Sequence enable bit */
+
+/** ADC global data register bit fields */
+#define ADC_SEQ_GDAT_RESULT_MASK         (0xFFF << 4)	/*!< Result value mask */
+#define ADC_SEQ_GDAT_RESULT_BITPOS       (4)			/*!< Result start bit position */
+#define ADC_SEQ_GDAT_THCMPRANGE_MASK     (0x3 << 16)	/*!< Comparion range mask */
+#define ADC_SEQ_GDAT_THCMPRANGE_BITPOS   (16)			/*!< Comparison range bit position */
+#define ADC_SEQ_GDAT_THCMPCROSS_MASK     (0x3 << 18)	/*!< Comparion cross mask */
+#define ADC_SEQ_GDAT_THCMPCROSS_BITPOS   (18)			/*!< Comparison cross bit position */
+#define ADC_SEQ_GDAT_CHAN_MASK           (0xF << 26)	/*!< Channel number mask */
+#define ADC_SEQ_GDAT_CHAN_BITPOS         (26)			/*!< Channel number bit position */
+#define ADC_SEQ_GDAT_OVERRUN             (1 << 30)		/*!< Overrun bit */
+#define ADC_SEQ_GDAT_DATAVALID           (1UL << 31)	/*!< Data valid bit */
+
+/** ADC Data register bit fields */
+#define ADC_DR_RESULT_BITPOS       (4)			/*!< Result start bit position */
+#define ADC_DR_RESULT(n)           ((((n) >> 4) & 0xFFF))	/*!< Macro for getting the ADC data value */
+#define ADC_DR_THCMPRANGE_MASK     (0x3 << 16)			/*!< Comparion range mask */
+#define ADC_DR_THCMPRANGE_BITPOS   (16)					/*!< Comparison range bit position */
+#define ADC_DR_THCMPRANGE(n)       (((n) >> ADC_DR_THCMPRANGE_BITPOS) & 0x3)
+#define ADC_DR_THCMPCROSS_MASK     (0x3 << 18)			/*!< Comparion cross mask */
+#define ADC_DR_THCMPCROSS_BITPOS   (18)					/*!< Comparison cross bit position */
+#define ADC_DR_THCMPCROSS(n)       (((n) >> ADC_DR_THCMPCROSS_BITPOS) & 0x3)
+#define ADC_DR_CHAN_MASK           (0xF << 26)			/*!< Channel number mask */
+#define ADC_DR_CHAN_BITPOS         (26)					/*!< Channel number bit position */
+#define ADC_DR_CHANNEL(n)          (((n) >> ADC_DR_CHAN_BITPOS) & 0xF)	/*!< Channel number bit position */
+#define ADC_DR_OVERRUN             (1 << 30)			/*!< Overrun bit */
+#define ADC_DR_DATAVALID           (1UL << 31)			/*!< Data valid bit */
+#define ADC_DR_DONE(n)             (((n) >> 31))
+
+/** ADC low/high Threshold register bit fields */
+#define ADC_THR_VAL_MASK            (0xFFF << 4)		/*!< Threshold value bit mask */
+#define ADC_THR_VAL_POS             (4)					/*!< Threshold value bit position */
+
+/** ADC Threshold select register bit fields */
+#define ADC_THRSEL_CHAN_SEL_THR1(n) (1 << (n))			/*!< Select THR1 register for channel n */
+
+/** ADC Interrupt Enable register bit fields */
+#define ADC_INTEN_SEQA_ENABLE       (1 << 0)			/*!< Sequence A Interrupt enable bit */
+#define ADC_INTEN_SEQB_ENABLE       (1 << 1)			/*!< Sequence B Interrupt enable bit */
+#define ADC_INTEN_SEQN_ENABLE(seq)  (1 << (seq))		/*!< Sequence A/B Interrupt enable bit */
+#define ADC_INTEN_OVRRUN_ENABLE     (1 << 2)			/*!< Overrun Interrupt enable bit */
+#define ADC_INTEN_CMP_DISBALE       (0)					/*!< Disable comparison interrupt value */
+#define ADC_INTEN_CMP_OUTSIDETH     (1)					/*!< Outside threshold interrupt value */
+#define ADC_INTEN_CMP_CROSSTH       (2)					/*!< Crossing threshold interrupt value */
+#define ADC_INTEN_CMP_MASK          (3)					/*!< Comparison interrupt value mask */
+#define ADC_INTEN_CMP_ENABLE(isel, ch) (((isel) & ADC_INTEN_CMP_MASK) << ((2 * (ch)) + 3))	/*!< Interrupt selection for channel */
+
+/** ADC Flags register bit fields */
+#define ADC_FLAGS_THCMP_MASK(ch)    (1 << (ch))		/*!< Threshold comparison status for channel */
+#define ADC_FLAGS_OVRRUN_MASK(ch)   (1 << (12 + (ch)))	/*!< Overrun status for channel */
+#define ADC_FLAGS_SEQA_OVRRUN_MASK  (1 << 24)			/*!< Seq A Overrun status */
+#define ADC_FLAGS_SEQB_OVRRUN_MASK  (1 << 25)			/*!< Seq B Overrun status */
+#define ADC_FLAGS_SEQN_OVRRUN_MASK(seq) (1 << (24 + (seq)))	/*!< Seq A/B Overrun status */
+#define ADC_FLAGS_SEQA_INT_MASK     (1 << 28)			/*!< Seq A Interrupt status */
+#define ADC_FLAGS_SEQB_INT_MASK     (1 << 29)			/*!< Seq B Interrupt status */
+#define ADC_FLAGS_SEQN_INT_MASK(seq) (1 << (28 + (seq)))/*!< Seq A/B Interrupt status */
+#define ADC_FLAGS_THCMP_INT_MASK    (1 << 30)			/*!< Threshold comparison Interrupt status */
+#define ADC_FLAGS_OVRRUN_INT_MASK   (1UL << 31)			/*!< Overrun Interrupt status */
+
+/** ADC Startup register bit fields */
+#define ADC_STARTUP_ENABLE       (0x1 << 0)
+#define ADC_STARTUP_INIT         (0x1 << 1)
+
+/* ADC Calibration register definition */
+#define ADC_CALIB                       (0x1 << 0)
+#define ADC_CALREQD                     (0x1 << 1)
+
+/**
+ * @brief	Set Interrupt bits (safe)
+ * @param	pADC	: Pointer to ADC peripheral
+ * @param	intMask	: Mask of bits to be set
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_SetIntBits(LPC_ADC_T *pADC, uint32_t intMask)
+{
+	/* Read and write values may not be the same, write 0 to undefined bits */
+	pADC->INTEN = (pADC->INTEN | intMask) & 0x07FFFFFF;
+}
+
+/**
+ * @brief	Clear Interrupt bits (safe)
+ * @param	pADC	: Pointer to ADC peripheral
+ * @param	intMask	: Mask of bits to be cleared
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_ClearIntBits(LPC_ADC_T *pADC, uint32_t intMask)
+{
+	/* Read and write values may not be the same, write 0 to undefined bits */
+	pADC->INTEN = pADC->INTEN & (0x07FFFFFF & ~intMask);
+}
+
+/**
+ * @brief	Set Threshold select bits (safe)
+ * @param	pADC	: Pointer to ADC peripheral
+ * @param	mask	: Mask of bits to be set
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_SetTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
+{
+	/* Read and write values may not be the same, write 0 to undefined bits */
+	pADC->CHAN_THRSEL = (pADC->CHAN_THRSEL | mask) & 0x00000FFF;
+}
+
+/**
+ * @brief	Clear Threshold select bits (safe)
+ * @param	pADC	: Pointer to ADC peripheral
+ * @param	mask	: Mask of bits to be cleared
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_ClearTHRSELBits(LPC_ADC_T *pADC, uint32_t mask)
+{
+	/* Read and write values may not be the same, write 0 to undefined bits */
+	pADC->CHAN_THRSEL = pADC->CHAN_THRSEL & (0x00000FFF & ~mask);
+}
+
+/**
+ * @brief	Initialize the ADC peripheral
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	flags	: ADC flags for init (ADC_CR_MODE10BIT and/or ADC_CR_LPWRMODEBIT)
+ * @return	Nothing
+ * @note	To select low-power ADC mode, enable the ADC_CR_LPWRMODEBIT flag.
+ * To select 10-bit conversion mode, enable the ADC_CR_MODE10BIT flag.<br>
+ * Example: Chip_ADC_Init(LPC_ADC, (ADC_CR_MODE10BIT | ADC_CR_LPWRMODEBIT));
+ */
+void Chip_ADC_Init(LPC_ADC_T *pADC, uint32_t flags);
+
+/**
+ * @brief	Shutdown ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @return	Nothing
+ * @note	Disables the ADC clocks and ADC power
+ */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC);
+
+/**
+ * @brief	Set ADC divider
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	div		: ADC divider value to set minus 1
+ * @return	Nothing
+ * @note	The value is used as a divider to generate the ADC
+ * clock rate from the ADC input clock. The ADC input clock is based
+ * on the system clock. Valid values for this function are from 0 to 255
+ * with 0=divide by 1, 1=divide by 2, 2=divide by 3, etc.<br>
+ * Do not decrement this value by 1.<br>
+ * To set the ADC clock rate to 1MHz, use the following function:<br>
+ * Chip_ADC_SetDivider(LPC_ADC, (Chip_Clock_GetSystemClockRate() / 1000000) - 1);
+ */
+__STATIC_INLINE void Chip_ADC_SetDivider(LPC_ADC_T *pADC, uint8_t div)
+{
+	uint32_t temp;
+
+	temp = pADC->CTRL & ~(ADC_CR_CLKDIV_MASK);
+	pADC->CTRL = temp | (uint32_t) div;
+}
+
+/**
+ * @brief	Set ADC clock rate
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	rate	: rate in Hz to set ADC clock to (maximum ADC_MAX_SAMPLE_RATE)
+ * @return	Nothing
+ */
+void Chip_ADC_SetClockRate(LPC_ADC_T *pADC, uint32_t rate);
+
+/**
+ * @brief	Get ADC divider
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @return	the current ADC divider
+ * @note	This function returns the divider that is used to generate the
+ * ADC frequency. The returned value must be incremented by 1. The
+ * frequency can be determined with the following function:<br>
+ * adc_freq = Chip_Clock_GetSystemClockRate() / (Chip_ADC_GetDivider(LPC_ADC) + 1);
+ */
+__STATIC_INLINE uint8_t Chip_ADC_GetDivider(LPC_ADC_T *pADC)
+{
+	return pADC->CTRL & ADC_CR_CLKDIV_MASK;
+}
+
+/**
+ * @brief	Calibrate ADC upon startup or wakeup after powerdown
+ * @pre		ADC must be Initialized and Configured
+ * @param	pADC		: Pointer to ADC peripheral
+ * @return	Result of calibrarion operation
+ * @retval	LPC_OK				Calibration is successful
+ * @retval	ERR_ADC_NO_POWER	Unable to powerup ADC
+ * @retval	ERR_TIME_OUT		Calibration operation timed-out
+ */
+uint32_t Chip_ADC_Calibration(LPC_ADC_T *pADC);
+
+/**
+ * @brief	Helper function for safely setting ADC sequencer register bits
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to set bits for
+ * @param	bits		: Or'ed bits of a sequencer register to set
+ * @return	Nothing
+ * @note	This function will safely set the ADC sequencer register bits
+ * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
+ */
+__STATIC_INLINE void Chip_ADC_SetSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
+{
+	/* OR in passed bits */
+	pADC->SEQ_CTRL[seqIndex] = (pADC->SEQ_CTRL[seqIndex] & ~(0x3F << 20)) | bits;
+}
+
+/**
+ * @brief	Helper function for safely clearing ADC sequencer register bits
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to clear bits for
+ * @param	bits		: Or'ed bits of a sequencer register to clear
+ * @return	Nothing
+ * @note	This function will safely clear the ADC sequencer register bits
+ * while maintaining bits 20..25 as 0, regardless of the read state of those bits.
+ */
+__STATIC_INLINE void Chip_ADC_ClearSequencerBits(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t bits)
+{
+	/* Read sequencer register and mask off bits 20..25 */
+	pADC->SEQ_CTRL[seqIndex] = pADC->SEQ_CTRL[seqIndex] & ~((0x3F << 20) | bits);
+}
+
+/**
+ * @brief	Sets up ADC conversion sequencer A or B
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to setup
+ * @param	options		: OR'ed Sequencer options to setup (see notes)
+ * @return	Nothing
+ * @note	Sets up sequencer options for a conversion sequence. This function
+ * should be used to setup the selected channels for the sequence, the sequencer
+ * trigger, the trigger polarity, synchronization bypass, priority, and mode. All
+ * options are passed to the functions as a OR'ed list of values. This function will
+ * disable/clear the sequencer start/burst/single step/enable if they are enabled.<br>
+ * Select the channels by OR'ing in one or more ADC_SEQ_CTRL_CHANSEL(ch) values.<br>
+ * Select the hardware trigger by OR'ing in one ADC_SEQ_CTRL_HWTRIG_* value.<br>
+ * Select a positive edge hardware trigger by OR'ing in ADC_SEQ_CTRL_HWTRIG_POLPOS.<br>
+ * Select trigger bypass synchronisation by OR'ing in ADC_SEQ_CTRL_HWTRIG_SYNCBYPASS.<br>
+ * Select ADC single step on trigger/start by OR'ing in ADC_SEQ_CTRL_SINGLESTEP.<br>
+ * Select higher priority conversion on the other sequencer by OR'ing in ADC_SEQ_CTRL_LOWPRIO.<br>
+ * Select end of seqeuence instead of end of conversion interrupt by OR'ing in ADC_SEQ_CTRL_MODE_EOS.<br>
+ * Example for setting up sequencer A (channels 0-2, trigger on high edge of PIO0_2, interrupt on end of sequence):<br>
+ * Chip_ADC_SetupSequencer(LPC_ADC, ADC_SEQA_IDX, (
+ *     ADC_SEQ_CTRL_CHANSEL(0) | ADC_SEQ_CTRL_CHANSEL(1) | ADC_SEQ_CTRL_CHANSEL(2) |
+ *     ADC_SEQ_CTRL_HWTRIG_PIO0_2 | ADC_SEQ_CTRL_HWTRIG_POLPOS | ADC_SEQ_CTRL_MODE_EOS));
+ */
+__STATIC_INLINE void Chip_ADC_SetupSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex, uint32_t options)
+{
+	pADC->SEQ_CTRL[seqIndex] = options;
+}
+
+/**
+ * @brief	Get sequenceX control register value
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to setup
+ * @return	Sequencer control register value
+ */
+__STATIC_INLINE uint32_t Chip_ADC_GetSequencerCtrl(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	return pADC->SEQ_CTRL[seqIndex];
+}
+
+/**
+ * @brief	Enables a sequencer
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to enable
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_EnableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
+}
+
+/**
+ * @brief	Disables a sequencer
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to disable
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_DisableSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_SEQ_ENA);
+}
+
+/**
+ * @brief	Forces a sequencer trigger event (software trigger of ADC)
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to start
+ * @return	Nothing
+ * @note	This function sets the START bit for the sequencer to force a
+ * single conversion sequence or a single step conversion. START and BURST bits can not
+ * be set at the same time, thus, BURST bit will be cleared.
+ */
+__STATIC_INLINE void Chip_ADC_StartSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
+	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_START);
+}
+
+/**
+ * @brief	Starts sequencer burst mode
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to start burst on
+ * @return	Nothing
+ * @note	This function sets the BURST bit for the sequencer to force
+ * continuous conversion. Use Chip_ADC_StopBurstSequencer() to stop the
+ * ADC burst sequence. START and BURST bits can not be set at the same time, thus,
+ * START bit will be cleared.
+ */
+__STATIC_INLINE void Chip_ADC_StartBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	/* START and BURST bits can not be set at the same time. */
+	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_START);
+	Chip_ADC_SetSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
+}
+
+/**
+ * @brief	Stops sequencer burst mode
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to stop burst on
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_ADC_StopBurstSequencer(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	Chip_ADC_ClearSequencerBits(pADC, seqIndex, ADC_SEQ_CTRL_BURST);
+}
+
+/** ADC sequence global data register threshold comparison range enumerations */
+typedef enum {
+	ADC_DR_THCMPRANGE_INRANGE,
+	ADC_DR_THCMPRANGE_RESERVED,
+	ADC_DR_THCMPRANGE_BELOW,
+	ADC_DR_THCMPRANGE_ABOVE
+} ADC_DR_THCMPRANGE_T;
+
+/** ADC sequence global data register threshold comparison cross enumerations */
+typedef enum {
+	ADC_DR_THCMPCROSS_NOCROSS,
+	ADC_DR_THCMPCROSS_RESERVED,
+	ADC_DR_THCMPCROSS_DOWNWARD,
+	ADC_DR_THCMPCROSS_UPWARD
+} ADC_DR_THCMPCROSS_T;
+
+/**
+ * @brief	Read a ADC sequence global data register
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param	seqIndex	: Sequencer to read
+ * @return	Current raw value of the ADC sequence A or B global data register
+ * @note	This function returns the raw value of the data register and clears
+ * the overrun and datavalid status for the register. Once this register is read,
+ * the following functions can be used to parse the raw value:<br>
+ * uint32_t adcDataRawValue = Chip_ADC_GetGlobalDataReg(LPC_ADC, ADC_SEQA_IDX); // Get raw value
+ * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
+ * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
+ * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
+ * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
+ * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
+ * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
+ */
+__STATIC_INLINE uint32_t Chip_ADC_GetGlobalDataReg(LPC_ADC_T *pADC, ADC_SEQ_IDX_T seqIndex)
+{
+	return pADC->SEQ_GDAT[seqIndex];
+}
+
+/**
+ * @brief	Read a ADC data register
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	index	: Data register to read, 0-11
+ * @return	Current raw value of the ADC data register
+ * @note	This function returns the raw value of the data register and clears
+ * the overrun and datavalid status for the register. Once this register is read,
+ * the following functions can be used to parse the raw value:<br>
+ * uint32_t adcDataRawValue = Chip_ADC_GetDataReg(LPC_ADC, ADC_MAX_CHANNEL_NUM); // Get raw value
+ * uint32_t adcDataValue = ADC_DR_RESULT(adcDataRawValue); // Aligned and masked ADC data value
+ * ADC_DR_THCMPRANGE_T adcRange = (ADC_DR_THCMPRANGE_T) ADC_DR_THCMPRANGE(adcDataRawValue); // Sample range compared to threshold low/high
+ * ADC_DR_THCMPCROSS_T adcRange = (ADC_DR_THCMPCROSS_T) ADC_DR_THCMPCROSS(adcDataRawValue); // Sample cross compared to threshold low
+ * uint32_t channel = ADC_DR_CHANNEL(adcDataRawValue); // ADC channel for this sample/data
+ * bool adcDataOverrun = (bool) ((adcDataRawValue & ADC_DR_OVERRUN) != 0); // Data overrun flag
+ * bool adcDataValid = (bool) ((adcDataRawValue & ADC_SEQ_GDAT_DATAVALID) != 0); // Data valid flag
+ */
+__STATIC_INLINE uint32_t Chip_ADC_GetDataReg(LPC_ADC_T *pADC, uint8_t index)
+{
+	return pADC->DAT[index];
+}
+
+/**
+ * @brief	Set Threshold low value in ADC
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param   thrnum      : Threshold register value (1 for threshold register 1, 0 for threshold register 0)
+ * @param   value       : Threshold low data value (should be 12-bit value)
+ * @return	None
+ */
+__STATIC_INLINE void Chip_ADC_SetThrLowValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
+{
+	pADC->THR_LOW[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
+}
+
+/**
+ * @brief	Set Threshold high value in ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param   thrnum	: Threshold register value (1 for threshold register 1, 0 for threshold register 0)
+ * @param   value	: Threshold high data value (should be 12-bit value)
+ * @return	None
+ */
+__STATIC_INLINE void Chip_ADC_SetThrHighValue(LPC_ADC_T *pADC, uint8_t thrnum, uint16_t value)
+{
+	pADC->THR_HIGH[thrnum] = (((uint32_t) value) << ADC_THR_VAL_POS);
+}
+
+/**
+ * @brief	Select threshold 0 values for comparison for selected channels
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
+ * @return	None
+ * @note	Select multiple channels to use the threshold 0 comparison.<br>
+ * Example:<br>
+ * Chip_ADC_SelectTH0Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(1) | ADC_THRSEL_CHAN_SEL_THR1(2))); // Selects channels 1 and 2 for threshold 0
+ */
+__STATIC_INLINE void Chip_ADC_SelectTH0Channels(LPC_ADC_T *pADC, uint32_t channels)
+{
+	Chip_ADC_ClearTHRSELBits(pADC, channels);
+}
+
+/**
+ * @brief	Select threshold 1 value for comparison for selected channels
+ * @param	pADC		: The base of ADC peripheral on the chip
+ * @param   channels	: An OR'ed value of one or more ADC_THRSEL_CHAN_SEL_THR1(ch) values
+ * @return	None
+ * @note	Select multiple channels to use the 1 threshold comparison.<br>
+ * Example:<br>
+ * Chip_ADC_SelectTH1Channels(LPC_ADC, (ADC_THRSEL_CHAN_SEL_THR1(4) | ADC_THRSEL_CHAN_SEL_THR1(5))); // Selects channels 4 and 5 for 1 threshold
+ */
+__STATIC_INLINE void Chip_ADC_SelectTH1Channels(LPC_ADC_T *pADC, uint32_t channels)
+{
+	Chip_ADC_SetTHRSELBits(pADC, channels);
+}
+
+/**
+ * @brief	Enable interrupts in ADC (sequencers A/B and overrun)
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	intMask	: Interrupt values to be enabled (see notes)
+ * @return	None
+ * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
+ * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to enable the
+ * specific ADC interrupts.
+ */
+__STATIC_INLINE void Chip_ADC_EnableInt(LPC_ADC_T *pADC, uint32_t intMask)
+{
+	Chip_ADC_SetIntBits(pADC, intMask);
+}
+
+/**
+ * @brief	Disable interrupts in ADC (sequencers A/B and overrun)
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	intMask	: Interrupt values to be disabled (see notes)
+ * @return	None
+ * @note	Select one or more OR'ed values of ADC_INTEN_SEQA_ENABLE,
+ * ADC_INTEN_SEQB_ENABLE, and ADC_INTEN_OVRRUN_ENABLE to disable the
+ * specific ADC interrupts.
+ */
+__STATIC_INLINE void Chip_ADC_DisableInt(LPC_ADC_T *pADC, uint32_t intMask)
+{
+	Chip_ADC_ClearIntBits(pADC, intMask);
+}
+
+/** Threshold interrupt event options */
+typedef enum {
+	ADC_INTEN_THCMP_DISABLE,
+	ADC_INTEN_THCMP_OUTSIDE,
+	ADC_INTEN_THCMP_CROSSING,
+} ADC_INTEN_THCMP_T;
+
+/**
+ * @brief	Enable a threshold event interrupt in ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	ch		: ADC channel to set threshold inetrrupt for, 1-8
+ * @param	thInt	: Selected threshold interrupt type
+ * @return	None
+ */
+__STATIC_INLINE void Chip_ADC_SetThresholdInt(LPC_ADC_T *pADC, uint8_t ch, ADC_INTEN_THCMP_T thInt)
+{
+	int shiftIndex = 3 + (ch * 2);
+
+	/* Clear current bits first */
+	Chip_ADC_ClearIntBits(pADC, (ADC_INTEN_CMP_MASK << shiftIndex));
+
+	/* Set new threshold interrupt type */
+	Chip_ADC_SetIntBits(pADC, ((uint32_t) thInt << shiftIndex));
+}
+
+/**
+ * @brief	Get flags register in ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @return  Flags register value (ORed ADC_FLAG* values)
+ * @note	Mask the return value of this function with the ADC_FLAGS_*
+ * definitions to determine the overall ADC interrupt events.<br>
+ * Example:<br>
+ * if (Chip_ADC_GetFlags(LPC_ADC) & ADC_FLAGS_THCMP_MASK(3) // Check of threshold comp status for ADC channel 3
+ */
+__STATIC_INLINE uint32_t Chip_ADC_GetFlags(LPC_ADC_T *pADC)
+{
+	return pADC->FLAGS;
+}
+
+/**
+ * @brief	Clear flags register in ADC
+ * @param	pADC	: The base of ADC peripheral on the chip
+ * @param	flags	: An Or'ed values of ADC_FLAGS_* values to clear
+ * @return  Flags register value (ORed ADC_FLAG* values)
+ */
+__STATIC_INLINE void Chip_ADC_ClearFlags(LPC_ADC_T *pADC, uint32_t flags)
+{
+	pADC->FLAGS = flags;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ADC_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/chip.h ./chip/inc/chip.h
--- a_tnusFF/chip/inc/chip.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/chip.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,251 @@
+/*
+ * @brief LPC5410x basic chip inclusion file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CHIP_H_
+#define __CHIP_H_
+
+#include "lpc_types.h"
+#include "cmsis.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* LPCXpresso macro LPCOpen macro defines */
+#ifdef __LPC5410X__
+#define CHIP_LPC5410X
+#endif
+
+#ifndef CORE_M4
+#ifndef CORE_M0PLUS
+#error "CORE_M4 or CORE_M0PLUS is not defined for the LPC5410x architecture"
+#error "CORE_M4 or CORE_M0PLUS should be defined as part of your compiler define list"
+#endif
+#endif
+
+#ifndef CHIP_LPC5410X
+#error "The LPC5410X Chip include path is used for this build, but"
+#error "CHIP_LPC5410X is not defined!"
+#endif
+
+/** @defgroup PERIPH_5410X_BASE CHIP: LPC5410X Peripheral addresses and register set declarations
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/* Main memory addresses */
+#define LPC_FLASHMEM_BASE          0x00000000UL
+#define LPC_SRAM0_BASE             0x02000000UL
+#define LPC_SRAM1_BASE             0x02010000UL
+#define LPC_ROM_BASE               0x03000000UL
+#define LPC_SRAM2_BASE             0x03400000UL
+#define LPC_GPIO_PORT_BASE         0x1C000000UL
+#define LPC_DMA_BASE               0x1C004000UL
+#define LPC_CRC_BASE               0x1C010000UL
+#define LPC_SCT_BASE               0x1C018000UL
+#define LPC_MBOX_BASE              0x1C02C000UL
+#define LPC_ADC_BASE               0x1C034000UL
+#define LPC_FIFO_BASE              0x1C038000UL
+
+/* APB0 peripheral group addresses */
+#define LPC_SYSCON_BASE            0x40000000UL
+#define LPC_TIMER2_BASE            0x40004000UL
+#define LPC_TIMER3_BASE            0x40008000UL
+#define LPC_TIMER4_BASE            0x4000C000UL
+#define LPC_GPIO_GROUPINT0_BASE    0x40010000UL
+#define LPC_GPIO_GROUPINT1_BASE    0x40014000UL
+#define LPC_PIN_INT_BASE           0x40018000UL
+#define LPC_IOCON_BASE             0x4001C000UL
+#define LPC_UTICK_BASE             0x40020000UL
+#define LPC_FMC_BASE               0x40024000UL
+#define LPC_PMU_BASE               0x4002C000UL
+#define LPC_WWDT_BASE              0x40038000UL
+#define LPC_RTC_BASE               0x4003C000UL
+
+/* APB1 peripheral group addresses */
+#define LPC_ASYNC_SYSCON_BASE      0x40080000UL
+#define LPC_USART0_BASE            0x40084000UL
+#define LPC_USART1_BASE            0x40088000UL
+#define LPC_USART2_BASE            0x4008C000UL
+#define LPC_USART3_BASE            0x40090000UL
+#define LPC_I2C0_BASE              0x40094000UL
+#define LPC_I2C1_BASE              0x40098000UL
+#define LPC_I2C2_BASE              0x4009C000UL
+#define LPC_SPI0_BASE              0x400A4000UL
+#define LPC_SPI1_BASE              0x400A8000UL
+#define LPC_TIMER0_BASE            0x400B4000UL
+#define LPC_TIMER1_BASE            0x400B8000UL
+#define LPC_INMUX_BASE             0x40050000UL
+#define LPC_RITIMER_BASE           0x40070000UL
+#define LPC_MRT_BASE               0x40074000UL
+
+/* Main memory register access */
+#define LPC_GPIO           ((LPC_GPIO_T            *) LPC_GPIO_PORT_BASE)
+#define LPC_DMA            ((LPC_DMA_T             *) LPC_DMA_BASE)
+#define LPC_CRC            ((LPC_CRC_T             *) LPC_CRC_BASE)
+#define LPC_SCT            ((LPC_SCT_T             *) LPC_SCT_BASE)
+#define LPC_MBOX           ((LPC_MBOX_T            *) LPC_MBOX_BASE)
+#define LPC_ADC            ((LPC_ADC_T             *) LPC_ADC_BASE)
+#define LPC_FIFO           ((LPC_FIFO_T            *) LPC_FIFO_BASE)
+
+/* APB0 peripheral group register access */
+#define LPC_SYSCON         ((LPC_SYSCON_T          *) LPC_SYSCON_BASE)
+#define LPC_TIMER2         ((LPC_TIMER_T           *) LPC_TIMER2_BASE)
+#define LPC_TIMER3         ((LPC_TIMER_T           *) LPC_TIMER3_BASE)
+#define LPC_TIMER4         ((LPC_TIMER_T           *) LPC_TIMER4_BASE)
+#define LPC_GINT           ((LPC_GPIOGROUPINT_T    *) LPC_GPIO_GROUPINT0_BASE)
+#define LPC_PININT         ((LPC_PIN_INT_T         *) LPC_PIN_INT_BASE)
+#define LPC_IOCON          ((LPC_IOCON_T           *) LPC_IOCON_BASE)
+#define LPC_UTICK          ((LPC_UTICK_T           *) LPC_UTICK_BASE)
+#define LPC_WWDT           ((LPC_WWDT_T            *) LPC_WWDT_BASE)
+#define LPC_RTC            ((LPC_RTC_T             *) LPC_RTC_BASE)
+
+/* APB1 peripheral group register access */
+#define LPC_ASYNC_SYSCON   ((LPC_ASYNC_SYSCON_T    *) LPC_ASYNC_SYSCON_BASE)
+#define LPC_USART0         ((LPC_USART_T           *) LPC_USART0_BASE)
+#define LPC_USART1         ((LPC_USART_T           *) LPC_USART1_BASE)
+#define LPC_USART2         ((LPC_USART_T           *) LPC_USART2_BASE)
+#define LPC_USART3         ((LPC_USART_T           *) LPC_USART3_BASE)
+#define LPC_I2C0           ((LPC_I2C_T             *) LPC_I2C0_BASE)
+#define LPC_I2C1           ((LPC_I2C_T             *) LPC_I2C1_BASE)
+#define LPC_I2C2           ((LPC_I2C_T             *) LPC_I2C2_BASE)
+#define LPC_SCT0           LPC_SCT
+#define LPC_SPI0           ((LPC_SPI_T             *) LPC_SPI0_BASE)
+#define LPC_SPI1           ((LPC_SPI_T             *) LPC_SPI1_BASE)
+#define LPC_TIMER0         ((LPC_TIMER_T           *) LPC_TIMER0_BASE)
+#define LPC_TIMER1         ((LPC_TIMER_T           *) LPC_TIMER1_BASE)
+#define LPC_INMUX          ((LPC_INMUX_T           *) LPC_INMUX_BASE)
+#define LPC_RITIMER        ((LPC_RITIMER_T         *) LPC_RITIMER_BASE)
+#define LPC_MRT            ((LPC_MRT_T             *) LPC_MRT_BASE)
+#define LPC_PMU            ((LPC_PMU_T             *) LPC_PMU_BASE)
+
+/**
+ * @}
+ */
+
+/** @ingroup CHIP_5410X_DRIVER_OPTIONS
+ * @{
+ */
+
+/**
+ * @brief	Clock rate on the CLKIN pin
+ * This value is defined externally to the chip layer and contains
+ * the value in Hz for the CLKIN pin for the board. If this pin isn't used,
+ * this rate can be 0.
+ */
+extern const uint32_t ExtClockIn;
+
+/**
+ * @}
+ */
+
+/* Include order is important! */
+#include "romapi_5410x.h"
+#include "syscon_5410x.h"
+#include "cpuctrl_5410x.h"
+#include "clock_5410x.h"
+#include "pmu_5410x.h"
+#include "iocon_5410x.h"
+#include "pinint_5410x.h"
+#include "inmux_5410x.h"
+#include "crc_5410x.h"
+#include "gpio_5410x.h"
+#include "fifo_5410x.h"
+#include "mrt_5410x.h"
+#include "wwdt_5410x.h"
+#include "sct_5410x.h"
+#include "sct_pwm_5410x.h"
+#include "rtc_5410x.h"
+#include "timer_5410x.h"
+#include "ritimer_5410x.h"
+#include "utick_5410x.h"
+#include "gpiogroup_5410x.h"
+#include "mailbox_5410x.h"
+#include "fpu_init.h"
+#include "power_lib_5410x.h"
+#include "adc_5410x.h"
+#include "dma_5410x.h"
+#include "uart_5410x.h"
+#include "spi_common_5410x.h"
+#include "spim_5410x.h"
+#include "spis_5410x.h"
+#include "i2c_common_5410x.h"
+#include "i2cm_5410x.h"
+#include "i2cs_5410x.h"
+
+/** @defgroup SUPPORT_5410X_FUNC CHIP: LPC5410X support functions
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief	Current system clock rate, mainly used for peripherals in SYSCON
+ */
+extern uint32_t SystemCoreClock;
+
+/**
+ * @brief	Update system core and ASYNC syscon clock rate, should be called if the
+ *			system has a clock rate change
+ * @return	None
+ */
+void SystemCoreClockUpdate(void);
+
+/**
+ * @brief	Set up and initialize hardware prior to call to main()
+ * @return	None
+ * @note	Chip_SystemInit() is called prior to the application and sets up
+ * system clocking prior to the application starting.
+ */
+void Chip_SystemInit(void);
+
+/**
+ * @brief	Clock and PLL initialization based on the internal oscillator
+ * @param	iFreq	: Rate (in Hz) to set the main system clock to
+ * @return	None
+ */
+void Chip_SetupIrcClocking(uint32_t iFreq);
+
+/**
+ * @brief	Clock and PLL initialization based on the external clock input
+ * @param	iFreq	: Rate (in Hz) to set the main system clock to
+ * @return	None
+ */
+void Chip_SetupExtInClocking(uint32_t iFreq);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CHIP_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/clock_5410x.h ./chip/inc/clock_5410x.h
--- a_tnusFF/chip/inc/clock_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/clock_5410x.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,473 @@
+/*
+ * @brief LPC5410X clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CLOCK_5410X_H_
+#define __CLOCK_5410X_H_
+
+#include "pll_5410x.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CLOCK_5410X CHIP: LPC5410X Clock Driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/* Internal oscillator frequency */
+#define SYSCON_IRC_FREQ     (12000000)
+#define SYSCON_WDTOSC_FREQ  (500000)
+#define SYSCON_RTC_FREQ     (32768)
+
+/**
+ * @brief	Returns the internal oscillator (IRC) clock rate
+ * @return	internal oscillator (IRC) clock rate
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetIntOscRate(void)
+{
+	return SYSCON_IRC_FREQ;
+}
+
+/**
+ * @brief	Returns the external clock input rate
+ * @return	External clock input rate
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetExtClockInRate(void)
+{
+	return ExtClockIn;
+}
+
+/**
+ * @brief	Returns the RTC clock rate
+ * @return	RTC oscillator clock rate in Hz
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetRTCOscRate(void)
+{
+	return SYSCON_RTC_FREQ;
+}
+
+/**
+ * @brief	Return estimated watchdog oscillator rate
+ * @return	Estimated watchdog oscillator rate
+ * @note	This rate is accurate to plus or minus 40%.
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetWDTOSCRate(void)
+{
+	return SYSCON_WDTOSC_FREQ;
+}
+
+/**
+ * Clock source selections for only the main A system clock. The main A system
+ * clock is used as an input into the main B system clock selector. Main clock A
+ * only needs to be setup if the main clock A input is used in the main clock
+ * system selector.
+ */
+typedef enum {
+	SYSCON_MAIN_A_CLKSRC_IRC = 0,		/*!< Internal oscillator */
+	SYSCON_MAIN_A_CLKSRCA_CLKIN,		/*!< Crystal (main) oscillator in */
+	SYSCON_MAIN_A_CLKSRCA_WDTOSC,		/*!< Watchdog oscillator rate */
+} CHIP_SYSCON_MAIN_A_CLKSRC_T;
+
+/**
+ * @brief	Set main A system clock source
+ * @param	src	: Clock source for main A
+ * @return	Nothing
+ * @note	This function only needs to be setup if main clock A will be
+ * selected in the Chip_Clock_GetMain_B_ClockRate() function.
+ */
+__STATIC_INLINE void Chip_Clock_SetMain_A_ClockSource(CHIP_SYSCON_MAIN_A_CLKSRC_T src)
+{
+	LPC_SYSCON->MAINCLKSELA = (uint32_t) src;
+}
+
+/**
+ * @brief   Returns the main A clock source
+ * @return	Returns which clock is used for the main A
+ */
+__STATIC_INLINE CHIP_SYSCON_MAIN_A_CLKSRC_T Chip_Clock_GetMain_A_ClockSource(void)
+{
+	return (CHIP_SYSCON_MAIN_A_CLKSRC_T) (LPC_SYSCON->MAINCLKSELA);
+}
+
+/**
+ * @brief	Return main A clock rate
+ * @return	main A clock rate in Hz
+ */
+uint32_t Chip_Clock_GetMain_A_ClockRate(void);
+
+/**
+ * Clock sources for only main B system clock
+ */
+typedef enum {
+	SYSCON_MAIN_B_CLKSRC_MAINCLKSELA = 0,	/*!< main clock A */
+	SYSCON_MAIN_B_CLKSRC_SYSPLLIN,			/*!< System PLL input */
+	SYSCON_MAIN_B_CLKSRC_SYSPLLOUT,			/*!< System PLL output */
+	SYSCON_MAIN_B_CLKSRC_RTC,				/*!< RTC oscillator 32KHz output */
+} CHIP_SYSCON_MAIN_B_CLKSRC_T;
+
+/**
+ * @brief	Set main B system clock source
+ * @param	src	: Clock source for main B
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_Clock_SetMain_B_ClockSource(CHIP_SYSCON_MAIN_B_CLKSRC_T src)
+{
+	LPC_SYSCON->MAINCLKSELB = (uint32_t) src;
+}
+
+/**
+ * @brief   Returns the main B clock source
+ * @return	Returns which clock is used for the main B
+ */
+__STATIC_INLINE CHIP_SYSCON_MAIN_B_CLKSRC_T Chip_Clock_GetMain_B_ClockSource(void)
+{
+	return (CHIP_SYSCON_MAIN_B_CLKSRC_T) (LPC_SYSCON->MAINCLKSELB);
+}
+
+/**
+ * @brief	Return main B clock rate
+ * @return	main B clock rate
+ */
+uint32_t Chip_Clock_GetMain_B_ClockRate(void);
+
+/**
+ * Clock sources for CLKOUT
+ */
+typedef enum {
+	SYSCON_CLKOUTSRC_MAINCLK = 0,		/*!< Main system clock for CLKOUT */
+	SYSCON_CLKOUTSRC_CLKIN,				/*!< CLKIN for CLKOUT */
+	SYSCON_CLKOUTSRC_WDTOSC,			/*!< Watchdog oscillator for CLKOUT */
+	SYSCON_CLKOUTSRC_IRC,				/*!< Internal oscillator for CLKOUT */
+	SYSCON_CLKOUTSRCA_OUTPUT,			/*!< clkoutA output route to input of clkoutB */
+	SYSCON_CLKOUTSRC_RTC = 7			/*!< RTC oscillator 32KHz for CLKOUT */
+} CHIP_SYSCON_CLKOUTSRC_T;
+
+/**
+ * @brief	Set CLKOUT clock source and divider
+ * @param	src	: Clock source for CLKOUT
+ * @param	div	: divider for CLKOUT clock
+ * @return	Nothing
+ * @note	Use 0 to disable, or a divider value of 1 to 255. The CLKOUT clock
+ * rate is the clock source divided by the divider. This function will
+ * also toggle the clock source update register to update the clock
+ * source.
+ */
+void Chip_Clock_SetCLKOUTSource(CHIP_SYSCON_CLKOUTSRC_T src, uint32_t div);
+
+/**
+ * System and peripheral clocks enum
+ */
+typedef enum CHIP_SYSCON_CLOCK {
+	/* Peripheral clock enables for SYSAHBCLKCTRL0 */
+	SYSCON_CLOCK_ROM = 1,				/*!< ROM clock */
+	SYSCON_CLOCK_SRAM1 = 3,				/*!< SRAM1 clock */
+	SYSCON_CLOCK_SRAM2,					/*!< SRAM2 clock */
+	SYSCON_CLOCK_FLASH = 7,				/*!< FLASH controller clock */
+	SYSCON_CLOCK_FMC,					/*!< FMC clock */
+	SYSCON_CLOCK_INPUTMUX = 11,			/*!< Input mux clock */
+	SYSCON_CLOCK_IOCON = 13,			/*!< IOCON clock */
+	SYSCON_CLOCK_GPIO0,					/*!< GPIO0 clock */
+	SYSCON_CLOCK_GPIO1,					/*!< GPIO1 clock */
+	SYSCON_CLOCK_PINT = 18,				/*!< PININT clock */
+	SYSCON_CLOCK_GINT,					/*!< grouped pin interrupt block clock */
+	SYSCON_CLOCK_DMA,					/*!< DMA clock */
+	SYSCON_CLOCK_CRC,					/*!< CRC clock */
+	SYSCON_CLOCK_WWDT,					/*!< WDT clock */
+	SYSCON_CLOCK_RTC,					/*!< RTC clock */
+	SYSCON_CLOCK_MAILBOX = 26,			/*!< Mailbox clock */
+	SYSCON_CLOCK_ADC0,					/*!< ADC0 clock */
+
+	/* Peripheral clock enables for SYSAHBCLKCTRL1 */
+	SYSCON_CLOCK_MRT = 32,				/*!< multi-rate timer clock */
+	SYSCON_CLOCK_RIT,					/*!< Repetitive interval timer clock */
+	SYSCON_CLOCK_SCT0,					/*!< SCT0 clock */
+	SYSCON_CLOCK_FIFO = 32 + 9,			/*!< System FIFO clock */
+	SYSCON_CLOCK_UTICK,					/*!< UTICK clock */
+	SYSCON_CLOCK_TIMER2 = 32 + 22,		/*!< TIMER2 clock */
+	SYSCON_CLOCK_TIMER3 = 32 + 26,		/*!< TIMER3 clock */
+	SYSCON_CLOCK_TIMER4,				/*!< TIMER4 clock */
+
+	/* Peripheral clock enables for ASYNCAPBCLKCTRLCLR */
+	SYSCON_CLOCK_USART0 = 128 + 1,		/*!< USART0 clock */
+	SYSCON_CLOCK_USART1,				/*!< USART1 clock */
+	SYSCON_CLOCK_USART2,				/*!< USART2 clock */
+	SYSCON_CLOCK_USART3,				/*!< USART3 clock */
+	SYSCON_CLOCK_I2C0,					/*!< I2C0  clock */
+	SYSCON_CLOCK_I2C1,					/*!< I2C1  clock */
+	SYSCON_CLOCK_I2C2,					/*!< I2C2  clock */
+	SYSCON_CLOCK_SPI0 = 128 + 9,		/*!< SPI0  clock */
+	SYSCON_CLOCK_SPI1,					/*!< SPI1  clock */
+	SYSCON_CLOCK_TIMER0 = 128 + 13,		/*!< TIMER0 clock */
+	SYSCON_CLOCK_TIMER1,				/*!< TIMER1 clock */
+	SYSCON_CLOCK_FRG					/*!< FRG clock */
+} CHIP_SYSCON_CLOCK_T;
+
+/**
+ * @brief	Enable a system or peripheral clock
+ * @param	clk	: Clock to enable
+ * @return	Nothing
+ */
+void Chip_Clock_EnablePeriphClock(CHIP_SYSCON_CLOCK_T clk);
+
+/**
+ * @brief	Disable a system or peripheral clock
+ * @param	clk	: Clock to disable
+ * @return	Nothing
+ */
+void Chip_Clock_DisablePeriphClock(CHIP_SYSCON_CLOCK_T clk);
+
+/**
+ * @brief	Set system tick clock divider (external CLKIN as SYSTICK reference only)
+ * @param	div	: divider for system clock
+ * @return	Nothing
+ * @note	Use 0 to disable, or a divider value of 1 to 255. The system tick
+ * rate is the external CLKIN rate divided by this value. The extern CLKIN pin
+ * signal, divided by the SYSTICKCLKDIV divider, is selected by clearing
+ * CLKSOURCE bit 2 in the System Tick CSR register. The core clock must be at least
+ * 2.5 times faster than the reference system tick clock otherwise the count
+ * values are unpredictable.
+ */
+__STATIC_INLINE void Chip_Clock_SetSysTickClockDiv(uint32_t div)
+{
+	LPC_SYSCON->SYSTICKCLKDIV = div;
+}
+
+/**
+ * @brief	Returns system tick clock divider
+ * @return	system tick clock divider
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetSysTickClockDiv(void)
+{
+	return LPC_SYSCON->SYSTICKCLKDIV;
+}
+
+/**
+ * @brief	Returns the system tick rate as used with the system tick divider
+ * @return	the system tick rate
+ */
+uint32_t Chip_Clock_GetSysTickClockRate(void);
+
+/**
+ * @brief	Set system clock divider
+ * @param	div	: divider for system clock
+ * @return	Nothing
+ * @note	Use 0 to disable, or a divider value of 1 to 255. The system clock
+ * rate is the main system clock divided by this value.
+ */
+__STATIC_INLINE void Chip_Clock_SetSysClockDiv(uint32_t div)
+{
+	LPC_SYSCON->AHBCLKDIV = div;
+}
+
+/**
+ * @brief	Set system tick clock divider
+ * @param	div	: divider for system clock
+ * @return	Nothing
+ * @note	Use 0 to disable, or a divider value of 1 to 255. The system tick
+ * rate is the main system clock divided by this value. Use caution when using
+ * the CMSIS SysTick_Config() functions as they typically use SystemCoreClock
+ * for setup.
+ */
+__STATIC_INLINE void Chip_Clock_SetADCClockDiv(uint32_t div)
+{
+	LPC_SYSCON->ADCCLKDIV = div;
+}
+
+/**
+ * @brief	Returns ADC clock divider
+ * @return	ADC clock divider, 0 = disabled
+ */
+__STATIC_INLINE uint32_t Chip_Clock_GetADCClockDiv(void)
+{
+	return LPC_SYSCON->ADCCLKDIV;
+}
+
+/**
+ * Clock sources for ADC clock source select
+ */
+typedef enum {
+	SYSCON_ADCCLKSELSRC_MAINCLK = 0,		/*!< Main clock */
+	SYSCON_ADCCLKSELSRC_SYSPLLOUT,			/*!< PLL output */
+	SYSCON_ADCCLKSELSRC_IRC					/*!< Internal oscillator */
+} CHIP_SYSCON_ADCCLKSELSRC_T;
+
+/**
+ * @brief	Set the ADC clock source
+ * @param	src	: ADC clock source
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_Clock_SetADCClockSource(CHIP_SYSCON_ADCCLKSELSRC_T src)
+{
+	LPC_SYSCON->ADCCLKSEL = (uint32_t) src;
+}
+
+/**
+ * @brief   Returns the ADC clock source
+ * @return	Returns which clock is used for the ADC clock source
+ */
+__STATIC_INLINE CHIP_SYSCON_ADCCLKSELSRC_T Chip_Clock_GetADCClockSource(void)
+{
+	return (CHIP_SYSCON_ADCCLKSELSRC_T) (LPC_SYSCON->ADCCLKSEL);
+}
+
+/**
+ * @brief	Return ADC clock rate
+ * @return	ADC clock rate
+ */
+uint32_t Chip_Clock_GetADCClockRate(void);
+
+/**
+ * @brief	Enable the RTC 32KHz output
+ * @return	Nothing
+ * @note	This clock can be used for the main clock directly, but
+ *			do not use this clock with the system PLL.
+ */
+__STATIC_INLINE void Chip_Clock_EnableRTCOsc(void)
+{
+	LPC_SYSCON->RTCOSCCTRL  = 1;
+}
+
+/**
+ * @brief	Disable the RTC 32KHz output
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_Clock_DisableRTCOsc(void)
+{
+	LPC_SYSCON->RTCOSCCTRL  = 0;
+}
+
+/**
+ * Clock source selections for the asynchronous APB clock
+ */
+typedef enum {
+	SYSCON_ASYNC_IRC = 0,			/*!< IRC input */
+	SYSCON_ASYNC_WDTOSC,			/*!< Watchdog oscillator */
+	SYSCON_ASYNC_MAINCLK = 4,		/*!< Main clock */
+	SYSCON_ASYNC_CLKIN,				/*!< external CLK input */
+	SYSCON_ASYNC_SYSPLLOUT			/*!< System PLL output */
+} CHIP_ASYNC_SYSCON_SRC_T;
+
+/**
+ * @brief	Set asynchronous APB clock source
+ * @param	src	: Clock source for asynchronous APB clock
+ * @return	Nothing
+ */
+void Chip_Clock_SetAsyncSysconClockSource(CHIP_ASYNC_SYSCON_SRC_T src);
+
+/**
+ * @brief	Get asynchronous APB clock source
+ * @return	Clock source for asynchronous APB clock
+ */
+CHIP_ASYNC_SYSCON_SRC_T Chip_Clock_GetAsyncSysconClockSource(void);
+
+/**
+ * @brief	Return asynchronous APB clock rate
+ * @return	Asynchronous APB clock rate
+ * @note	Includes adjustments by Async clock divider (ASYNCCLKDIV).
+ */
+uint32_t Chip_Clock_GetAsyncSyscon_ClockRate(void);
+
+/**
+ * @brief	Set UART divider clock
+ * @param	div	: divider for UART clock
+ * @return	Nothing
+ * @note	Use 0 to disable, or a divider value of 1 to 255. The UART clock
+ * rate is the main system clock divided by this value.
+ */
+__STATIC_INLINE void Chip_Clock_SetAsyncSysconClockDiv(uint32_t div)
+{
+	LPC_ASYNC_SYSCON->ASYNCCLKDIV = div;
+}
+
+/**
+ * Clock sources for main system clock. This is a mix of both main clock A
+ * and B selections.
+ */
+typedef enum {
+	SYSCON_MAINCLKSRC_IRC = 0,				/*!< Internal oscillator */
+	SYSCON_MAINCLKSRC_CLKIN,				/*!< Crystal (main) oscillator in */
+	SYSCON_MAINCLKSRC_WDTOSC,				/*!< Watchdog oscillator rate */
+	SYSCON_MAINCLKSRC_PLLIN = 5,			/*!< System PLL input */
+	SYSCON_MAINCLKSRC_PLLOUT,				/*!< System PLL output */
+	SYSCON_MAINCLKSRC_RTC					/*!< RTC oscillator 32KHz output */
+} CHIP_SYSCON_MAINCLKSRC_T;
+
+/**
+ * @brief	Set main system clock source
+ * @param	src	: Clock source for main system
+ * @return	Nothing
+ */
+void Chip_Clock_SetMainClockSource(CHIP_SYSCON_MAINCLKSRC_T src);
+
+/**
+ * @brief	Get main system clock source
+ * @return	Clock source for main system
+ * @note
+ */
+CHIP_SYSCON_MAINCLKSRC_T Chip_Clock_GetMainClockSource(void);
+
+/**
+ * @brief	Return main clock rate
+ * @return	main clock rate
+ */
+uint32_t Chip_Clock_GetMainClockRate(void);
+
+/**
+ * @brief	Return system clock rate
+ * @return	system clock rate
+ * @note	This is the main clock rate divided by AHBCLKDIV.
+ */
+uint32_t Chip_Clock_GetSystemClockRate(void);
+
+/**
+ * @brief	Get UART base clock rate
+ * @return	UART base clock rate
+ */
+uint32_t Chip_Clock_GetUARTBaseClockRate(void);
+
+/**
+ * @brief	Get UART base clock rate using FRG
+ * @return	Actual UART base clock rate
+ * @note	It's recommended to set a base rate at least 16x the
+ * expected maximum UART transfer bit rate.
+ */
+uint32_t Chip_Clock_SetUARTBaseClockRate(uint32_t rate);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CLOCK_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/cmsis_5410x.h ./chip/inc/cmsis_5410x.h
--- a_tnusFF/chip/inc/cmsis_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/cmsis_5410x.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,171 @@
+/*
+ * @brief Basic CMSIS include file for LPC5410x M4 core
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_5410X_H_
+#define __CMSIS_5410X_H_
+
+#include "lpc_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_5410X_M4 CHIP: LPC5410X M4 core CMSIS include file
+ * @ingroup CHIP_5410X_CMSIS_DRIVERS
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+// Kill warning "#pragma push with no matching #pragma pop"
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+//  #pragma push // FIXME not usable for IAR
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/*
+ * ==========================================================================
+ * ---------- Interrupt Number Definition -----------------------------------
+ * ==========================================================================
+ */
+
+#if !defined(CORE_M4)
+#error "CORE_M4 is not defined"
+#endif
+
+/** @defgroup CMSIS_5410X_M4_IRQ CHIP_5410X: LPC5410X M4 core peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/******  Cortex-M4 Processor Exceptions Numbers ***************************************************/
+	Reset_IRQn                    = -15,	/*!< 1  Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn           = -14,	/*!< 2  Non maskable Interrupt, cannot be stopped or preempted */
+	HardFault_IRQn                = -13,	/*!< 3  Hard Fault, all classes of Fault */
+	MemoryManagement_IRQn         = -12,	/*!< 4  Memory Management, MPU mismatch, including Access Violation and No Match */
+	BusFault_IRQn                 = -11,	/*!< 5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory related Fault */
+	UsageFault_IRQn               = -10,	/*!< 6  Usage Fault, i.e. Undef Instruction, Illegal State Transition */
+	SVCall_IRQn                   =  -5,	/*!< 11  System Service Call via SVC instruction */
+	DebugMonitor_IRQn             =  -4,	/*!< 12  Debug Monitor                    */
+	PendSV_IRQn                   =  -2,	/*!< 14  Pendable request for system service */
+	SysTick_IRQn                  =  -1,	/*!< 15  System Tick Timer                */
+
+	/******  LPC5410X Specific Interrupt Numbers ********************************************************/
+	WDT_IRQn                      = 0,		/*!< WWDT                                             */
+	BOD_IRQn                      = 1,		/*!< BOD                                              */
+	Reserved2_IRQn                = 2,		/*!< Reserved Interrupt                               */
+	DMA_IRQn                      = 3,		/*!< DMA                                              */
+	GINT0_IRQn                    = 4,		/*!< GINT0                                            */
+	PIN_INT0_IRQn                 = 5,		/*!< PININT0                                          */
+	PIN_INT1_IRQn                 = 6,		/*!< PININT1                                          */
+	PIN_INT2_IRQn                 = 7,		/*!< PININT2                                          */
+	PIN_INT3_IRQn                 = 8,		/*!< PININT3                                          */
+	UTICK_IRQn                    = 9,		/*!< Micro-tick Timer interrupt                       */
+	MRT_IRQn                      = 10,		/*!< Multi-rate timer interrupt                       */
+	CT32B0_IRQn                   = 11,		/*!< CTMR0                                            */
+	CT32B1_IRQn                   = 12,		/*!< CTMR1                                            */
+	CT32B2_IRQn                   = 13,		/*!< CTMR2                                            */
+	CT32B3_IRQn                   = 14,		/*!< CTMR3                                            */
+	CT32B4_IRQn                   = 15,		/*!< CTMR4                                            */
+	SCT0_IRQn                     = 16,		/*!< SCT                                              */
+	UART0_IRQn                    = 17,		/*!< UART0                                            */
+	UART1_IRQn                    = 18,		/*!< UART1                                            */
+	UART2_IRQn                    = 19,		/*!< UART2                                            */
+	UART3_IRQn                    = 20,		/*!< UART3                                            */
+	I2C0_IRQn                     = 21,		/*!< I2C0                                             */
+	I2C1_IRQn                     = 22,		/*!< I2C1                                             */
+	I2C2_IRQn                     = 23,		/*!< I2C2                                             */
+	SPI0_IRQn                     = 24,		/*!< SPI0                                             */
+	SPI1_IRQn                     = 25,		/*!< SPI1                                             */
+	ADC_SEQA_IRQn                 = 26,		/*!< ADC0 sequence A completion                       */
+	ADC_SEQB_IRQn                 = 27,		/*!< ADC0 sequence B completion                       */
+	ADC_THCMP_IRQn                = 28,		/*!< ADC0 threshold compare and error                 */
+	RTC_IRQn                      = 29,		/*!< RTC alarm and wake-up interrupts                 */
+	Reserved30_IRQn               = 30,		/*!< Reserved Interrupt                               */
+	MAILBOX_IRQn                  = 31,		/*!< Mailbox                                          */
+	GINT1_IRQn                    = 32,		/*!< GINT1                                            */
+	PIN_INT4_IRQn                 = 33,		/*!< External Interrupt 4                             */
+	PIN_INT5_IRQn                 = 34,		/*!< External Interrupt 5                             */
+	PIN_INT6_IRQn                 = 35,		/*!< External Interrupt 6                             */
+	PIN_INT7_IRQn                 = 36,		/*!< External Interrupt 7                             */
+	Reserved37_IRQn               = 37,		/*!< Reserved Interrupt                               */
+	Reserved38_IRQn               = 38,		/*!< Reserved Interrupt                               */
+	Reserved39_IRQn               = 39,		/*!< Reserved Interrupt                               */
+	RIT_IRQn                      = 40,		/*!< Repetitive Interrupt Timer                       */
+	Reserved41_IRQn               = 41,		/*!< Reserved Interrupt                               */
+	Reserved42_IRQn               = 42,		/*!< Reserved Interrupt                               */
+	Reserved43_IRQn               = 43,		/*!< Reserved Interrupt                               */
+	Reserved44_IRQn               = 44,		/*!< Reserved Interrupt                               */
+} LPC5410X_IRQn_Type;
+
+/**
+ * @}
+ */
+
+/*
+ * ==========================================================================
+ * ----------- Processor and Core Peripheral Section ------------------------
+ * ==========================================================================
+ */
+
+/** @defgroup CMSIS_5410X_M4_COMMON CHIP: LPC5410X M4 core Cortex CMSIS definitions
+ * @{
+ */
+
+/* Configuration of the Cortex-M4 Processor and Core Peripherals */
+#define __CM4_REV                 0x0001	/*!< Cortex-M4 Core Revision                          */
+#define __MPU_PRESENT             1			/*!< MPU present or not                               */
+#define __NVIC_PRIO_BITS          3			/*!< Number of Bits used for Priority Levels          */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used     */
+#define __FPU_PRESENT             1
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CMSIS_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/cmsis_5410x_m0.h ./chip/inc/cmsis_5410x_m0.h
--- a_tnusFF/chip/inc/cmsis_5410x_m0.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/cmsis_5410x_m0.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,154 @@
+/*
+ * @brief Basic CMSIS include file for LPC5410x M0+ core
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_5410X_M0_H_
+#define __CMSIS_5410X_M0_H_
+
+#include "lpc_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CMSIS_5410X_M0 CHIP: LPC5410X M0 core CMSIS include file
+ * @ingroup CHIP_5410X_CMSIS_DRIVERS
+ * @{
+ */
+
+#if defined(__ARMCC_VERSION)
+// Kill warning "#pragma push with no matching #pragma pop"
+  #pragma diag_suppress 2525
+  #pragma push
+  #pragma anon_unions
+#elif defined(__CWCC__)
+  #pragma push
+  #pragma cpp_extensions on
+#elif defined(__GNUC__)
+/* anonymous unions are enabled by default */
+#elif defined(__IAR_SYSTEMS_ICC__)
+//  #pragma push // FIXME not usable for IAR
+  #pragma language=extended
+#else
+  #error Not supported compiler type
+#endif
+
+/*
+ * ==========================================================================
+ * ---------- Interrupt Number Definition -----------------------------------
+ * ==========================================================================
+ */
+
+#if !defined(CORE_M0PLUS)
+#error "CORE_M0PLUS is not defined"
+#endif
+
+/** @defgroup CMSIS_5410X_M0_IRQ CHIP_5410X: LPC5410X M0 core peripheral interrupt numbers
+ * @{
+ */
+
+typedef enum {
+	/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
+	Reset_IRQn                    = -15,	/*!< 1 Reset Vector, invoked on Power up and warm reset */
+	NonMaskableInt_IRQn           = -14,	/*!< 2 Non Maskable Interrupt                           */
+	HardFault_IRQn                = -13,	/*!< 3 Cortex-M0 Hard Fault Interrupt                   */
+	SVCall_IRQn                   = -5,		/*!< 11 Cortex-M0 SV Call Interrupt                     */
+	PendSV_IRQn                   = -2,		/*!< 14 Cortex-M0 Pend SV Interrupt                     */
+	SysTick_IRQn                  = -1,		/*!< 15 Cortex-M0 System Tick Interrupt                 */
+
+	/******  LPC5410X Specific Interrupt Numbers ********************************************************/
+	WDT_IRQn                      = 0,		/*!< WWDT                                             */
+	BOD_IRQn                      = 1,		/*!< BOD                                              */
+	Reserved2_IRQn                = 2,		/*!< Reserved Interrupt                               */
+	DMA_IRQn                      = 3,		/*!< DMA                                              */
+	GINT0_IRQn                    = 4,		/*!< GINT0                                            */
+	PIN_INT0_IRQn                 = 5,		/*!< PININT0                                          */
+	PIN_INT1_IRQn                 = 6,		/*!< PININT1                                          */
+	PIN_INT2_IRQn                 = 7,		/*!< PININT2                                          */
+	PIN_INT3_IRQn                 = 8,		/*!< PININT3                                          */
+	UTICK_IRQn                    = 9,		/*!< Micro-tick Timer interrupt                       */
+	MRT_IRQn                      = 10,		/*!< Multi-rate timer interrupt                       */
+	CT32B0_IRQn                   = 11,		/*!< CTMR0                                            */
+	CT32B1_IRQn                   = 12,		/*!< CTMR1                                            */
+	CT32B2_IRQn                   = 13,		/*!< CTMR2                                            */
+	CT32B3_IRQn                   = 14,		/*!< CTMR3                                            */
+	CT32B4_IRQn                   = 15,		/*!< CTMR4                                            */
+	SCT0_IRQn                     = 16,		/*!< SCT                                              */
+	UART0_IRQn                    = 17,		/*!< UART0                                            */
+	UART1_IRQn                    = 18,		/*!< UART1                                            */
+	UART2_IRQn                    = 19,		/*!< UART2                                            */
+	UART3_IRQn                    = 20,		/*!< UART3                                            */
+	I2C0_IRQn                     = 21,		/*!< I2C0                                             */
+	I2C1_IRQn                     = 22,		/*!< I2C1                                             */
+	I2C2_IRQn                     = 23,		/*!< I2C2                                             */
+	SPI0_IRQn                     = 24,		/*!< SPI0                                             */
+	SPI1_IRQn                     = 25,		/*!< SPI1                                             */
+	ADC_SEQA_IRQn                 = 26,		/*!< ADC0 sequence A completion                       */
+	ADC_SEQB_IRQn                 = 27,		/*!< ADC0 sequence B completion                       */
+	ADC_THCMP_IRQn                = 28,		/*!< ADC0 threshold compare and error                 */
+	RTC_IRQn                      = 29,		/*!< RTC alarm and wake-up interrupts                 */
+	Reserved30_IRQn               = 30,		/*!< Reserved Interrupt                               */
+	MAILBOX_IRQn                  = 31,		/*!< Mailbox                                          */
+} LPC5410X_M0_IRQn_Type;
+
+/**
+ * @}
+ */
+
+/*
+ * ==========================================================================
+ * ----------- Processor and Core Peripheral Section ------------------------
+ * ==========================================================================
+ */
+
+/** @defgroup CMSIS_5410X_M0_COMMON CHIP: LPC5410X M0 core Cortex CMSIS definitions
+ * @{
+ */
+
+/* Configuration of the Cortex-M0+ Processor and Core Peripherals */
+#define __CM0PLUS_REV             0x0001	/*!< Cortex-M0PLUS Core Revision                      */
+#define __MPU_PRESENT             0			/*!< MPU present or not                               */
+#define __NVIC_PRIO_BITS          2			/*!< Number of Bits used for Priority Levels          */
+#define __Vendor_SysTickConfig    0			/*!< Set to 1 if different SysTick Config is used     */
+#define __VTOR_PRESENT            1
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CMSIS_5410X_M0_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/cmsis.h ./chip/inc/cmsis.h
--- a_tnusFF/chip/inc/cmsis.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/cmsis.h	2016-10-22 23:17:43.536840277 -0300
@@ -0,0 +1,55 @@
+/*
+ * @brief LPC5410x selective CMSIS inclusion file
+ *
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CMSIS_H_
+#define __CMSIS_H_
+
+#include "lpc_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Select correct CMSIS include file based on CORE_* definition */
+#if defined(CORE_M4)
+#include "cmsis_5410x.h"
+typedef LPC5410X_IRQn_Type IRQn_Type;
+#include "core_cm4.h"					/*!< Cortex-M4 processor and core peripherals      */
+#elif defined(CORE_M0PLUS)
+#include "cmsis_5410x_m0.h"
+typedef LPC5410X_M0_IRQn_Type IRQn_Type;
+#include "core_cm0plus.h"				/*!< Cortex-M0 Plus processor and core peripherals  */
+#else
+#error "No CORE_* definition is defined"
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CMSIS_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/core_cm0plus.h ./chip/inc/core_cm0plus.h
--- a_tnusFF/chip/inc/core_cm0plus.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/core_cm0plus.h	2016-10-22 23:17:43.540840277 -0300
@@ -0,0 +1,793 @@
+/**************************************************************************//**
+ * @file     core_cm0plus.h
+ * @brief    CMSIS Cortex-M0+ Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM0PLUS_H_GENERIC
+#define __CORE_CM0PLUS_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex-M0+
+  @{
+ */
+
+/*  CMSIS CM0P definitions */
+#define __CM0PLUS_CMSIS_VERSION_MAIN (0x03)                                /*!< [31:16] CMSIS HAL main version   */
+#define __CM0PLUS_CMSIS_VERSION_SUB  (0x20)                                /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM0PLUS_CMSIS_VERSION      ((__CM0PLUS_CMSIS_VERSION_MAIN << 16) | \
+                                       __CM0PLUS_CMSIS_VERSION_SUB)        /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
+*/
+#define __FPU_USED       0
+
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+
+#endif /* __CORE_CM0PLUS_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM0PLUS_H_DEPENDANT
+#define __CORE_CM0PLUS_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM0PLUS_REV
+    #define __CM0PLUS_REV             0x0000
+    #warning "__CM0PLUS_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __VTOR_PRESENT
+    #define __VTOR_PRESENT            0
+    #warning "__VTOR_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          2
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex-M0+ */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core MPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[31];
+  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
+       uint32_t RSERVED1[31];
+  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
+       uint32_t RESERVED2[31];
+  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
+       uint32_t RESERVED3[31];
+       uint32_t RESERVED4[64];
+  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
+}  NVIC_Type;
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+#if (__VTOR_PRESENT == 1)
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+#else
+       uint32_t RESERVED0;
+#endif
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+       uint32_t RESERVED1;
+  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+#if (__VTOR_PRESENT == 1)
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 8                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0xFFFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
+#endif
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   8                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0xFFFFFFUL << MPU_RBAR_ADDR_Pos)              /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Cortex-M0+ Core Debug Registers (DCB registers, SHCSR, and DFSR)
+                are only accessible over DAP and not via processor. Therefore
+                they are not covered by the Cortex-M0 header file.
+  @{
+ */
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M0+ Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
+
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
+/* The following MACROS handle generation of the register offset and byte masks */
+#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
+#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
+#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+  else {
+    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
+        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
+  else {
+    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 SCB_AIRCR_SYSRESETREQ_Msk);
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+
+#endif /* __CORE_CM0PLUS_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/core_cm4.h ./chip/inc/core_cm4.h
--- a_tnusFF/chip/inc/core_cm4.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/core_cm4.h	2016-10-22 23:17:43.544840277 -0300
@@ -0,0 +1,1772 @@
+/**************************************************************************//**
+ * @file     core_cm4.h
+ * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#if defined ( __ICCARM__ )
+ #pragma system_include  /* treat file as system include file for MISRA check */
+#endif
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_H_GENERIC
+#define __CORE_CM4_H_GENERIC
+
+/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
+  CMSIS violates the following MISRA-C:2004 rules:
+
+   \li Required Rule 8.5, object/function definition in header file.<br>
+     Function definitions in header files are used to allow 'inlining'.
+
+   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
+     Unions are used for effective representation of core registers.
+
+   \li Advisory Rule 19.7, Function-like macro defined.<br>
+     Function-like macros are used to allow more efficient code.
+ */
+
+
+/*******************************************************************************
+ *                 CMSIS definitions
+ ******************************************************************************/
+/** \ingroup Cortex_M4
+  @{
+ */
+
+/*  CMSIS CM4 definitions */
+#define __CM4_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
+#define __CM4_CMSIS_VERSION_SUB   (0x20)                                   /*!< [15:0]  CMSIS HAL sub version    */
+#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
+                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
+
+#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
+
+
+#if   defined ( __CC_ARM )
+  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
+  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
+  #define __STATIC_INLINE  static __inline
+
+#elif defined ( __ICCARM__ )
+  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TMS470__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __GNUC__ )
+  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
+  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
+  #define __STATIC_INLINE  static inline
+
+#elif defined ( __TASKING__ )
+  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
+  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
+  #define __STATIC_INLINE  static inline
+
+#endif
+
+/** __FPU_USED indicates whether an FPU is used or not. For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
+*/
+#if defined ( __CC_ARM )
+  #if defined __TARGET_FPU_VFP
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __ICCARM__ )
+  #if defined __ARMVFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TMS470__ )
+  #if defined __TI_VFP_SUPPORT__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __GNUC__ )
+  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+
+#elif defined ( __TASKING__ )
+  #if defined __FPU_VFP__
+    #if (__FPU_PRESENT == 1)
+      #define __FPU_USED       1
+    #else
+      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
+      #define __FPU_USED       0
+    #endif
+  #else
+    #define __FPU_USED         0
+  #endif
+#endif
+
+#include <stdint.h>                      /* standard types definitions                      */
+#include <core_cmInstr.h>                /* Core Instruction Access                         */
+#include <core_cmFunc.h>                 /* Core Function Access                            */
+#include <core_cm4_simd.h>               /* Compiler specific SIMD Intrinsics               */
+
+#endif /* __CORE_CM4_H_GENERIC */
+
+#ifndef __CMSIS_GENERIC
+
+#ifndef __CORE_CM4_H_DEPENDANT
+#define __CORE_CM4_H_DEPENDANT
+
+/* check device defines and use defaults */
+#if defined __CHECK_DEVICE_DEFINES
+  #ifndef __CM4_REV
+    #define __CM4_REV               0x0000
+    #warning "__CM4_REV not defined in device header file; using default!"
+  #endif
+
+  #ifndef __FPU_PRESENT
+    #define __FPU_PRESENT             0
+    #warning "__FPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __MPU_PRESENT
+    #define __MPU_PRESENT             0
+    #warning "__MPU_PRESENT not defined in device header file; using default!"
+  #endif
+
+  #ifndef __NVIC_PRIO_BITS
+    #define __NVIC_PRIO_BITS          4
+    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
+  #endif
+
+  #ifndef __Vendor_SysTickConfig
+    #define __Vendor_SysTickConfig    0
+    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
+  #endif
+#endif
+
+/* IO definitions (access restrictions to peripheral registers) */
+/**
+    \defgroup CMSIS_glob_defs CMSIS Global Defines
+
+    <strong>IO Type Qualifiers</strong> are used
+    \li to specify the access to peripheral variables.
+    \li for automatic generation of peripheral register debug information.
+*/
+#ifdef __cplusplus
+  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
+#else
+  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
+#endif
+#define     __O     volatile             /*!< Defines 'write only' permissions                */
+#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
+
+/*@} end of group Cortex_M4 */
+
+
+
+/*******************************************************************************
+ *                 Register Abstraction
+  Core Register contain:
+  - Core Register
+  - Core NVIC Register
+  - Core SCB Register
+  - Core SysTick Register
+  - Core Debug Register
+  - Core MPU Register
+  - Core FPU Register
+ ******************************************************************************/
+/** \defgroup CMSIS_core_register Defines and Type Definitions
+    \brief Type definitions and defines for Cortex-M processor based devices.
+*/
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_CORE  Status and Control Registers
+    \brief  Core Register type definitions.
+  @{
+ */
+
+/** \brief  Union type to access the Application Program Status Register (APSR).
+ */
+typedef union
+{
+  struct
+  {
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
+#else
+    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
+#endif
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} APSR_Type;
+
+
+/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} IPSR_Type;
+
+
+/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
+#if (__CORTEX_M != 0x04)
+    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
+#else
+    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
+    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
+    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
+#endif
+    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
+    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
+    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
+    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
+    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
+    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
+    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} xPSR_Type;
+
+
+/** \brief  Union type to access the Control Registers (CONTROL).
+ */
+typedef union
+{
+  struct
+  {
+    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
+    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
+    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
+    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
+  } b;                                   /*!< Structure used for bit  access                  */
+  uint32_t w;                            /*!< Type      used for word access                  */
+} CONTROL_Type;
+
+/*@} end of group CMSIS_CORE */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
+    \brief      Type definitions for the NVIC Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
+ */
+typedef struct
+{
+  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
+       uint32_t RESERVED0[24];
+  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
+       uint32_t RSERVED1[24];
+  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
+       uint32_t RESERVED2[24];
+  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
+       uint32_t RESERVED3[24];
+  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
+       uint32_t RESERVED4[56];
+  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
+       uint32_t RESERVED5[644];
+  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
+}  NVIC_Type;
+
+/* Software Triggered Interrupt Register Definitions */
+#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
+#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
+
+/*@} end of group CMSIS_NVIC */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCB     System Control Block (SCB)
+    \brief      Type definitions for the System Control Block Registers
+  @{
+ */
+
+/** \brief  Structure type to access the System Control Block (SCB).
+ */
+typedef struct
+{
+  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
+  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
+  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
+  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
+  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
+  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
+  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
+  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
+  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
+  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
+  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
+  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
+  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
+  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
+  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
+  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
+  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
+  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
+  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
+       uint32_t RESERVED0[5];
+  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
+} SCB_Type;
+
+/* SCB CPUID Register Definitions */
+#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
+#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
+
+#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
+#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
+
+#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
+#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
+
+#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
+#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
+
+#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
+#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
+
+/* SCB Interrupt Control State Register Definitions */
+#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
+#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
+
+#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
+#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
+
+#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
+#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
+
+#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
+#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
+
+#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
+#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
+
+#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
+#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
+
+#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
+#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
+
+#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
+#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
+
+#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
+#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
+
+#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
+#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
+
+/* SCB Vector Table Offset Register Definitions */
+#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
+#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
+
+/* SCB Application Interrupt and Reset Control Register Definitions */
+#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
+#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
+
+#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
+#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
+
+#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
+#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
+
+#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
+#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
+
+#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
+#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
+
+#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
+#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
+
+#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
+#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
+
+/* SCB System Control Register Definitions */
+#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
+#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
+
+#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
+#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
+
+#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
+#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
+
+/* SCB Configuration Control Register Definitions */
+#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
+#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
+
+#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
+#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
+
+#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
+#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
+
+#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
+#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
+
+#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
+#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
+
+#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
+#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
+
+/* SCB System Handler Control and State Register Definitions */
+#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
+#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
+
+#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
+#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
+
+#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
+#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
+
+#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
+#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
+
+#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
+#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
+
+#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
+#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
+
+#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
+#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
+
+#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
+#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
+
+#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
+#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
+
+#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
+#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
+
+#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
+#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
+
+#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
+#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
+
+#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
+#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
+
+#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
+#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
+
+/* SCB Configurable Fault Status Registers Definitions */
+#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
+#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
+
+#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
+#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
+
+#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
+#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
+
+/* SCB Hard Fault Status Registers Definitions */
+#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
+#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
+
+#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
+#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
+
+#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
+#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
+
+/* SCB Debug Fault Status Register Definitions */
+#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
+#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
+
+#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
+#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
+
+#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
+#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
+
+#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
+#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
+
+#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
+#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
+
+/*@} end of group CMSIS_SCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
+    \brief      Type definitions for the System Control and ID Register not in the SCB
+  @{
+ */
+
+/** \brief  Structure type to access the System Control and ID Register not in the SCB.
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
+  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
+} SCnSCB_Type;
+
+/* Interrupt Controller Type Register Definitions */
+#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
+#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
+
+/* Auxiliary Control Register Definitions */
+#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
+#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
+
+#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
+#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
+
+#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
+#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
+
+#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
+#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
+
+#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
+#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
+
+/*@} end of group CMSIS_SCnotSCB */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
+    \brief      Type definitions for the System Timer Registers.
+  @{
+ */
+
+/** \brief  Structure type to access the System Timer (SysTick).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
+  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
+  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
+  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
+} SysTick_Type;
+
+/* SysTick Control / Status Register Definitions */
+#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
+#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
+
+#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
+#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
+
+#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
+#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
+
+#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
+#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
+
+/* SysTick Reload Register Definitions */
+#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
+#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
+
+/* SysTick Current Register Definitions */
+#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
+#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
+
+/* SysTick Calibration Register Definitions */
+#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
+#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
+
+#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
+#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
+
+#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
+#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
+
+/*@} end of group CMSIS_SysTick */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
+    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
+  @{
+ */
+
+/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
+ */
+typedef struct
+{
+  __O  union
+  {
+    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
+    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
+    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
+  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
+       uint32_t RESERVED0[864];
+  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
+       uint32_t RESERVED1[15];
+  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
+       uint32_t RESERVED2[15];
+  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
+       uint32_t RESERVED3[29];
+  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
+  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
+  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
+       uint32_t RESERVED4[43];
+  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
+  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
+       uint32_t RESERVED5[6];
+  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
+  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
+  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
+  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
+  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
+  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
+  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
+  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
+  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
+  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
+  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
+  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
+} ITM_Type;
+
+/* ITM Trace Privilege Register Definitions */
+#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
+#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
+
+/* ITM Trace Control Register Definitions */
+#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
+#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
+
+#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
+#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
+
+#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
+#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
+
+#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
+#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
+
+#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
+#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
+
+#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
+#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
+
+#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
+#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
+
+#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
+#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
+
+#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
+#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
+
+/* ITM Integration Write Register Definitions */
+#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
+#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
+
+/* ITM Integration Read Register Definitions */
+#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
+#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
+
+/* ITM Integration Mode Control Register Definitions */
+#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
+#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
+
+/* ITM Lock Status Register Definitions */
+#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
+#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
+
+#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
+#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
+
+#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
+#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
+
+/*@}*/ /* end of group CMSIS_ITM */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
+    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
+  @{
+ */
+
+/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
+ */
+typedef struct
+{
+  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
+  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
+  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
+  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
+  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
+  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
+  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
+  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
+  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
+  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
+  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
+       uint32_t RESERVED0[1];
+  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
+  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
+  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
+       uint32_t RESERVED1[1];
+  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
+  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
+  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
+       uint32_t RESERVED2[1];
+  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
+  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
+  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
+} DWT_Type;
+
+/* DWT Control Register Definitions */
+#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
+#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
+
+#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
+#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
+
+#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
+#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
+
+#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
+#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
+
+#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
+#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
+
+#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
+#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
+
+#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
+#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
+
+#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
+#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
+
+#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
+#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
+
+#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
+#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
+
+#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
+#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
+
+#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
+#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
+
+#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
+#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
+
+#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
+#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
+
+#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
+#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
+
+#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
+#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
+
+#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
+#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
+
+#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
+#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
+
+/* DWT CPI Count Register Definitions */
+#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
+#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
+
+/* DWT Exception Overhead Count Register Definitions */
+#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
+#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
+
+/* DWT Sleep Count Register Definitions */
+#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
+#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
+
+/* DWT LSU Count Register Definitions */
+#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
+#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
+
+/* DWT Folded-instruction Count Register Definitions */
+#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
+#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
+
+/* DWT Comparator Mask Register Definitions */
+#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
+#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
+
+/* DWT Comparator Function Register Definitions */
+#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
+#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
+
+#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
+#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
+
+#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
+#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
+
+#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
+#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
+
+#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
+#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
+
+#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
+#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
+
+#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
+#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
+
+#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
+#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
+
+#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
+#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
+
+/*@}*/ /* end of group CMSIS_DWT */
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
+    \brief      Type definitions for the Trace Port Interface (TPI)
+  @{
+ */
+
+/** \brief  Structure type to access the Trace Port Interface Register (TPI).
+ */
+typedef struct
+{
+  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
+  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
+       uint32_t RESERVED0[2];
+  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
+       uint32_t RESERVED1[55];
+  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
+       uint32_t RESERVED2[131];
+  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
+  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
+  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
+       uint32_t RESERVED3[759];
+  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
+  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
+  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
+       uint32_t RESERVED4[1];
+  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
+  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
+  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
+       uint32_t RESERVED5[39];
+  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
+  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
+       uint32_t RESERVED7[8];
+  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
+  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
+} TPI_Type;
+
+/* TPI Asynchronous Clock Prescaler Register Definitions */
+#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
+#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
+
+/* TPI Selected Pin Protocol Register Definitions */
+#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
+#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
+
+/* TPI Formatter and Flush Status Register Definitions */
+#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
+#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
+
+#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
+#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
+
+#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
+#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
+
+#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
+#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
+
+/* TPI Formatter and Flush Control Register Definitions */
+#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
+#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
+
+#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
+#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
+
+/* TPI TRIGGER Register Definitions */
+#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
+#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
+
+/* TPI Integration ETM Data Register Definitions (FIFO0) */
+#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
+#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
+
+#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
+#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
+
+#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
+#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
+
+#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
+#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
+
+#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
+#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
+
+#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
+#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
+
+#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
+#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
+
+/* TPI ITATBCTR2 Register Definitions */
+#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
+#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
+
+/* TPI Integration ITM Data Register Definitions (FIFO1) */
+#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
+#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
+
+#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
+#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
+
+#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
+#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
+
+#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
+#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
+
+#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
+#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
+
+#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
+#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
+
+#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
+#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
+
+/* TPI ITATBCTR0 Register Definitions */
+#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
+#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
+
+/* TPI Integration Mode Control Register Definitions */
+#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
+#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
+
+/* TPI DEVID Register Definitions */
+#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
+#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
+
+#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
+#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
+
+#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
+#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
+
+#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
+#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
+
+#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
+#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
+
+#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
+#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
+
+/* TPI DEVTYPE Register Definitions */
+#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
+#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
+
+#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
+#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
+
+/*@}*/ /* end of group CMSIS_TPI */
+
+
+#if (__MPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
+    \brief      Type definitions for the Memory Protection Unit (MPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Memory Protection Unit (MPU).
+ */
+typedef struct
+{
+  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
+  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
+  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
+  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
+  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
+  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
+  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
+  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
+  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
+  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
+} MPU_Type;
+
+/* MPU Type Register */
+#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
+#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
+
+#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
+#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
+
+#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
+#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
+
+/* MPU Control Register */
+#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
+#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
+
+#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
+#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
+
+#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
+#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
+
+/* MPU Region Number Register */
+#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
+#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
+
+/* MPU Region Base Address Register */
+#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
+#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
+
+#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
+#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
+
+#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
+#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
+
+/* MPU Region Attribute and Size Register */
+#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
+#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
+
+#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
+#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
+
+#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
+#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
+
+#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
+#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
+
+#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
+#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
+
+#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
+#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
+
+#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
+#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
+
+#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
+#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
+
+#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
+#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
+
+#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
+#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
+
+/*@} end of group CMSIS_MPU */
+#endif
+
+
+#if (__FPU_PRESENT == 1)
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
+    \brief      Type definitions for the Floating Point Unit (FPU)
+  @{
+ */
+
+/** \brief  Structure type to access the Floating Point Unit (FPU).
+ */
+typedef struct
+{
+       uint32_t RESERVED0[1];
+  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
+  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
+  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
+  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
+  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
+} FPU_Type;
+
+/* Floating-Point Context Control Register */
+#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
+#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
+
+#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
+#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
+
+#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
+#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
+
+#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
+#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
+
+#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
+#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
+
+#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
+#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
+
+#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
+#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
+
+#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
+#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
+
+#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
+#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
+
+/* Floating-Point Context Address Register */
+#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
+#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
+
+/* Floating-Point Default Status Control Register */
+#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
+#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
+
+#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
+#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
+
+#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
+#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
+
+#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
+#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
+
+/* Media and FP Feature Register 0 */
+#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
+#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
+
+#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
+#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
+
+#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
+#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
+
+#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
+#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
+
+#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
+#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
+
+#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
+#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
+
+#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
+#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
+
+#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
+#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
+
+/* Media and FP Feature Register 1 */
+#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
+#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
+
+#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
+#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
+
+#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
+#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
+
+#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
+#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
+
+/*@} end of group CMSIS_FPU */
+#endif
+
+
+/** \ingroup  CMSIS_core_register
+    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
+    \brief      Type definitions for the Core Debug Registers
+  @{
+ */
+
+/** \brief  Structure type to access the Core Debug Register (CoreDebug).
+ */
+typedef struct
+{
+  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
+  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
+  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
+  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
+} CoreDebug_Type;
+
+/* Debug Halting Control and Status Register */
+#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
+#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
+
+#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
+#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
+
+#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
+#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
+
+#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
+#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
+
+#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
+#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
+
+#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
+#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
+
+#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
+#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
+
+#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
+#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
+
+#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
+#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
+
+#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
+#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
+
+#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
+#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
+
+#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
+#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
+
+/* Debug Core Register Selector Register */
+#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
+#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
+
+#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
+#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
+
+/* Debug Exception and Monitor Control Register */
+#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
+#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
+
+#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
+#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
+
+#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
+#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
+
+#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
+#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
+
+#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
+#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
+
+#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
+#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
+
+#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
+#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
+
+#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
+#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
+
+#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
+#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
+
+#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
+#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
+
+#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
+#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
+
+#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
+#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
+
+#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
+#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
+
+/*@} end of group CMSIS_CoreDebug */
+
+
+/** \ingroup    CMSIS_core_register
+    \defgroup   CMSIS_core_base     Core Definitions
+    \brief      Definitions for base addresses, unions, and structures.
+  @{
+ */
+
+/* Memory mapping of Cortex-M4 Hardware */
+#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
+#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
+#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
+#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
+#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
+#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
+#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
+#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
+
+#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
+#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
+#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
+#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
+#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
+#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
+#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
+#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
+
+#if (__MPU_PRESENT == 1)
+  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+#endif
+
+#if (__FPU_PRESENT == 1)
+  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
+  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
+#endif
+
+/*@} */
+
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+  Core Function Interface contains:
+  - Core NVIC Functions
+  - Core SysTick Functions
+  - Core Debug Functions
+  - Core Register Access Functions
+ ******************************************************************************/
+/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
+*/
+
+
+
+/* ##########################   NVIC functions  #################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
+    \brief      Functions that manage interrupts and exceptions via the NVIC.
+    @{
+ */
+
+/** \brief  Set Priority Grouping
+
+  The function sets the priority grouping field using the required unlock sequence.
+  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
+  Only values from 0..7 are used.
+  In case of a conflict between priority grouping and available
+  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
+
+    \param [in]      PriorityGroup  Priority grouping field.
+ */
+__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
+{
+  uint32_t reg_value;
+  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
+
+  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
+  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
+  reg_value  =  (reg_value                                 |
+                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
+                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
+  SCB->AIRCR =  reg_value;
+}
+
+
+/** \brief  Get Priority Grouping
+
+  The function reads the priority grouping field from the NVIC Interrupt Controller.
+
+    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
+{
+  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
+}
+
+
+/** \brief  Enable External Interrupt
+
+    The function enables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
+{
+/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
+  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
+}
+
+
+/** \brief  Disable External Interrupt
+
+    The function disables a device-specific interrupt in the NVIC interrupt controller.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
+}
+
+
+/** \brief  Get Pending Interrupt
+
+    The function reads the pending register in the NVIC and returns the pending bit
+    for the specified interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not pending.
+    \return             1  Interrupt status is pending.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
+{
+  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
+}
+
+
+/** \brief  Set Pending Interrupt
+
+    The function sets the pending bit of an external interrupt.
+
+    \param [in]      IRQn  Interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
+}
+
+
+/** \brief  Clear Pending Interrupt
+
+    The function clears the pending bit of an external interrupt.
+
+    \param [in]      IRQn  External interrupt number. Value cannot be negative.
+ */
+__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
+{
+  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
+}
+
+
+/** \brief  Get Active Interrupt
+
+    The function reads the active register in NVIC and returns the active bit.
+
+    \param [in]      IRQn  Interrupt number.
+
+    \return             0  Interrupt status is not active.
+    \return             1  Interrupt status is active.
+ */
+__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
+{
+  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
+}
+
+
+/** \brief  Set Interrupt Priority
+
+    The function sets the priority of an interrupt.
+
+    \note The priority cannot be set for every core interrupt.
+
+    \param [in]      IRQn  Interrupt number.
+    \param [in]  priority  Priority to set.
+ */
+__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
+{
+  if(IRQn < 0) {
+    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
+  else {
+    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
+}
+
+
+/** \brief  Get Interrupt Priority
+
+    The function reads the priority of an interrupt. The interrupt
+    number can be positive to specify an external (device specific)
+    interrupt, or negative to specify an internal (core) interrupt.
+
+
+    \param [in]   IRQn  Interrupt number.
+    \return             Interrupt Priority. Value is aligned automatically to the implemented
+                        priority bits of the microcontroller.
+ */
+__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
+{
+
+  if(IRQn < 0) {
+    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
+  else {
+    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
+}
+
+
+/** \brief  Encode Priority
+
+    The function encodes the priority for an interrupt with the given priority group,
+    preemptive priority value, and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS), the samllest possible priority group is set.
+
+    \param [in]     PriorityGroup  Used priority group.
+    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
+    \param [in]       SubPriority  Subpriority value (starting from 0).
+    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
+ */
+__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  return (
+           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
+           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
+         );
+}
+
+
+/** \brief  Decode Priority
+
+    The function decodes an interrupt priority value with a given priority group to
+    preemptive priority value and subpriority value.
+    In case of a conflict between priority grouping and available
+    priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
+
+    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
+    \param [in]     PriorityGroup  Used priority group.
+    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
+    \param [out]     pSubPriority  Subpriority value (starting from 0).
+ */
+__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
+{
+  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
+  uint32_t PreemptPriorityBits;
+  uint32_t SubPriorityBits;
+
+  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
+  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
+
+  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
+  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
+}
+
+
+/** \brief  System Reset
+
+    The function initiates a system reset request to reset the MCU.
+ */
+__STATIC_INLINE void NVIC_SystemReset(void)
+{
+  __DSB();                                                     /* Ensure all outstanding memory accesses included
+                                                                  buffered write are completed before reset */
+  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
+                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
+                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
+  __DSB();                                                     /* Ensure completion of memory access */
+  while(1);                                                    /* wait until reset */
+}
+
+/*@} end of CMSIS_Core_NVICFunctions */
+
+
+
+/* ##################################    SysTick function  ############################################ */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
+    \brief      Functions that configure the System.
+  @{
+ */
+
+#if (__Vendor_SysTickConfig == 0)
+
+/** \brief  System Tick Configuration
+
+    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
+    Counter is in free running mode to generate periodic interrupts.
+
+    \param [in]  ticks  Number of ticks between two interrupts.
+
+    \return          0  Function succeeded.
+    \return          1  Function failed.
+
+    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
+    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
+    must contain a vendor-specific implementation of this function.
+
+ */
+__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
+{
+  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
+
+  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
+  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
+  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
+  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
+                   SysTick_CTRL_TICKINT_Msk   |
+                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
+  return (0);                                                  /* Function successful */
+}
+
+#endif
+
+/*@} end of CMSIS_Core_SysTickFunctions */
+
+
+
+/* ##################################### Debug In/Output function ########################################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_core_DebugFunctions ITM Functions
+    \brief   Functions that access the ITM debug interface.
+  @{
+ */
+
+extern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
+#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
+
+
+/** \brief  ITM Send Character
+
+    The function transmits a character via the ITM channel 0, and
+    \li Just returns when no debugger is connected that has booked the output.
+    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
+
+    \param [in]     ch  Character to transmit.
+
+    \returns            Character to transmit.
+ */
+__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
+{
+  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
+      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
+  {
+    while (ITM->PORT[0].u32 == 0);
+    ITM->PORT[0].u8 = (uint8_t) ch;
+  }
+  return (ch);
+}
+
+
+/** \brief  ITM Receive Character
+
+    The function inputs a character via the external variable \ref ITM_RxBuffer.
+
+    \return             Received character.
+    \return         -1  No character pending.
+ */
+__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
+  int32_t ch = -1;                           /* no character available */
+
+  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
+    ch = ITM_RxBuffer;
+    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
+  }
+
+  return (ch);
+}
+
+
+/** \brief  ITM Check Character
+
+    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
+
+    \return          0  No character available.
+    \return          1  Character available.
+ */
+__STATIC_INLINE int32_t ITM_CheckChar (void) {
+
+  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
+    return (0);                                 /* no character available */
+  } else {
+    return (1);                                 /*    character available */
+  }
+}
+
+/*@} end of CMSIS_core_DebugFunctions */
+
+#endif /* __CORE_CM4_H_DEPENDANT */
+
+#endif /* __CMSIS_GENERIC */
+
+#ifdef __cplusplus
+}
+#endif
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/core_cm4_simd.h ./chip/inc/core_cm4_simd.h
--- a_tnusFF/chip/inc/core_cm4_simd.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/core_cm4_simd.h	2016-10-22 23:17:43.548840278 -0300
@@ -0,0 +1,673 @@
+/**************************************************************************//**
+ * @file     core_cm4_simd.h
+ * @brief    CMSIS Cortex-M4 SIMD Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifdef __cplusplus
+ extern "C" {
+#endif
+
+#ifndef __CORE_CM4_SIMD_H
+#define __CORE_CM4_SIMD_H
+
+
+/*******************************************************************************
+ *                Hardware Abstraction Layer
+ ******************************************************************************/
+
+
+/* ###################  Compiler specific Intrinsics  ########################### */
+/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
+  Access to dedicated SIMD instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#define __SADD8                           __sadd8
+#define __QADD8                           __qadd8
+#define __SHADD8                          __shadd8
+#define __UADD8                           __uadd8
+#define __UQADD8                          __uqadd8
+#define __UHADD8                          __uhadd8
+#define __SSUB8                           __ssub8
+#define __QSUB8                           __qsub8
+#define __SHSUB8                          __shsub8
+#define __USUB8                           __usub8
+#define __UQSUB8                          __uqsub8
+#define __UHSUB8                          __uhsub8
+#define __SADD16                          __sadd16
+#define __QADD16                          __qadd16
+#define __SHADD16                         __shadd16
+#define __UADD16                          __uadd16
+#define __UQADD16                         __uqadd16
+#define __UHADD16                         __uhadd16
+#define __SSUB16                          __ssub16
+#define __QSUB16                          __qsub16
+#define __SHSUB16                         __shsub16
+#define __USUB16                          __usub16
+#define __UQSUB16                         __uqsub16
+#define __UHSUB16                         __uhsub16
+#define __SASX                            __sasx
+#define __QASX                            __qasx
+#define __SHASX                           __shasx
+#define __UASX                            __uasx
+#define __UQASX                           __uqasx
+#define __UHASX                           __uhasx
+#define __SSAX                            __ssax
+#define __QSAX                            __qsax
+#define __SHSAX                           __shsax
+#define __USAX                            __usax
+#define __UQSAX                           __uqsax
+#define __UHSAX                           __uhsax
+#define __USAD8                           __usad8
+#define __USADA8                          __usada8
+#define __SSAT16                          __ssat16
+#define __USAT16                          __usat16
+#define __UXTB16                          __uxtb16
+#define __UXTAB16                         __uxtab16
+#define __SXTB16                          __sxtb16
+#define __SXTAB16                         __sxtab16
+#define __SMUAD                           __smuad
+#define __SMUADX                          __smuadx
+#define __SMLAD                           __smlad
+#define __SMLADX                          __smladx
+#define __SMLALD                          __smlald
+#define __SMLALDX                         __smlaldx
+#define __SMUSD                           __smusd
+#define __SMUSDX                          __smusdx
+#define __SMLSD                           __smlsd
+#define __SMLSDX                          __smlsdx
+#define __SMLSLD                          __smlsld
+#define __SMLSLDX                         __smlsldx
+#define __SEL                             __sel
+#define __QADD                            __qadd
+#define __QSUB                            __qsub
+
+#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
+                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
+
+#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
+                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
+
+#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
+                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_iar.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+#include <cmsis_ccs.h>
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SSAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+#define __USAT16(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLALD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLALDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((uint64_t)(ARG3) >> 32), __ARG3_L = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
+{
+  uint32_t result;
+
+  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
+  return(result);
+}
+
+#define __SMLSLD(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+#define __SMLSLDX(ARG1,ARG2,ARG3) \
+({ \
+  uint32_t __ARG1 = (ARG1), __ARG2 = (ARG2), __ARG3_H = (uint32_t)((ARG3) >> 32), __ARG3_L = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \
+  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (__ARG3_L), "=r" (__ARG3_H) : "r" (__ARG1), "r" (__ARG2), "0" (__ARG3_L), "1" (__ARG3_H) ); \
+  (uint64_t)(((uint64_t)__ARG3_H << 32) | __ARG3_L); \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
+{
+  uint32_t result;
+
+  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
+  return(result);
+}
+
+#define __PKHBT(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+#define __PKHTB(ARG1,ARG2,ARG3) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
+  if (ARG3 == 0) \
+    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
+  else \
+    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
+  __RES; \
+ })
+
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
+{
+ int32_t result;
+
+ __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
+ return(result);
+}
+
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+
+/*------ CM4 SIMD Intrinsics -----------------------------------------------------*/
+/* not yet supported */
+/*-- End CM4 SIMD Intrinsics -----------------------------------------------------*/
+
+
+#endif
+
+/*@} end of group CMSIS_SIMD_intrinsics */
+
+
+#endif /* __CORE_CM4_SIMD_H */
+
+#ifdef __cplusplus
+}
+#endif
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/core_cmFunc.h ./chip/inc/core_cmFunc.h
--- a_tnusFF/chip/inc/core_cmFunc.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/core_cmFunc.h	2016-10-22 23:17:43.548840278 -0300
@@ -0,0 +1,636 @@
+/**************************************************************************//**
+ * @file     core_cmFunc.h
+ * @brief    CMSIS Cortex-M Core Function Access Header File
+ * @version  V3.20
+ * @date     25. February 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMFUNC_H
+#define __CORE_CMFUNC_H
+
+
+/* ###########################  Core Function Access  ########################### */
+/** \ingroup  CMSIS_Core_FunctionInterface
+    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
+  @{
+ */
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+/* intrinsic void __enable_irq();     */
+/* intrinsic void __disable_irq();    */
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  register uint32_t __regControl         __ASM("control");
+  return(__regControl);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  register uint32_t __regControl         __ASM("control");
+  __regControl = control;
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  register uint32_t __regIPSR          __ASM("ipsr");
+  return(__regIPSR);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__STATIC_INLINE uint32_t __get_APSR(void)
+{
+  register uint32_t __regAPSR          __ASM("apsr");
+  return(__regAPSR);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  register uint32_t __regXPSR          __ASM("xpsr");
+  return(__regXPSR);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  return(__regProcessStackPointer);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  register uint32_t __regProcessStackPointer  __ASM("psp");
+  __regProcessStackPointer = topOfProcStack;
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  return(__regMainStackPointer);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  register uint32_t __regMainStackPointer     __ASM("msp");
+  __regMainStackPointer = topOfMainStack;
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  return(__regPriMask);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  register uint32_t __regPriMask         __ASM("primask");
+  __regPriMask = (priMask);
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __enable_fault_irq                __enable_fiq
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+#define __disable_fault_irq               __disable_fiq
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__STATIC_INLINE uint32_t  __get_BASEPRI(void)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  return(__regBasePri);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
+{
+  register uint32_t __regBasePri         __ASM("basepri");
+  __regBasePri = (basePri & 0xff);
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  return(__regFaultMask);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  register uint32_t __regFaultMask       __ASM("faultmask");
+  __regFaultMask = (faultMask & (uint32_t)1);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  return(__regfpscr);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  register uint32_t __regfpscr         __ASM("fpscr");
+  __regfpscr = (fpscr);
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/** \brief  Enable IRQ Interrupts
+
+  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
+{
+  __ASM volatile ("cpsie i" : : : "memory");
+}
+
+
+/** \brief  Disable IRQ Interrupts
+
+  This function disables IRQ interrupts by setting the I-bit in the CPSR.
+  Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
+{
+  __ASM volatile ("cpsid i" : : : "memory");
+}
+
+
+/** \brief  Get Control Register
+
+    This function returns the content of the Control Register.
+
+    \return               Control Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, control" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Control Register
+
+    This function writes the given value to the Control Register.
+
+    \param [in]    control  Control Register value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
+{
+  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
+}
+
+
+/** \brief  Get IPSR Register
+
+    This function returns the content of the IPSR Register.
+
+    \return               IPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get APSR Register
+
+    This function returns the content of the APSR Register.
+
+    \return               APSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get xPSR Register
+
+    This function returns the content of the xPSR Register.
+
+    \return               xPSR Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Get Process Stack Pointer
+
+    This function returns the current value of the Process Stack Pointer (PSP).
+
+    \return               PSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Process Stack Pointer
+
+    This function assigns the given value to the Process Stack Pointer (PSP).
+
+    \param [in]    topOfProcStack  Process Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
+{
+  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
+}
+
+
+/** \brief  Get Main Stack Pointer
+
+    This function returns the current value of the Main Stack Pointer (MSP).
+
+    \return               MSP Register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
+{
+  register uint32_t result;
+
+  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Main Stack Pointer
+
+    This function assigns the given value to the Main Stack Pointer (MSP).
+
+    \param [in]    topOfMainStack  Main Stack Pointer value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
+{
+  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
+}
+
+
+/** \brief  Get Priority Mask
+
+    This function returns the current state of the priority mask bit from the Priority Mask Register.
+
+    \return               Priority Mask value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, primask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Priority Mask
+
+    This function assigns the given value to the Priority Mask Register.
+
+    \param [in]    priMask  Priority Mask
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
+{
+  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
+}
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Enable FIQ
+
+    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
+{
+  __ASM volatile ("cpsie f" : : : "memory");
+}
+
+
+/** \brief  Disable FIQ
+
+    This function disables FIQ interrupts by setting the F-bit in the CPSR.
+    Can only be executed in Privileged modes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
+{
+  __ASM volatile ("cpsid f" : : : "memory");
+}
+
+
+/** \brief  Get Base Priority
+
+    This function returns the current value of the Base Priority register.
+
+    \return               Base Priority register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Base Priority
+
+    This function assigns the given value to the Base Priority register.
+
+    \param [in]    basePri  Base Priority value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
+{
+  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
+}
+
+
+/** \brief  Get Fault Mask
+
+    This function returns the current value of the Fault Mask register.
+
+    \return               Fault Mask register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
+{
+  uint32_t result;
+
+  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
+  return(result);
+}
+
+
+/** \brief  Set Fault Mask
+
+    This function assigns the given value to the Fault Mask register.
+
+    \param [in]    faultMask  Fault Mask value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
+{
+  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+#if       (__CORTEX_M == 0x04)
+
+/** \brief  Get FPSCR
+
+    This function returns the current value of the Floating Point Status/Control register.
+
+    \return               Floating Point Status/Control register value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  uint32_t result;
+
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
+  __ASM volatile ("");
+  return(result);
+#else
+   return(0);
+#endif
+}
+
+
+/** \brief  Set FPSCR
+
+    This function assigns the given value to the Floating Point Status/Control register.
+
+    \param [in]    fpscr  Floating Point Status/Control value to set
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
+{
+#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
+  /* Empty asm statement works as a scheduling barrier */
+  __ASM volatile ("");
+  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
+  __ASM volatile ("");
+#endif
+}
+
+#endif /* (__CORTEX_M == 0x04) */
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all instrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@} end of CMSIS_Core_RegAccFunctions */
+
+
+#endif /* __CORE_CMFUNC_H */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/core_cmInstr.h ./chip/inc/core_cmInstr.h
--- a_tnusFF/chip/inc/core_cmInstr.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/core_cmInstr.h	2016-10-22 23:17:43.548840278 -0300
@@ -0,0 +1,688 @@
+/**************************************************************************//**
+ * @file     core_cmInstr.h
+ * @brief    CMSIS Cortex-M Core Instruction Access Header File
+ * @version  V3.20
+ * @date     05. March 2013
+ *
+ * @note
+ *
+ ******************************************************************************/
+/* Copyright (c) 2009 - 2013 ARM LIMITED
+
+   All rights reserved.
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions are met:
+   - Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+   - Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+   - Neither the name of ARM nor the names of its contributors may be used
+     to endorse or promote products derived from this software without
+     specific prior written permission.
+   *
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
+   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+   POSSIBILITY OF SUCH DAMAGE.
+   ---------------------------------------------------------------------------*/
+
+
+#ifndef __CORE_CMINSTR_H
+#define __CORE_CMINSTR_H
+
+
+/* ##########################  Core Instruction Access  ######################### */
+/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
+  Access to dedicated instructions
+  @{
+*/
+
+#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
+/* ARM armcc specific functions */
+
+#if (__ARMCC_VERSION < 400677)
+  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
+#endif
+
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+#define __NOP                             __nop
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+#define __WFI                             __wfi
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+#define __WFE                             __wfe
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+#define __SEV                             __sev
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+#define __ISB()                           __isb(0xF)
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+#define __DSB()                           __dsb(0xF)
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+#define __DMB()                           __dmb(0xF)
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __REV                             __rev
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
+{
+  rev16 r0, r0
+  bx lr
+}
+#endif
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#ifndef __NO_EMBEDDED_ASM
+__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
+{
+  revsh r0, r0
+  bx lr
+}
+#endif
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+#define __ROR                             __ror
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __breakpoint(value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+#define __RBIT                            __rbit
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXB(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXH(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+#define __STREXW(value, ptr)              __strex(value, ptr)
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+#define __CLREX                           __clrex
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT                            __ssat
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT                            __usat
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+#define __CLZ                             __clz
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
+/* IAR iccarm specific functions */
+
+#include <cmsis_iar.h>
+
+
+#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
+/* TI CCS specific functions */
+
+#include <cmsis_ccs.h>
+
+
+#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
+/* GNU gcc specific functions */
+
+/* Define macros for porting to both thumb1 and thumb2.
+ * For thumb1, use low register (r0-r7), specified by constrant "l"
+ * Otherwise, use general registers, specified by constrant "r" */
+#if defined (__thumb__) && !defined (__thumb2__)
+#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
+#define __CMSIS_GCC_USE_REG(r) "l" (r)
+#else
+#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
+#define __CMSIS_GCC_USE_REG(r) "r" (r)
+#endif
+
+/** \brief  No Operation
+
+    No Operation does nothing. This instruction can be used for code alignment purposes.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
+{
+  __ASM volatile ("nop");
+}
+
+
+/** \brief  Wait For Interrupt
+
+    Wait For Interrupt is a hint instruction that suspends execution
+    until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
+{
+  __ASM volatile ("wfi");
+}
+
+
+/** \brief  Wait For Event
+
+    Wait For Event is a hint instruction that permits the processor to enter
+    a low-power state until one of a number of events occurs.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
+{
+  __ASM volatile ("wfe");
+}
+
+
+/** \brief  Send Event
+
+    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
+{
+  __ASM volatile ("sev");
+}
+
+
+/** \brief  Instruction Synchronization Barrier
+
+    Instruction Synchronization Barrier flushes the pipeline in the processor,
+    so that all instructions following the ISB are fetched from cache or
+    memory, after the instruction has been completed.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
+{
+  __ASM volatile ("isb");
+}
+
+
+/** \brief  Data Synchronization Barrier
+
+    This function acts as a special kind of Data Memory Barrier.
+    It completes when all explicit memory accesses before this instruction complete.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
+{
+  __ASM volatile ("dsb");
+}
+
+
+/** \brief  Data Memory Barrier
+
+    This function ensures the apparent order of the explicit memory operations before
+    and after the instruction, without ensuring their completion.
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
+{
+  __ASM volatile ("dmb");
+}
+
+
+/** \brief  Reverse byte order (32 bit)
+
+    This function reverses the byte order in integer value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+  return __builtin_bswap32(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Reverse byte order (16 bit)
+
+    This function reverses the byte order in two unsigned short values.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
+{
+  uint32_t result;
+
+  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+}
+
+
+/** \brief  Reverse byte order in signed short value
+
+    This function reverses the byte order in a signed short value with sign extension to integer.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
+{
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+  return (short)__builtin_bswap16(value);
+#else
+  uint32_t result;
+
+  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
+  return(result);
+#endif
+}
+
+
+/** \brief  Rotate Right in unsigned value (32 bit)
+
+    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
+
+    \param [in]    value  Value to rotate
+    \param [in]    value  Number of Bits to rotate
+    \return               Rotated value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
+{
+  return (op1 >> op2) | (op1 << (32 - op2));
+}
+
+
+/** \brief  Breakpoint
+
+    This function causes the processor to enter Debug state.
+    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
+
+    \param [in]    value  is ignored by the processor.
+                   If required, a debugger can use it to store additional information about the breakpoint.
+ */
+#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
+
+
+#if       (__CORTEX_M >= 0x03)
+
+/** \brief  Reverse bit order of value
+
+    This function reverses the bit order of the given value.
+
+    \param [in]    value  Value to reverse
+    \return               Reversed value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
+{
+  uint32_t result;
+
+   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (8 bit)
+
+    This function performs a exclusive LDR command for 8 bit value.
+
+    \param [in]    ptr  Pointer to data
+    \return             value of type uint8_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (16 bit)
+
+    This function performs a exclusive LDR command for 16 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint16_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
+{
+    uint32_t result;
+
+#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
+   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
+#else
+    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
+       accepted by assembler. So has to use following less efficient pattern.
+    */
+   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
+#endif
+   return(result);
+}
+
+
+/** \brief  LDR Exclusive (32 bit)
+
+    This function performs a exclusive LDR command for 32 bit values.
+
+    \param [in]    ptr  Pointer to data
+    \return        value of type uint32_t at (*ptr)
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
+{
+    uint32_t result;
+
+   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (8 bit)
+
+    This function performs a exclusive STR command for 8 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (16 bit)
+
+    This function performs a exclusive STR command for 16 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  STR Exclusive (32 bit)
+
+    This function performs a exclusive STR command for 32 bit values.
+
+    \param [in]  value  Value to store
+    \param [in]    ptr  Pointer to location
+    \return          0  Function succeeded
+    \return          1  Function failed
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
+{
+   uint32_t result;
+
+   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
+   return(result);
+}
+
+
+/** \brief  Remove the exclusive lock
+
+    This function removes the exclusive lock which is created by LDREX.
+
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
+{
+  __ASM volatile ("clrex" ::: "memory");
+}
+
+
+/** \brief  Signed Saturate
+
+    This function saturates a signed value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (1..32)
+    \return             Saturated value
+ */
+#define __SSAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Unsigned Saturate
+
+    This function saturates an unsigned value.
+
+    \param [in]  value  Value to be saturated
+    \param [in]    sat  Bit position to saturate to (0..31)
+    \return             Saturated value
+ */
+#define __USAT(ARG1,ARG2) \
+({                          \
+  uint32_t __RES, __ARG1 = (ARG1); \
+  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
+  __RES; \
+ })
+
+
+/** \brief  Count leading zeros
+
+    This function counts the number of leading zeros of a data value.
+
+    \param [in]  value  Value to count the leading zeros
+    \return             number of leading zeros in value
+ */
+__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
+{
+   uint32_t result;
+
+  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
+  return(result);
+}
+
+#endif /* (__CORTEX_M >= 0x03) */
+
+
+
+
+#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
+/* TASKING carm specific functions */
+
+/*
+ * The CMSIS functions have been implemented as intrinsics in the compiler.
+ * Please use "carm -?i" to get an up to date list of all intrinsics,
+ * Including the CMSIS ones.
+ */
+
+#endif
+
+/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
+
+#endif /* __CORE_CMINSTR_H */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/cpuctrl_5410x.h ./chip/inc/cpuctrl_5410x.h
--- a_tnusFF/chip/inc/cpuctrl_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/cpuctrl_5410x.h	2016-10-22 23:17:43.548840278 -0300
@@ -0,0 +1,117 @@
+/*
+ * @brief LPC5410X CPU multi-core support driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CPUCTRL_5410X_H_
+#define __CPUCTRL_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CPUCTRL_5410X CHIP: LPC5410X CPU multi-core support driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * This driver helps with determine which MCU core the software is running,
+ * whether the MCU core is in master or slave mode, and provides functions
+ * for master and slave core control.<br>
+ *
+ * The functions for the driver are provided as part of the
+ * @ref POWER_LIBRARY_5410X library. For more information on using the
+ * LPC5410x LPCopen package with multi-core, see @ref CHIP_5410X_MULTICORE<br>.
+ * @{
+ */
+
+/**
+ * @brief	Determine which MCU this code is running on
+ * @return  true if executing on the CM4, or false if executing on the CM0+
+ */
+__STATIC_INLINE bool Chip_CPU_IsM4Core(void) {
+	/* M4 core is designated by values 0xC24 on bits 15..4 */
+	if (((SCB->CPUID >> 4) & 0xFFF) == 0xC24) {
+		return true;
+	}
+
+	return false;
+}
+
+/* Core selection */
+typedef enum {
+	CORESELECT_M0PLUS = 0,
+	CORESELECT_M4
+} CORESELECT_T;
+
+/**
+ * @brief	Select master core and system power control ownership
+ * @return	Nothing
+ * @note	This function can be used to select the master core and which
+ * core can powerdown the system. The master core can be re-selected on
+ * either the current master or slave core. Power control ownership is used
+ * to select which core can place the system in DEEP SLEEP, POWERDOWN, and
+ * DEEP POWERDOWN modes. (See @ref Chip_POWER_EnterPowerMode). Note both
+ * the master and slave cores can used SLEEP mode, but only the master core
+ * can use the other modes.
+ */
+void Chip_CPU_SelectMasterCore(CORESELECT_T master, CORESELECT_T ownerPower);
+
+/**
+ * @brief	Determine if this core is a slave or master
+ * @return  true if this MCU is operating as the master, or false if operating as a slave
+ */
+bool Chip_CPU_IsMasterCore(void);
+
+/**
+ * @brief	Setup M0+ boot and reset M0+ core
+ * @param	coentry		: Pointer to boot entry point for M0+ core
+ * @param	costackptr	: Pointer to where stack should be located for M0+ core
+ * @return  Nothing
+ * @note	Will setup boot stack and entry point, enable M0+ clock and then
+ * reset M0+ core.
+ */
+void Chip_CPU_CM0Boot(uint32_t *coentry, uint32_t *costackptr);
+
+/**
+ * @brief	Setup M4 boot and reset M4 core
+ * @param	coentry		: Pointer to boot entry point for M4 core
+ * @param	costackptr	: Pointer to where stack should be located for M4 core
+ * @return  Nothing
+ * @note	Will setup boot stack and entry point, enable M4 clock and then
+ * reset M0+ core.
+ */
+void Chip_CPU_CM4Boot(uint32_t *coentry, uint32_t *costackptr);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CPUCTRL_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/crc_5410x.h ./chip/inc/crc_5410x.h
--- a_tnusFF/chip/inc/crc_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/crc_5410x.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,262 @@
+/*
+ * @brief LPC5410X Cyclic Redundancy Check (CRC) Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __CRC_5410X_H_
+#define __CRC_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup CRC_5410X CHIP: LPC5410X Cyclic Redundancy Check Engine driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief CRC register block structure
+ */
+typedef struct {					/*!< CRC Structure */
+	__IO    uint32_t    MODE;		/*!< CRC Mode Register */
+	__IO    uint32_t    SEED;		/*!< CRC SEED Register */
+	union {
+		__I     uint32_t    SUM;	/*!< CRC Checksum Register. */
+		__O     uint32_t    WRDATA32;	/*!< CRC Data Register: write size 32-bit*/
+		__O     uint16_t    WRDATA16;	/*!< CRC Data Register: write size 16-bit*/
+		__O     uint8_t     WRDATA8;	/*!< CRC Data Register: write size 8-bit*/
+	};
+
+} LPC_CRC_T;
+
+/*
+ * @brief CRC MODE register description
+ */
+#define CRC_MODE_POLY_BITMASK   ((0x03))	/** CRC polynomial Bit mask */
+#define CRC_MODE_POLY_CCITT     (0x00)		/** Select CRC-CCITT polynomial */
+#define CRC_MODE_POLY_CRC16     (0x01)		/** Select CRC-16 polynomial */
+#define CRC_MODE_POLY_CRC32     (0x02)		/** Select CRC-32 polynomial */
+#define CRC_MODE_WRDATA_BITMASK (0x03 << 2)	/** CRC WR_Data Config Bit mask */
+#define CRC_MODE_WRDATA_BIT_RVS (1 << 2)	/** Select Bit order reverse for WR_DATA (per byte) */
+#define CRC_MODE_WRDATA_CMPL    (1 << 3)	/** Select One's complement for WR_DATA */
+#define CRC_MODE_SUM_BITMASK    (0x03 << 4)	/** CRC Sum Config Bit mask */
+#define CRC_MODE_SUM_BIT_RVS    (1 << 4)	/** Select Bit order reverse for CRC_SUM */
+#define CRC_MODE_SUM_CMPL       (1 << 5)	/** Select One's complement for CRC_SUM */
+
+#define MODE_CFG_CCITT          (0x00)	/** Pre-defined mode word for default CCITT setup */
+#define MODE_CFG_CRC16          (0x15)	/** Pre-defined mode word for default CRC16 setup */
+#define MODE_CFG_CRC32          (0x36)	/** Pre-defined mode word for default CRC32 setup */
+
+#define CRC_SEED_CCITT          (0x0000FFFF)/** Initial seed value for CCITT mode */
+#define CRC_SEED_CRC16          (0x00000000)/** Initial seed value for CRC16 mode */
+#define CRC_SEED_CRC32          (0xFFFFFFFF)/** Initial seed value for CRC32 mode */
+
+/**
+ * @brief CRC polynomial
+ */
+typedef enum IP_CRC_001_POLY {
+	CRC_POLY_CCITT = CRC_MODE_POLY_CCITT,	/**< CRC-CCIT polynomial */
+	CRC_POLY_CRC16 = CRC_MODE_POLY_CRC16,	/**< CRC-16 polynomial */
+	CRC_POLY_CRC32 = CRC_MODE_POLY_CRC32,	/**< CRC-32 polynomial */
+	CRC_POLY_LAST,
+} CRC_POLY_T;
+
+/**
+ * @brief	Initializes the CRC Engine
+ * @return	Nothing
+ */
+void Chip_CRC_Init(void);
+
+/**
+ * @brief	Deinitializes the CRC Engine
+ * @return	Nothing
+ */
+void Chip_CRC_Deinit(void);
+
+/**
+ * @brief	Set the polynomial used for the CRC calculation
+ * @param	poly	: The enumerated polynomial to be used
+ * @param	flags	: An Or'ed value of flags that setup the mode
+ * @return	Nothing
+ * @note	Flags for setting up the mode word include CRC_MODE_WRDATA_BIT_RVS,
+ * CRC_MODE_WRDATA_CMPL, CRC_MODE_SUM_BIT_RVS, and CRC_MODE_SUM_CMPL.
+ */
+__STATIC_INLINE void Chip_CRC_SetPoly(CRC_POLY_T poly, uint32_t flags)
+{
+	LPC_CRC->MODE = (uint32_t) poly | flags;
+}
+
+/**
+ * @brief	Sets up the CRC engine for CRC16 mode
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_UseCRC16(void)
+{
+	LPC_CRC->MODE = MODE_CFG_CRC16;
+	LPC_CRC->SEED = CRC_SEED_CRC16;
+}
+
+/**
+ * @brief	Sets up the CRC engine for CRC32 mode
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_UseCRC32(void)
+{
+	LPC_CRC->MODE = MODE_CFG_CRC32;
+	LPC_CRC->SEED = CRC_SEED_CRC32;
+}
+
+/**
+ * @brief	Sets up the CRC engine for CCITT mode
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_UseCCITT(void)
+{
+	LPC_CRC->MODE = MODE_CFG_CCITT;
+	LPC_CRC->SEED = CRC_SEED_CCITT;
+}
+
+/**
+ * @brief	Engage the CRC engine with defaults based on the polynomial to be used
+ * @param	poly	: The enumerated polynomial to be used
+ * @return	Nothing
+ */
+void Chip_CRC_UseDefaultConfig(CRC_POLY_T poly);
+
+/**
+ * @brief	Set the CRC Mode bits
+ * @param	mode	: Mode value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_SetMode(uint32_t mode)
+{
+	LPC_CRC->MODE = mode;
+}
+
+/**
+ * @brief	Get the CRC Mode bits
+ * @return	The current value of the CRC Mode bits
+ */
+__STATIC_INLINE uint32_t Chip_CRC_GetMode(void)
+{
+	return LPC_CRC->MODE;
+}
+
+/**
+ * @brief	Set the seed bits used by the CRC_SUM register
+ * @param	seed	: Seed value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_SetSeed(uint32_t seed)
+{
+	LPC_CRC->SEED = seed;
+}
+
+/**
+ * @brief	Get the CRC seed value
+ * @return	Seed value
+ */
+__STATIC_INLINE uint32_t Chip_CRC_GetSeed(void)
+{
+	return LPC_CRC->SEED;
+}
+
+/**
+ * @brief	Convenience function for writing 8-bit data to the CRC engine
+ * @param	data	: 8-bit data to write
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_Write8(uint8_t data)
+{
+	LPC_CRC->WRDATA8 = data;
+}
+
+/**
+ * @brief	Convenience function for writing 16-bit data to the CRC engine
+ * @param	data	: 16-bit data to write
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_Write16(uint16_t data)
+{
+	LPC_CRC->WRDATA16 = data;
+}
+
+/**
+ * @brief	Convenience function for writing 32-bit data to the CRC engine
+ * @param	data	: 32-bit data to write
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_CRC_Write32(uint32_t data)
+{
+	LPC_CRC->WRDATA32 = data;
+}
+
+/**
+ * @brief	Gets the CRC Sum based on the Mode and Seed as previously configured
+ * @return	CRC Checksum value
+ */
+__STATIC_INLINE uint32_t Chip_CRC_Sum(void)
+{
+	return LPC_CRC->SUM;
+}
+
+/**
+ * @brief	Convenience function for computing a standard CCITT checksum from an 8-bit data block
+ * @param	data	: Pointer to the block of 8-bit data
+ * @param   bytes	: The number of bytes pointed to by data
+ * @return	Check sum value
+ */
+uint32_t Chip_CRC_CRC8(const uint8_t *data, uint32_t bytes);
+
+/**
+ * @brief	Convenience function for computing a standard CRC16 checksum from 16-bit data block
+ * @param	data	: Pointer to the block of 16-bit data
+ * @param   hwords	: The number of 16 byte entries pointed to by data
+ * @return	Check sum value
+ */
+uint32_t Chip_CRC_CRC16(const uint16_t *data, uint32_t hwords);
+
+/**
+ * @brief	Convenience function for computing a standard CRC32 checksum from 32-bit data block
+ * @param	data	: Pointer to the block of 32-bit data
+ * @param   words	: The number of 32-bit entries pointed to by data
+ * @return	Check sum value
+ */
+uint32_t Chip_CRC_CRC32(const uint32_t *data, uint32_t words);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CRC_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/dma_5410x.h ./chip/inc/dma_5410x.h
--- a_tnusFF/chip/inc/dma_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/dma_5410x.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,714 @@
+/*
+ * @brief LPC5410X DMA driver declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __DMA_5410X_H
+#define __DMA_5410X_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup DMALEG_5410X CHIP: LPC5410X DMA Engine driver (legacy)
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+/**
+ * @brief DMA Controller shared registers structure
+ */
+typedef struct {					/*!< DMA shared registers structure */
+	__IO uint32_t  ENABLESET;		/*!< DMA Channel Enable read and Set for all DMA channels */
+	__I  uint32_t  RESERVED0;
+	__O  uint32_t  ENABLECLR;		/*!< DMA Channel Enable Clear for all DMA channels */
+	__I  uint32_t  RESERVED1;
+	__I  uint32_t  ACTIVE;			/*!< DMA Channel Active status for all DMA channels */
+	__I  uint32_t  RESERVED2;
+	__I  uint32_t  BUSY;			/*!< DMA Channel Busy status for all DMA channels */
+	__I  uint32_t  RESERVED3;
+	__IO uint32_t  ERRINT;			/*!< DMA Error Interrupt status for all DMA channels */
+	__I  uint32_t  RESERVED4;
+	__IO uint32_t  INTENSET;		/*!< DMA Interrupt Enable read and Set for all DMA channels */
+	__I  uint32_t  RESERVED5;
+	__O  uint32_t  INTENCLR;		/*!< DMA Interrupt Enable Clear for all DMA channels */
+	__I  uint32_t  RESERVED6;
+	__IO  uint32_t  INTA;			/*!< DMA Interrupt A status for all DMA channels */
+	__I  uint32_t  RESERVED7;
+	__IO  uint32_t  INTB;			/*!< DMA Interrupt B status for all DMA channels */
+	__I  uint32_t  RESERVED8;
+	__O  uint32_t  SETVALID;		/*!< DMA Set ValidPending control bits for all DMA channels */
+	__I  uint32_t  RESERVED9;
+	__O  uint32_t  SETTRIG;			/*!< DMA Set Trigger control bits for all DMA channels */
+	__I  uint32_t  RESERVED10;
+	__O  uint32_t  ABORT;			/*!< DMA Channel Abort control for all DMA channels */
+} LPC_DMA_COMMON_T;
+
+/**
+ * @brief DMA Controller shared registers structure
+ */
+typedef struct {					/*!< DMA channel register structure */
+	__IO  uint32_t  CFG;				/*!< DMA Configuration register */
+	__I   uint32_t  CTLSTAT;			/*!< DMA Control and status register */
+	__IO  uint32_t  XFERCFG;			/*!< DMA Transfer configuration register */
+	__I   uint32_t  RESERVED;
+} LPC_DMA_CHANNEL_T;
+
+/* On LPC540XX, Max DMA channel is 22 */
+#define MAX_DMA_CHANNEL         (22)
+
+/**
+ * @brief DMA Controller register block structure
+ */
+typedef struct {					/*!< DMA Structure */
+	__IO uint32_t  CTRL;			/*!< DMA control register */
+	__I  uint32_t  INTSTAT;			/*!< DMA Interrupt status register */
+	__IO uint32_t  SRAMBASE;		/*!< DMA SRAM address of the channel configuration table */
+	__I  uint32_t  RESERVED2[5];
+	LPC_DMA_COMMON_T DMACOMMON[1];	/*!< DMA shared channel (common) registers */
+	__I  uint32_t  RESERVED0[225];
+	LPC_DMA_CHANNEL_T DMACH[MAX_DMA_CHANNEL];	/*!< DMA channel registers */
+} LPC_DMA_T;
+
+/* DMA interrupt status bits (common) */
+#define DMA_INTSTAT_ACTIVEINT       0x2		/*!< Summarizes whether any enabled interrupts are pending */
+#define DMA_INTSTAT_ACTIVEERRINT    0x4		/*!< Summarizes whether any error interrupts are pending */
+
+/* Support macro for DMA_CHDESC_T */
+#define DMA_ADDR(addr)      ((uint32_t) (addr))
+
+/* Support definitions for setting the configuration of a DMA channel. You
+   will need to get more information on these options from the User manual. */
+#define DMA_CFG_PERIPHREQEN     (1 << 0)	/*!< Enables Peripheral DMA requests */
+#define DMA_CFG_HWTRIGEN        (1 << 1)	/*!< Use hardware triggering via imput mux */
+#define DMA_CFG_TRIGPOL_LOW     (0 << 4)	/*!< Hardware trigger is active low or falling edge */
+#define DMA_CFG_TRIGPOL_HIGH    (1 << 4)	/*!< Hardware trigger is active high or rising edge */
+#define DMA_CFG_TRIGTYPE_EDGE   (0 << 5)	/*!< Hardware trigger is edge triggered */
+#define DMA_CFG_TRIGTYPE_LEVEL  (1 << 5)	/*!< Hardware trigger is level triggered */
+#define DMA_CFG_TRIGBURST_SNGL  (0 << 6)	/*!< Single transfer. Hardware trigger causes a single transfer */
+#define DMA_CFG_TRIGBURST_BURST (1 << 6)	/*!< Burst transfer (see UM) */
+#define DMA_CFG_BURSTPOWER_1    (0 << 8)	/*!< Set DMA burst size to 1 transfer */
+#define DMA_CFG_BURSTPOWER_2    (1 << 8)	/*!< Set DMA burst size to 2 transfers */
+#define DMA_CFG_BURSTPOWER_4    (2 << 8)	/*!< Set DMA burst size to 4 transfers */
+#define DMA_CFG_BURSTPOWER_8    (3 << 8)	/*!< Set DMA burst size to 8 transfers */
+#define DMA_CFG_BURSTPOWER_16   (4 << 8)	/*!< Set DMA burst size to 16 transfers */
+#define DMA_CFG_BURSTPOWER_32   (5 << 8)	/*!< Set DMA burst size to 32 transfers */
+#define DMA_CFG_BURSTPOWER_64   (6 << 8)	/*!< Set DMA burst size to 64 transfers */
+#define DMA_CFG_BURSTPOWER_128  (7 << 8)	/*!< Set DMA burst size to 128 transfers */
+#define DMA_CFG_BURSTPOWER_256  (8 << 8)	/*!< Set DMA burst size to 256 transfers */
+#define DMA_CFG_BURSTPOWER_512  (9 << 8)	/*!< Set DMA burst size to 512 transfers */
+#define DMA_CFG_BURSTPOWER_1024 (10 << 8)	/*!< Set DMA burst size to 1024 transfers */
+#define DMA_CFG_BURSTPOWER(n)   ((n) << 8)	/*!< Set DMA burst size to 2^n transfers, max n=10 */
+#define DMA_CFG_SRCBURSTWRAP    (1 << 14)	/*!< Source burst wrapping is enabled for this DMA channel */
+#define DMA_CFG_DSTBURSTWRAP    (1 << 15)	/*!< Destination burst wrapping is enabled for this DMA channel */
+#define DMA_CFG_CHPRIORITY(p)   ((p) << 16)	/*!< Sets DMA channel priority, min 0 (highest), max 3 (lowest) */
+
+/* DMA channel control and status register definitions */
+#define DMA_CTLSTAT_VALIDPENDING    (1 << 0)	/*!< Valid pending flag for this channel */
+#define DMA_CTLSTAT_TRIG            (1 << 2)	/*!< Trigger flag. Indicates that the trigger for this channel is currently set */
+
+/* DMA channel transfer configuration registers definitions */
+#define DMA_XFERCFG_CFGVALID        (1 << 0)	/*!< Configuration Valid flag */
+#define DMA_XFERCFG_RELOAD          (1 << 1)	/*!< Indicates whether the channels control structure will be reloaded when the current descriptor is exhausted */
+#define DMA_XFERCFG_SWTRIG          (1 << 2)	/*!< Software Trigger */
+#define DMA_XFERCFG_CLRTRIG         (1 << 3)	/*!< Clear Trigger */
+#define DMA_XFERCFG_SETINTA         (1 << 4)	/*!< Set Interrupt flag A for this channel to fire when descriptor is complete */
+#define DMA_XFERCFG_SETINTB         (1 << 5)	/*!< Set Interrupt flag B for this channel to fire when descriptor is complete */
+#define DMA_XFERCFG_WIDTH_8         (0 << 8)	/*!< 8-bit transfers are performed */
+#define DMA_XFERCFG_WIDTH_16        (1 << 8)	/*!< 16-bit transfers are performed */
+#define DMA_XFERCFG_WIDTH_32        (2 << 8)	/*!< 32-bit transfers are performed */
+#define DMA_XFERCFG_SRCINC_0        (0 << 12)	/*!< DMA source address is not incremented after a transfer */
+#define DMA_XFERCFG_SRCINC_1        (1 << 12)	/*!< DMA source address is incremented by 1 (width) after a transfer */
+#define DMA_XFERCFG_SRCINC_2        (2 << 12)	/*!< DMA source address is incremented by 2 (width) after a transfer */
+#define DMA_XFERCFG_SRCINC_4        (3 << 12)	/*!< DMA source address is incremented by 4 (width) after a transfer */
+#define DMA_XFERCFG_DSTINC_0        (0 << 14)	/*!< DMA destination address is not incremented after a transfer */
+#define DMA_XFERCFG_DSTINC_1        (1 << 14)	/*!< DMA destination address is incremented by 1 (width) after a transfer */
+#define DMA_XFERCFG_DSTINC_2        (2 << 14)	/*!< DMA destination address is incremented by 2 (width) after a transfer */
+#define DMA_XFERCFG_DSTINC_4        (3 << 14)	/*!< DMA destination address is incremented by 4 (width) after a transfer */
+#define DMA_XFERCFG_XFERCOUNT(n)    ((n - 1) << 16)	/*!< DMA transfer count in 'transfers', between (0)1 and (1023)1024 */
+
+/* DMA channel mapping - each channel is mapped to an individual peripheral
+   and direction or a DMA imput mux trigger */
+typedef enum {
+	DMAREQ_UART0_RX = 0,				/*!< UART00 receive DMA channel */
+	DMA_CH0 = DMAREQ_UART0_RX,
+	DMAREQ_UART0_TX,					/*!< UART0 transmit DMA channel */
+	DMA_CH1 = DMAREQ_UART0_TX,
+	DMAREQ_UART1_RX,					/*!< UART1 receive DMA channel */
+	DMA_CH2 = DMAREQ_UART1_RX,
+	DMAREQ_UART1_TX,					/*!< UART1 transmit DMA channel */
+	DMA_CH3 = DMAREQ_UART1_TX,
+	DMAREQ_UART2_RX,					/*!< UART2 receive DMA channel */
+	DMA_CH4 = DMAREQ_UART2_RX,
+	DMAREQ_UART2_TX,					/*!< UART2 transmit DMA channel */
+	DMA_CH5 = DMAREQ_UART2_TX,
+	DMAREQ_UART3_RX,					/*!< UART3 receive DMA channel */
+	DMA_CH6 = DMAREQ_UART3_RX,
+	DMAREQ_UART3_TX,					/*!< UART3 transmit DMA channel */
+	DMA_CH7 = DMAREQ_UART3_TX,
+	DMAREQ_SPI0_RX,					/*!< SPI0 receive DMA channel */
+	DMA_CH8 = DMAREQ_SPI0_RX,
+	DMAREQ_SPI0_TX,					/*!< SPI0 transmit DMA channel */
+	DMA_CH9 = DMAREQ_SPI0_TX,
+	DMAREQ_SPI1_RX,					/*!< SPI1 receive DMA channel */
+	DMA_CH10 = DMAREQ_SPI1_RX,
+	DMAREQ_SPI1_TX,					/*!< SPI1 transmit DMA channel */
+	DMA_CH11 = DMAREQ_SPI1_TX,
+	DMAREQ_I2C0_SLAVE,					/*!< I2C0 Slave DMA channel */
+	DMA_CH12 = DMAREQ_I2C0_SLAVE,
+	DMAREQ_I2C0_MASTER,					/*!< I2C0 Master DMA channel */
+	DMA_CH13 = DMAREQ_I2C0_MASTER,
+	DMAREQ_I2C1_SLAVE,					/*!< I2C1 Slave DMA channel */
+	DMA_CH14 = DMAREQ_I2C1_SLAVE,
+	DMAREQ_I2C1_MASTER,					/*!< I2C1 Master DMA channel */
+	DMA_CH15 = DMAREQ_I2C1_MASTER,
+	DMAREQ_I2C2_SLAVE,					/*!< I2C2 Slave DMA channel */
+	DMA_CH16 = DMAREQ_I2C2_SLAVE,
+	DMAREQ_I2C2_MASTER,					/*!< I2C2 Master DMA channel */
+	DMA_CH17 = DMAREQ_I2C2_MASTER,
+	DMAREQ_I2C0_MONITOR,					/*!< I2C0 Monitor DMA channel */
+	DMA_CH18 = DMAREQ_I2C0_MONITOR,
+	DMAREQ_I2C1_MONITOR,					/*!< I2C1 Monitor DMA channel */
+	DMA_CH19 = DMAREQ_I2C1_MONITOR,
+	DMAREQ_I2C2_MONITOR,					/*!< I2C2 Monitor DMA channel */
+	DMA_CH20 = DMAREQ_I2C2_MONITOR,
+	RESERVED_SPARE_DMA,
+	DMA_CH21 = RESERVED_SPARE_DMA
+} DMA_CHID_T;
+
+/** @defgroup DMALEG_COMMON_5410X CHIP: LPC5410X DMA Controller driver common functions (legacy)
+ * @{
+ */
+
+/**
+ * @brief	Initialize DMA controller
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_Init(LPC_DMA_T *pDMA)
+{
+	(void) pDMA;
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_DMA);
+}
+
+/**
+ * @brief	De-Initialize DMA controller
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_DeInit(LPC_DMA_T *pDMA)
+{
+	(void) pDMA;
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_DMA);
+}
+
+/**
+ * @brief	Enable DMA controller
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_Enable(LPC_DMA_T *pDMA)
+{
+	pDMA->CTRL = 1;
+}
+
+/**
+ * @brief	Disable DMA controller
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_Disable(LPC_DMA_T *pDMA)
+{
+	pDMA->CTRL = 0;
+}
+
+/**
+ * @brief	Get pending interrupt or error interrupts
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	An Or'ed value of DMA_INTSTAT_* types
+ * @note	If any DMA channels have an active interrupt or error interrupt
+ *			pending, this functional will a common status that applies to all
+ *			channels.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetIntStatus(LPC_DMA_T *pDMA)
+{
+	return pDMA->INTSTAT;
+}
+
+/**
+ * @brief	Set DMA controller SRAM base address
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	base	: The base address where the DMA descriptors will be stored
+ * @return	Nothing
+ * @note	A 256 byte block of memory aligned on a 256 byte boundary must be
+ *			provided for this function. It sets the base address used for
+ *			DMA descriptor table (16 descriptors total that use 16 bytes each).<br>
+ *
+ *			A pre-defined table with correct alignment can be used for this
+ *			function by calling Chip_DMA_SetSRAMBase(LPC_DMA, DMA_ADDR(Chip_DMA_Table));
+ */
+__STATIC_INLINE void Chip_DMA_SetSRAMBase(LPC_DMA_T *pDMA, uint32_t base)
+{
+	pDMA->SRAMBASE = base;
+}
+
+/**
+ * @brief	Returns DMA controller SRAM base address
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	The base address where the DMA descriptors are stored
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetSRAMBase(LPC_DMA_T *pDMA)
+{
+	return pDMA->SRAMBASE;
+}
+
+/**
+ * @}
+ */
+
+/** @defgroup DMALEG_COMMONCHAN_5410X CHIP: LPC5410X DMA Controller driver common channel functions (legacy)
+ * @{
+ */
+
+/**
+ * @brief	Enables a single DMA channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_EnableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].ENABLESET = (1 << ch);
+}
+
+/**
+ * @brief	Disables a single DMA channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_DisableChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].ENABLECLR = (1 << ch);
+}
+
+/**
+ * @brief	Returns all enabled DMA channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	An Or'ed value of all enabled DMA channels (0 - 15)
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) is enabled. A low state is disabled.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetEnabledChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].ENABLESET;
+}
+
+/**
+ * @brief	Returns all active DMA channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	An Or'ed value of all active DMA channels (0 - 15)
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) is active. A low state is inactive. A active
+ *			channel indicates that a DMA operation has been started but
+ *			not yet fully completed.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetActiveChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].ACTIVE;
+}
+
+/**
+ * @brief	Returns all busy DMA channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	An Or'ed value of all busy DMA channels (0 - 15)
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) is busy. A low state is not busy. A DMA
+ *			channel is considered busy when there is any operation
+ *			related to that channel in the DMA controllerï¿½s internal
+ *			pipeline.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetBusyChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].BUSY;
+}
+
+/**
+ * @brief	Returns pending error interrupt status for all DMA channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	An Or'ed value of all channels (0 - 15) error interrupt status
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) has a pending error interrupt. A low state
+ *			indicates no error interrupt.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetErrorIntChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].ERRINT;
+}
+
+/**
+ * @brief	Clears a pending error interrupt status for a single DMA channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_ClearErrorIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].ERRINT = (1 << ch);
+}
+
+/**
+ * @brief	Enables a single DMA channel's interrupt used in common DMA interrupt
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_EnableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].INTENSET = (1 << ch);
+}
+
+/**
+ * @brief	Disables a single DMA channel's interrupt used in common DMA interrupt
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_DisableIntChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].INTENCLR = (1 << ch);
+}
+
+/**
+ * @brief	Returns all enabled interrupt channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) has an enabled interrupt for the channel.
+ *			A low state indicates that the DMA channel will not contribute
+ *			to the common DMA interrupt status.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetEnableIntChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].INTENSET;
+}
+
+/**
+ * @brief	Returns active A interrupt status for all channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) has an active A interrupt for the channel.
+ *			A low state indicates that the A interrupt is not active.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetActiveIntAChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].INTA;
+}
+
+/**
+ * @brief	Clears active A interrupt status for a single channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_ClearActiveIntAChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].INTA = (1 << ch);
+}
+
+/**
+ * @brief	Returns active B interrupt status for all channels
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @return	Nothing
+ * @note	A high values in bits 0 .. 15 in the return values indicates
+ *			that the channel for that bit (bit 0 = channel 0, bit 1 -
+ *			channel 1, etc.) has an active B interrupt for the channel.
+ *			A low state indicates that the B interrupt is not active.
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetActiveIntBChannels(LPC_DMA_T *pDMA)
+{
+	return pDMA->DMACOMMON[0].INTB;
+}
+
+/**
+ * @brief	Clears active B interrupt status for a single channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_ClearActiveIntBChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].INTB = (1 << ch);
+}
+
+/**
+ * @brief	Sets the VALIDPENDING control bit for a single channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ * @note	See the User Manual for more information for what this bit does.
+ *
+ */
+__STATIC_INLINE void Chip_DMA_SetValidChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].SETVALID = (1 << ch);
+}
+
+/**
+ * @brief	Sets the TRIG bit for a single channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ * @note	See the User Manual for more information for what this bit does.
+ */
+__STATIC_INLINE void Chip_DMA_SetTrigChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].SETTRIG = (1 << ch);
+}
+
+/**
+ * @brief	Aborts a DMA operation for a single channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ * @note	To abort a channel, the channel should first be disabled. Then wait
+ *			until the channel is no longer busy by checking the corresponding
+ *			bit in BUSY. Finally, abort the channel operation. This prevents the
+ *			channel from restarting an incomplete operation when it is enabled
+ *			again.
+ */
+__STATIC_INLINE void Chip_DMA_AbortChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	pDMA->DMACOMMON[0].ABORT = (1 << ch);
+}
+
+/**
+ * @}
+ */
+
+/** @defgroup DMALEG_CHANNEL_5410X CHIP: LPC5410X DMA Controller driver channel specific functions (legacy)
+ * @{
+ */
+
+/* DMA channel source/address/next descriptor */
+typedef struct {
+	uint32_t  xfercfg;	/*!< Transfer configuration (only used in linked lists and ping-pong configs) */
+	uint32_t  source;		/*!< DMA transfer source end address */
+	uint32_t  dest;			/*!< DMA transfer desintation end address */
+	uint32_t  next;			/*!< Link to next DMA descriptor, must be 16 byte aligned */
+} DMA_CHDESC_T;
+
+/* DMA SRAM table - this can be optionally used with the Chip_DMA_SetSRAMBase()
+   function if a DMA SRAM table is needed. */
+extern DMA_CHDESC_T Chip_DMA_Table[MAX_DMA_CHANNEL];
+
+/**
+ * @brief	Setup a DMA channel configuration
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	cfg		: An Or'ed value of DMA_CFG_* values that define the channel's configuration
+ * @return	Nothing
+ * @note	This function sets up all configurable options for the DMA channel.
+ *			These options are usually set once for a channel and then unchanged.<br>
+ *
+ *			The following example show how to configure the channel for peripheral
+ *			DMA requests, burst transfer size of 1 (in 'transfers', not bytes),
+ *			continuous reading of the same source address, incrementing destination
+ *			address, and highest channel priority.<br>
+ *			Example: Chip_DMA_SetupChannelConfig(pDMA, SSP0_RX_DMA,
+ *				(DMA_CFG_PERIPHREQEN | DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_1 |
+ *				DMA_CFG_SRCBURSTWRAP | DMA_CFG_CHPRIORITY(0)));<br>
+ *
+ *			The following example show how to configure the channel for an external
+ *			trigger from the imput mux with low edge polarity, a burst transfer size of 8,
+ *			incrementing source and destination addresses, and lowest channel
+ *			priority.<br>
+ *			Example: Chip_DMA_SetupChannelConfig(pDMA, DMA_CH14,
+ *				(DMA_CFG_HWTRIGEN | DMA_CFG_TRIGPOL_LOW | DMA_CFG_TRIGTYPE_EDGE |
+ *				DMA_CFG_TRIGBURST_BURST | DMA_CFG_BURSTPOWER_8 |
+ *				DMA_CFG_CHPRIORITY(3)));<br>
+ *
+ *			For non-peripheral DMA triggering (DMA_CFG_HWTRIGEN definition), use the
+ *			DMA input mux functions to configure the DMA trigger source for a DMA channel.
+ */
+__STATIC_INLINE void Chip_DMA_SetupChannelConfig(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
+{
+	pDMA->DMACH[ch].CFG = cfg;
+}
+
+/**
+ * @brief	Returns channel specific status flags
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	AN Or'ed value of DMA_CTLSTAT_VALIDPENDING and DMA_CTLSTAT_TRIG
+ */
+__STATIC_INLINE uint32_t Chip_DMA_GetChannelStatus(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	return pDMA->DMACH[ch].XFERCFG;
+}
+
+/**
+ * @brief	Setup a DMA channel transfer configuration
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	cfg		: An Or'ed value of DMA_XFERCFG_* values that define the channel's transfer configuration
+ * @return	Nothing
+ * @note	This function sets up the transfer configuration for the DMA channel.<br>
+ *
+ *			The following example show how to configure the channel's transfer for
+ *			multiple transfer descriptors (ie, ping-pong), interrupt 'A' trigger on
+ *			transfer descriptor completion, 128 byte size transfers, and source and
+ *			destination address increment.<br>
+ *			Example: Chip_DMA_SetupChannelTransfer(pDMA, SSP0_RX_DMA,
+ *				(DMA_XFERCFG_CFGVALID | DMA_XFERCFG_RELOAD | DMA_XFERCFG_SETINTA |
+ *				DMA_XFERCFG_WIDTH_8 | DMA_XFERCFG_SRCINC_1 | DMA_XFERCFG_DSTINC_1 |
+ *				DMA_XFERCFG_XFERCOUNT(128)));<br>
+ */
+__STATIC_INLINE void Chip_DMA_SetupChannelTransfer(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t cfg)
+{
+	pDMA->DMACH[ch].XFERCFG = cfg;
+}
+
+/**
+ * @brief	Set DMA transfer register interrupt bits (safe)
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	mask	: Bits to set
+ * @return	Nothing
+ * @note	This function safely sets bits in the DMA channel specific XFERCFG
+ *			register.
+ */
+__STATIC_INLINE void Chip_DMA_SetTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
+{
+	/* Read and write values may not be the same, write 0 to
+	   undefined bits */
+	pDMA->DMACH[ch].XFERCFG = (pDMA->DMACH[ch].XFERCFG | mask) & ~0xFC000CC0;
+
+}
+
+/**
+ * @brief	Clear DMA transfer register interrupt bits (safe)
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	mask	: Bits to clear
+ * @return	Nothing
+ * @note	This function safely clears bits in the DMA channel specific XFERCFG
+ *			register.
+ */
+__STATIC_INLINE void Chip_DMA_ClearTranBits(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t mask)
+{
+	/* Read and write values may not be the same, write 0 to
+	   undefined bits */
+	pDMA->DMACH[ch].XFERCFG = pDMA->DMACH[ch].XFERCFG & ~(0xFC000CC0 | mask);
+
+}
+
+/**
+ * @brief	Update the transfer size in an existing DMA channel transfer configuration
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	trans	: Number of transfers to update the transfer configuration to (1 - 1023)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_SetupChannelTransferSize(LPC_DMA_T *pDMA, DMA_CHID_T ch, uint32_t trans)
+{
+	Chip_DMA_ClearTranBits(pDMA, ch, (0x3FF << 16));
+	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_XFERCOUNT(trans));
+}
+
+/**
+ * @brief	Sets a DMA channel configuration as valid
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_SetChannelValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
+}
+
+/**
+ * @brief	Sets a DMA channel configuration as invalid
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_SetChannelInValid(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	Chip_DMA_ClearTranBits(pDMA, ch, DMA_XFERCFG_CFGVALID);
+}
+
+/**
+ * @brief	Performs a software trigger of the DMA channel
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_DMA_SWTriggerChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch)
+{
+	Chip_DMA_SetTranBits(pDMA, ch, DMA_XFERCFG_SWTRIG);
+}
+
+/**
+ * @brief	Sets up a DMA channel with the passed DMA transfer descriptor
+ * @param	pDMA	: The base of DMA controller on the chip
+ * @param	ch		: DMA channel ID
+ * @param	desc	: Pointer to DMA transfer descriptor
+ * @return	false if the DMA channel was active, otherwise true
+ * @note	This function will set the DMA descriptor in the SRAM table to the
+ *			the passed descriptor. This function is only meant to be used when
+ *			the DMA channel is not active and can be used to setup the
+ *			initial transfer for a linked list or ping-pong buffer or just a
+ *			single transfer without a next descriptor.<br>
+ *
+ *			If using this function to write the initial transfer descriptor in
+ *			a linked list or ping-pong buffer configuration, it should contain a
+ *			non-NULL 'next' field pointer.
+ */
+bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, DMA_CHDESC_T *desc);
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __DMA_5410X_H */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/error.h ./chip/inc/error.h
--- a_tnusFF/chip/inc/error.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/error.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,272 @@
+/*
+ * @brief Error code returned by Boot ROM drivers/library functions
+ *
+ *  This file contains unified error codes to be used across driver,
+ *  middleware, applications, hal and demo software.
+ *
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_ERROR_H__
+#define __LPC_ERROR_H__
+
+/** Error code returned by Boot ROM drivers/library functions
+ *
+ *  Error codes are a 32-bit value with :
+ *      - The 16 MSB contains the peripheral code number
+ *      - The 16 LSB contains an error code number associated to that peripheral
+ *
+ */
+typedef enum {
+	/**\b 0x00000000*/ LPC_OK = 0,	/**< enum value returned on Success */
+	/**\b 0xFFFFFFFF*/ ERR_FAILED = -1,	/**< enum value returned on general failure */
+	/**\b 0xFFFFFFFE*/ ERR_TIME_OUT = -2,	/**< enum value returned on general timeout */
+	/**\b 0xFFFFFFFD*/ ERR_BUSY = -3,	/**< enum value returned when resource is busy */
+
+	/* ISP related errors */
+	ERR_ISP_BASE = 0x00000000,
+	/*0x00000001*/ ERR_ISP_INVALID_COMMAND = ERR_ISP_BASE + 1,
+	/*0x00000002*/ ERR_ISP_SRC_ADDR_ERROR,	/* Source address not on word boundary */
+	/*0x00000003*/ ERR_ISP_DST_ADDR_ERROR,	/* Destination address not on word or 256 byte boundary */
+	/*0x00000004*/ ERR_ISP_SRC_ADDR_NOT_MAPPED,
+	/*0x00000005*/ ERR_ISP_DST_ADDR_NOT_MAPPED,
+	/*0x00000006*/ ERR_ISP_COUNT_ERROR,	/* Byte count is not multiple of 4 or is not a permitted value */
+	/*0x00000007*/ ERR_ISP_INVALID_SECTOR,
+	/*0x00000008*/ ERR_ISP_SECTOR_NOT_BLANK,
+	/*0x00000009*/ ERR_ISP_SECTOR_NOT_PREPARED_FOR_WRITE_OPERATION,
+	/*0x0000000A*/ ERR_ISP_COMPARE_ERROR,
+	/*0x0000000B*/ ERR_ISP_BUSY,/* Flash programming hardware interface is busy */
+	/*0x0000000C*/ ERR_ISP_PARAM_ERROR,	/* Insufficient number of parameters */
+	/*0x0000000D*/ ERR_ISP_ADDR_ERROR,	/* Address not on word boundary */
+	/*0x0000000E*/ ERR_ISP_ADDR_NOT_MAPPED,
+	/*0x0000000F*/ ERR_ISP_CMD_LOCKED,	/* Command is locked */
+	/*0x00000010*/ ERR_ISP_INVALID_CODE,/* Unlock code is invalid */
+	/*0x00000011*/ ERR_ISP_INVALID_BAUD_RATE,
+	/*0x00000012*/ ERR_ISP_INVALID_STOP_BIT,
+	/*0x00000013*/ ERR_ISP_CODE_READ_PROTECTION_ENABLED,
+	/*0x00000014*/ ERR_ISP_INVALID_FLASH_UNIT,
+	/*0x00000015*/ ERR_ISP_USER_CODE_CHECKSUM,
+	/*0x00000016*/ ERR_ISP_SETTING_ACTIVE_PARTITION,
+	/*0x00000017*/ ERR_ISP_IRC_NO_POWER,
+	/*0x00000018*/ ERR_ISP_FLASH_NO_POWER,
+	/*0x00000019*/ ERR_ISP_EEPROM_NO_POWER,
+	/*0x0000001A*/ ERR_ISP_EEPROM_NO_CLOCK,
+	/*0x0000001B*/ ERR_ISP_FLASH_NO_CLOCK,
+	/*0x0000001C*/ ERR_ISP_REINVOKE_ISP_CONFIG,
+
+	/* ROM API related errors */
+	ERR_API_BASE = 0x00010000,
+	/**\b 0x00010001*/ ERR_API_INVALID_PARAMS = ERR_API_BASE + 1,	/**< Invalid parameters*/
+	/**\b 0x00010002*/ ERR_API_INVALID_PARAM1,	/**< PARAM1 is invalid */
+	/**\b 0x00010003*/ ERR_API_INVALID_PARAM2,	/**< PARAM2 is invalid */
+	/**\b 0x00010004*/ ERR_API_INVALID_PARAM3,	/**< PARAM3 is invalid */
+	/**\b 0x00010005*/ ERR_API_MOD_INIT,/**< API is called before module init */
+
+	/* SPIFI API related errors */
+	ERR_SPIFI_BASE = 0x00020000,
+	/*0x00020001*/ ERR_SPIFI_DEVICE_ERROR = ERR_SPIFI_BASE + 1,
+	/*0x00020002*/ ERR_SPIFI_INTERNAL_ERROR,
+	/*0x00020003*/ ERR_SPIFI_TIMEOUT,
+	/*0x00020004*/ ERR_SPIFI_OPERAND_ERROR,
+	/*0x00020005*/ ERR_SPIFI_STATUS_PROBLEM,
+	/*0x00020006*/ ERR_SPIFI_UNKNOWN_EXT,
+	/*0x00020007*/ ERR_SPIFI_UNKNOWN_ID,
+	/*0x00020008*/ ERR_SPIFI_UNKNOWN_TYPE,
+	/*0x00020009*/ ERR_SPIFI_UNKNOWN_MFG,
+	/*0x0002000A*/ ERR_SPIFI_NO_DEVICE,
+	/*0x0002000B*/ ERR_SPIFI_ERASE_NEEDED,
+
+	SEC_AES_NO_ERROR = 0,
+	/* Security API related errors */
+	ERR_SEC_AES_BASE = 0x00030000,
+	/*0x00030001*/ ERR_SEC_AES_WRONG_CMD = ERR_SEC_AES_BASE + 1,
+	/*0x00030002*/ ERR_SEC_AES_NOT_SUPPORTED,
+	/*0x00030003*/ ERR_SEC_AES_KEY_ALREADY_PROGRAMMED,
+	/*0x00030004*/ ERR_SEC_AES_DMA_CHANNEL_CFG,
+	/*0x00030005*/ ERR_SEC_AES_DMA_MUX_CFG,
+	/*0x00030006*/ SEC_AES_DMA_BUSY,
+
+	/* USB device stack related errors */
+	ERR_USBD_BASE = 0x00040000,
+	/**\b 0x00040001*/ ERR_USBD_INVALID_REQ = ERR_USBD_BASE + 1,/**< invalid request */
+	/**\b 0x00040002*/ ERR_USBD_UNHANDLED,	/**< Callback did not process the event */
+	/**\b 0x00040003*/ ERR_USBD_STALL,	/**< Stall the endpoint on which the call back is called */
+	/**\b 0x00040004*/ ERR_USBD_SEND_ZLP,	/**< Send ZLP packet on the endpoint on which the call back is called */
+	/**\b 0x00040005*/ ERR_USBD_SEND_DATA,	/**< Send data packet on the endpoint on which the call back is called */
+	/**\b 0x00040006*/ ERR_USBD_BAD_DESC,	/**< Bad descriptor*/
+	/**\b 0x00040007*/ ERR_USBD_BAD_CFG_DESC,	/**< Bad config descriptor*/
+	/**\b 0x00040008*/ ERR_USBD_BAD_INTF_DESC,	/**< Bad interface descriptor*/
+	/**\b 0x00040009*/ ERR_USBD_BAD_EP_DESC,/**< Bad endpoint descriptor*/
+	/**\b 0x0004000a*/ ERR_USBD_BAD_MEM_BUF,/**< Bad alignment of buffer passed. */
+	/**\b 0x0004000b*/ ERR_USBD_TOO_MANY_CLASS_HDLR,/**< Too many class handlers. */
+
+	/* CGU  related errors */
+	ERR_CGU_BASE = 0x00050000,
+	/*0x00050001*/ ERR_CGU_NOT_IMPL = ERR_CGU_BASE + 1,
+	/*0x00050002*/ ERR_CGU_INVALID_PARAM,
+	/*0x00050003*/ ERR_CGU_INVALID_SLICE,
+	/*0x00050004*/ ERR_CGU_OUTPUT_GEN,
+	/*0x00050005*/ ERR_CGU_DIV_SRC,
+	/*0x00050006*/ ERR_CGU_DIV_VAL,
+	/*0x00050007*/ ERR_CGU_SRC,
+
+	/*  I2C related errors   */
+	ERR_I2C_BASE = 0x00060000,
+	/*0x00060000*/ ERR_I2C_BUSY = ERR_I2C_BASE,
+	/*0x00060001*/ ERR_I2C_NAK,
+	/*0x00060002*/ ERR_I2C_BUFFER_OVERFLOW,
+	/*0x00060003*/ ERR_I2C_BYTE_COUNT_ERR,
+	/*0x00060004*/ ERR_I2C_LOSS_OF_ARBRITRATION,
+	/*0x00060005*/ ERR_I2C_SLAVE_NOT_ADDRESSED,
+	/*0x00060006*/ ERR_I2C_LOSS_OF_ARBRITRATION_NAK_BIT,
+	/*0x00060007*/ ERR_I2C_GENERAL_FAILURE,
+	/*0x00060008*/ ERR_I2C_REGS_SET_TO_DEFAULT,
+	/*0x00060009*/ ERR_I2C_TIMEOUT,
+	/*0x0006000A*/ ERR_I2C_BUFFER_UNDERFLOW,
+	/*0x0006000B*/ ERR_I2C_PARAM,
+
+	/* OTP  related errors */
+	ERR_OTP_BASE = 0x00070000,
+	/*0x00070001*/ ERR_OTP_WR_ENABLE_INVALID = ERR_OTP_BASE + 1,
+	/*0x00070002*/ ERR_OTP_SOME_BITS_ALREADY_PROGRAMMED,
+	/*0x00070003*/ ERR_OTP_ALL_DATA_OR_MASK_ZERO,
+	/*0x00070004*/ ERR_OTP_WRITE_ACCESS_LOCKED,
+	/*0x00070005*/ ERR_OTP_READ_DATA_MISMATCH,
+	/*0x00070006*/ ERR_OTP_USB_ID_ENABLED,
+	/*0x00070007*/ ERR_OTP_ETH_MAC_ENABLED,
+	/*0x00070008*/ ERR_OTP_AES_KEYS_ENABLED,
+	/*0x00070009*/ ERR_OTP_ILLEGAL_BANK,
+
+	/*  UART related errors   */
+	ERR_UART_BASE = 0x00080000,
+	/*0x00080001*/ ERR_UART_RXD_BUSY = ERR_UART_BASE + 1,	// UART rxd is busy
+	/*0x00080002*/ ERR_UART_TXD_BUSY,	// UART txd is busy
+	/*0x00080003*/ ERR_UART_OVERRUN_FRAME_PARITY_NOISE,	// overrun err, frame err, parity err, RxNoise err
+	/*0x00080004*/ ERR_UART_UNDERRUN,	// underrun err
+	/*0x00080005*/ ERR_UART_PARAM,		// parameter is error
+	/*0x00080006*/ ERR_UART_BAUDRATE,	// baudrate setting is error
+
+	/*  CAN related errors   */
+	ERR_CAN_BASE = 0x00090000,
+	/*0x00090001*/ ERR_CAN_BAD_MEM_BUF = ERR_CAN_BASE + 1,
+	/*0x00090002*/ ERR_CAN_INIT_FAIL,
+	/*0x00090003*/ ERR_CANOPEN_INIT_FAIL,
+
+	/* SPIFI Lite API related errors */
+	ERR_SPIFI_LITE_BASE = 0x000A0000,
+	/*0x000A0001*/ ERR_SPIFI_LITE_INVALID_ARGUMENTS = ERR_SPIFI_LITE_BASE + 1,
+	/*0x000A0002*/ ERR_SPIFI_LITE_BUSY,
+	/*0x000A0003*/ ERR_SPIFI_LITE_MEMORY_MODE_ON,
+	/*0x000A0004*/ ERR_SPIFI_LITE_MEMORY_MODE_OFF,
+	/*0x000A0005*/ ERR_SPIFI_LITE_IN_DMA,
+	/*0x000A0006*/ ERR_SPIFI_LITE_NOT_IN_DMA,
+	/*0x000A0100*/ PENDING_SPIFI_LITE,
+
+	/* CLK related errors */
+	ERR_CLK_BASE = 0x000B0000,
+	/*0x000B0001*/ ERR_CLK_NOT_IMPL = ERR_CLK_BASE + 1,
+	/*0x000B0002*/ ERR_CLK_INVALID_PARAM,
+	/*0x000B0003*/ ERR_CLK_INVALID_SLICE,
+	/*0x000B0004*/ ERR_CLK_OUTPUT_GEN,
+	/*0x000B0005*/ ERR_CLK_DIV_SRC,
+	/*0x000B0006*/ ERR_CLK_DIV_VAL,
+	/*0x000B0007*/ ERR_CLK_SRC,
+	/*0x000B0008*/ ERR_CLK_PLL_FIN_TOO_SMALL,
+	/*0x000B0009*/ ERR_CLK_PLL_FIN_TOO_LARGE,
+	/*0x000B000A*/ ERR_CLK_PLL_FOUT_TOO_SMALL,
+	/*0x000B000B*/ ERR_CLK_PLL_FOUT_TOO_LARGE,
+	/*0x000B000C*/ ERR_CLK_PLL_NO_SOLUTION,
+	/*0x000B000D*/ ERR_CLK_PLL_MIN_PCT,
+	/*0x000B000E*/ ERR_CLK_PLL_MAX_PCT,
+	/*0x000B000F*/ ERR_CLK_OSC_FREQ,
+	/*0x000B0010*/ ERR_CLK_CFG,
+	/*0x000B0011*/ ERR_CLK_TIMEOUT,
+	/*0x000B0012*/ ERR_CLK_BASE_OFF,
+	/*0x000B0013*/ ERR_CLK_OFF_DEADLOCK,
+
+	/*Power API*/
+	ERR_PWR_BASE = 0x000C0000,
+	/*0x000C0001*/ PWR_ERROR_ILLEGAL_MODE = ERR_PWR_BASE + 1,
+	/*0x000C0002*/ PWR_ERROR_CLOCK_FREQ_TOO_HIGH,
+	/*0x000C0003*/ PWR_ERROR_INVALID_STATE,
+	/*0x000C0004*/ PWR_ERROR_INVALID_CFG,
+	/*0x000C0005*/ PWR_ERROR_PVT_DETECT,
+	/*0x000C0006*/ PWR_ERROR_INVALID_VOLTAGE,
+
+	/* DMA related errors */
+	ERR_DMA_BASE = 0x000D0000,
+	/*0x000D0001*/ ERR_DMA_ERROR_INT = ERR_DMA_BASE + 1,
+	/*0x000D0002*/ ERR_DMA_CHANNEL_NUMBER,
+	/*0x000D0003*/ ERR_DMA_CHANNEL_DISABLED,
+	/*0x000D0004*/ ERR_DMA_BUSY,
+	/*0x000D0005*/ ERR_DMA_NOT_ALIGNMENT,
+	/*0x000D0006*/ ERR_DMA_PING_PONG_EN,
+	/*0x000D0007*/ ERR_DMA_CHANNEL_VALID_PENDING,
+	/*0x000D0008*/ ERR_DMA_PARAM,
+	/*0x000D0009*/ ERR_DMA_QUEUE_EMPTY,
+	/*0x000D000A*/ ERR_DMA_GENERAL,
+
+	/* SPI related errors */
+	ERR_SPI_BASE = 0x000E0000,
+	/*0x000E0000*/ ERR_SPI_BUSY = ERR_SPI_BASE,
+	/*0x000E0001*/ ERR_SPI_RXOVERRUN,
+	/*0x000E0002*/ ERR_SPI_TXUNDERRUN,
+	/*0x000E0003*/ ERR_SPI_SELNASSERT,
+	/*0x000E0004*/ ERR_SPI_SELNDEASSERT,
+	/*0x000E0005*/ ERR_SPI_CLKSTALL,
+	/*0x000E0006*/ ERR_SPI_PARAM,
+	/*0x000E0007*/ ERR_SPI_INVALID_LENGTH,
+
+	/* ADC related errors */
+	ERR_ADC_BASE = 0x000F0000,
+	/*0x000F0001*/ ERR_ADC_OVERRUN = ERR_ADC_BASE + 1,
+	/*0x000F0002*/ ERR_ADC_INVALID_CHANNEL,
+	/*0x000F0003*/ ERR_ADC_INVALID_SEQUENCE,
+	/*0x000F0004*/ ERR_ADC_INVALID_SETUP,
+	/*0x000F0005*/ ERR_ADC_PARAM,
+	/*0x000F0006*/ ERR_ADC_INVALID_LENGTH,
+	/*0x000F0007*/ ERR_ADC_NO_POWER,
+
+	/* Debugger Mailbox related errors */
+	ERR_DM_BASE = 0x00100000,
+	/*0x00100001*/ ERR_DM_NOT_ENTERED = ERR_DM_BASE + 1,
+	/*0x00100002*/ ERR_DM_UNKNOWN_CMD,
+	/*0x00100003*/ ERR_DM_COMM_FAIL
+
+} ErrorCode_t;
+
+#ifndef offsetof
+#define offsetof(s, m)   (int) &(((s *) 0)->m)
+#endif
+
+#define COMPILE_TIME_ASSERT(pred)    switch (0) { \
+	case 0:	\
+	case pred:; }
+
+#endif /* __LPC_ERROR_H__ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/fifo_5410x.h ./chip/inc/fifo_5410x.h
--- a_tnusFF/chip/inc/fifo_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/fifo_5410x.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,559 @@
+/*
+ * @brief LPC5410X System FIFO chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FIFO_5410X_H_
+#define __FIFO_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup FIFO_5410X CHIP: LPC5410X System FIFO chip driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * This driver provides basic functionality for the system FIFO
+ * and can be used to increase the amount of FIFO space available
+ * to the UART and SPI peripherals. If using the system FIFO with the
+ * UART or SPI drivers, the standard UART and SPI transfer handlers
+ * cannot be used and buffer/stream management and status checking
+ * must occur in the user application.
+ * @{
+ */
+
+/** Maximum USART peripherals */
+#define LPC_FIFO_USART_MAX      (4)
+
+/** Maximum SPI peripherals */
+#define LPC_FIFO_SPI_MAX        (2)
+
+/**
+ * @brief LPC5410X System FIFO USART register block structure
+ */
+typedef struct {
+	__IO uint32_t CFG;			/*!< USART configuration Register */
+	__IO uint32_t STAT;			/*!< USART status Register */
+	__IO uint32_t INTSTAT;		/*!< USART interrupt status Register */
+	__IO uint32_t CTLSET;		/*!< USART control read and set Register */
+	__IO uint32_t CTLCLR;		/*!< USART control clear Register */
+	__IO uint32_t RXDAT;		/*!< USART received data Register */
+	__IO uint32_t RXDATSTAT;	/*!< USART received data with status Register */
+	__IO uint32_t TXDAT;		/*!< USART transmit data Register */
+	__I uint32_t  RESERVED[0x38];
+} LPC_FIFO_USART_T;
+
+/**
+ * @brief LPC5410X System FIFO SPI register block structure
+ */
+typedef struct {
+	__IO uint32_t CFG;			/*!< SPI configuration Register */
+	__IO uint32_t STAT;			/*!< SPI status Register */
+	__IO uint32_t INTSTAT;		/*!< SPI interrupt status Register */
+	__IO uint32_t CTLSET;		/*!< SPI control read and set Register */
+	__IO uint32_t CTLCLR;		/*!< SPI control clear Register */
+	__I  uint32_t RXDAT;		/*!< SPI received data Register */
+	union {
+		__O uint32_t TXDATSPI;	/*!< SPI transmit data and control Register */
+		struct {
+			__O uint16_t TXDATSPI_DATA;	/*!< SPI transmit data Register */
+			__O uint16_t TXDATSPI_CTRL;	/*!< SPI transmit control Register */
+		};
+
+	};
+
+	__I  uint32_t RESERVED[0x39];
+} LPC_FIFO_SPI_T;
+
+/**
+ * @brief LPC5410X System FIFO common register block structure
+ */
+typedef struct {
+	__I  uint32_t reserved0[0x40];
+	__IO uint32_t FIFOCTLUSART;			/*!< USART FIFO global control Register */
+	__O  uint32_t FIFOUPDATEUSART;		/*!< USART FIFO global update Register */
+	__I  uint32_t reserved1[0x2];
+	__IO uint32_t FIFOCFGUSART[LPC_FIFO_USART_MAX];	/*!< USART FIFO configuration Registers */
+	__I  uint32_t reserved2[0x38];
+	__IO uint32_t FIFOCTLSPI;			/*!< SPI FIFO global control Register */
+	__O  uint32_t FIFOUPDATESPI;		/*!< SPI FIFO global update Register */
+	__I  uint32_t reserved3[0x2];
+	__IO uint32_t FIFOCFGSPI[LPC_FIFO_SPI_MAX];		/*!< SPI FIFO configuration Registers */
+	__I  uint32_t reserved4[0x3A];
+	__I  uint32_t reserved5[((0x1000 - 0x300) / sizeof(uint32_t))];
+} LPC_FIFO_CMN_T;
+
+/**
+ * @brief LPC5410X Complete system FIFO register block structure
+ */
+typedef struct {
+	LPC_FIFO_CMN_T      common;
+	LPC_FIFO_USART_T    usart[LPC_FIFO_USART_MAX];
+	__I uint32_t        reserved0[((0x2000 - 0x1400) / sizeof(uint32_t))];
+	LPC_FIFO_SPI_T      spi[LPC_FIFO_SPI_MAX];
+} LPC_FIFO_T;
+
+/** @defgroup FIFO_CMN_5410X CHIP: Common FIFO functions
+ * These functions are for both the USART and SPI configuration and
+ * status.
+ * @{
+ */
+
+/**
+ * @brief	Initializes the system FIFO
+ * @brief	pFIFO	: Pointer to system FIFO registers
+ * @return	Nothing
+ */
+void Chip_FIFO_Init(LPC_FIFO_T *pFIFO);
+
+/**
+ * @brief	Deinitializes the system FIFO
+ * @brief	pFIFO	: Pointer to system FIFO registers
+ * @return	Nothing
+ */
+void Chip_FIFO_Deinit(LPC_FIFO_T *pFIFO);
+
+/** USART/SPI peripheral identifier */
+typedef enum {FIFO_USART, FIFO_SPI} LPC_FIFO_PERIPHID_T;
+
+/** USART/SPI FIFO direction identifier */
+typedef enum {FIFO_RX, FIFO_TX} LPC_FIFO_DIR_T;
+
+/**
+ * @brief	Get the FIFO space available for the USART/SPI direction
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	periphId	: Peripheral identifer
+ * @brief	dir			: FIFO direction
+ * @return	Amount of FIFO space available for the peripheral
+ */
+uint32_t Chip_FIFO_GetFifoSpace(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir);
+
+/** USART and SPI FIFO common statuses */
+#define LPC_FIFO_STAT_RXPAUSED      (1 << 1)		/*!< Receive FIFOs paused status */
+#define LPC_FIFO_STAT_RXEMPTY       (1 << 2)		/*!< Receive FIFOs empty status */
+#define LPC_FIFO_STAT_TXPAUSED      (1 << 9)		/*!< Transmit FIFOs paused status */
+#define LPC_FIFO_STAT_TXEMPTY       (1 << 10)		/*!< Transmit FIFOs empty status */
+
+/**
+ * @brief	Get periperhal FIFO status
+ * @brief	pFIFO	: Pointer to system FIFO registers
+ * @return	A bitfield of status values, mask with LPC_FIFO_STAT_* values
+ * @note	Mask with one or more LPC_FIFO_STAT_* definitions to get the
+ * status of the peripherals.
+ */
+__STATIC_INLINE uint32_t Chip_FIFO_GetFifoStatus(LPC_FIFO_T *pFIFO)
+{
+	return pFIFO->common.FIFOCTLUSART;
+}
+
+/**
+ * @brief	Pause a peripheral FIFO
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	periphId	: Peripheral identifer
+ * @brief	dir			: FIFO direction
+ * @return	Nothing
+ */
+void Chip_FIFO_PauseFifo(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir);
+
+/**
+ * @brief	Unpause a peripheral FIFO
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	periphId	: Peripheral identifer
+ * @brief	dir			: FIFO direction
+ * @return	Nothing
+ */
+void Chip_FIFO_UnpauseFifo(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir);
+
+/** Stucture for setting USART or SPI FIFO sizes */
+typedef struct {
+	uint16_t    fifoRXSize[4];	/*!< FIFO RX size, 0-3 for USARTS 0-3, or 0-1 for SPIS 0-1 */
+	uint16_t    fifoTXSize[4];	/*!< FIFO TX size, 0-3 for USARTS 0-3, or 0-1 for SPIS 0-1 */
+} LPC_FIFO_CFGSIZE_T;
+
+/**
+ * @brief	Configure a peripheral's FIFO sizes
+ * @brief	pFIFO	: Pointer to system FIFO registers
+ * @brief	periphId	: Peripheral identifer
+ * @brief	pSizes	: Pointer to s structure filled out with the peripherla FIFO sizes
+ * @return	Nothing
+ * @note	This function configures all the FIFOs for a supported peripheral
+ * in a single call. Use 0 to disable the FIFO. This function will pause the FIFO
+ * and leave it paused after configuration, call Chip_FIFO_UnpauseFifo() after
+ * calling this function.
+ */
+void Chip_FIFO_ConfigFifoSize(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_CFGSIZE_T *pSizes);
+
+/** Stucture for setting USART and SPI FIFO configuration */
+typedef struct {
+	uint32_t    noTimeoutContWrite  : 1;	/*!< Timeout Continue On Write, set to 0 to reset timeout on each TX FIFO data, or 1 for accumulated timeout */
+	uint32_t    noTimeoutContEmpty  : 1;	/*!< Timeout Continue On Empty., set to 0 to reset timeout on each RX FIFO data, or 1 for accumulated timeout */
+	uint32_t    timeoutBase         : 4;	/*!< Specifies the least significant timer bit to compare to TimeoutValue. See User Manual */
+	uint32_t    timeoutValue        : 4;	/*!< Specifies the maximum time value for timeout at the timer position identified by TimeoutBase. See User Manual */
+	uint32_t    rxThreshold         : 8;	/*!< Receive FIFO Threshold, number of data to receive prior to interrupt */
+	uint32_t    txThreshold         : 8;	/*!< Transmit FIFO Threshold, number of free TX data entries available prior to interrupt */
+} LPC_FIFO_CFG_T;
+
+/** USART and SPI FIFO statuses */
+#define LPC_PERIPFIFO_STAT_RXTH         (1 << 0)		/*!< When 1, the receive FIFO threshold has been reached */
+#define LPC_PERIPFIFO_STAT_TXTH         (1 << 1)		/*!< When 1, the transmit FIFO threshold has been reached */
+#define LPC_PERIPFIFO_STATCLR_RXTIMEOUT (1 << 4)		/*!< When 1, the receive FIFO has timed out, based on the timeout configuration in the CFG register */
+#define LPC_PERIPFIFO_STATCLR_BUSERR    (1 << 7)		/*!< Bus Error. When 1, a bus error has occurred while processing data for the peripheral. The bus error flag can be cleared by writing a 1 to this bit. */
+#define LPC_PERIPFIFO_STAT_RXEMPTY      (1 << 8)		/*!< Receive FIFO Empty. When 1, the receive FIFO is currently empty. */
+#define LPC_PERIPFIFO_STAT_TXEMPTY      (1 << 9)		/*!< Transmit FIFO Empty. When 1, the transmit FIFO is currently empty. */
+
+/** USART interrupt enable/disable bits */
+#define LPC_PERIPFIFO_INT_RXTH          (1 << 0)		/*!< Receive FIFO Threshold Interrupt Enable */
+#define LPC_PERIPFIFO_INT_TXTH          (1 << 1)		/*!< Transmit FIFO Threshold Interrupt Enable */
+#define LPC_PERIPFIFO_INT_RXTIMEOUT     (1 << 4)		/*!< Receive FIFO Timeout Interrupt Enable */
+#define LPC_PERIPFIFO_INT_RXFLUSH       (1 << 8)		/*!< Receive FIFO flush */
+#define LPC_PERIPFIFO_INT_TXFLUSH       (1 << 9)		/*!< Transmit FIFO flush */
+
+/**
+ * @}
+ */
+
+/** @defgroup FIFO_USART_5410X CHIP: USART FIFO functions
+ * These functions are for both the USART configuration, control, and status.
+ * @{
+ */
+
+/**
+ * @brief	Configure the USART system FIFO
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	pUSARTCfg	: Pointer to USART configuration
+ * @return	Nothing
+ */
+void Chip_FIFOUSART_Configure(LPC_FIFO_T *pFIFO, int usartIndex, LPC_FIFO_CFG_T *pUSARTCfg);
+
+/**
+ * @brief	Get USART FIFO statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @return	USART system FIFO statuses (mask with LPC_PERIPFIFO_STAT* values)
+ */
+__STATIC_INLINE uint32_t Chip_FIFOUSART_GetStatus(LPC_FIFO_T *pFIFO, int usartIndex)
+{
+	return pFIFO->usart[usartIndex].STAT;
+}
+
+/**
+ * @brief	Get USART RX FIFO count
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @return	Returns how many entries may be read from the receive FIFO. 0 = FIFO empty.
+ */
+__STATIC_INLINE uint32_t Chip_FIFOUSART_GetRxCount(LPC_FIFO_T *pFIFO, int usartIndex)
+{
+	return (pFIFO->usart[usartIndex].STAT >> 16) & 0xFF;
+}
+
+/**
+ * @brief	Get USART TC FIFO count
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @return	Returns how many entries may be written to the transmit FIFO. 0 = FIFO full.
+ */
+__STATIC_INLINE uint32_t Chip_FIFOUSART_GetTxCount(LPC_FIFO_T *pFIFO, int usartIndex)
+{
+	return (pFIFO->usart[usartIndex].STAT >> 24) & 0xFF;
+}
+
+/**
+ * @brief	Clear USART FIFO statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	clearMask	: Mask of latched bits to cleared, Or'ed values of LPC_PERIPFIFO_STATCLR*
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOUSART_ClearStatus(LPC_FIFO_T *pFIFO, int usartIndex, uint32_t clearMask)
+{
+	pFIFO->usart[usartIndex].STAT = clearMask;
+}
+
+/**
+ * @brief	Get USART FIFO pending interrupt statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @return	USART system FIFO pending interrupt statuses (mask with LPC_PERIPFIFO_STAT* values)
+ */
+__STATIC_INLINE uint32_t Chip_FIFOUSART_GetIntStatus(LPC_FIFO_T *pFIFO, int usartIndex)
+{
+	return pFIFO->usart[usartIndex].INTSTAT;
+}
+
+/**
+ * @brief	Enable USART system FIFO interrupts
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	intMask		: Interrupts to enable (LPC_PERIPFIFO_INT_RXTH, LPC_PERIPFIFO_INT_TXTH, or LPC_PERIPFIFO_INT_RXTIMEOUT)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOUSART_EnableInts(LPC_FIFO_T *pFIFO, int usartIndex, uint32_t intMask)
+{
+	pFIFO->usart[usartIndex].CTLSET = intMask;
+}
+
+/**
+ * @brief	Disable USART system FIFO interrupts
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	intMask		: Interrupts to disable (LPC_PERIPFIFO_INT_RXTH, LPC_PERIPFIFO_INT_TXTH, or LPC_PERIPFIFO_INT_RXTIMEOUT)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOUSART_DisableInts(LPC_FIFO_T *pFIFO, int usartIndex, uint32_t intMask)
+{
+	pFIFO->usart[usartIndex].CTLCLR = intMask;
+}
+
+/**
+ * @brief	Flush TX and/or RX USART system FIFOs
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	flushMask	: FIFOS to flush (Or'ed LPC_PERIPFIFO_INT_RXFLUSH and/or LPC_PERIPFIFO_INT_TXFLUSH)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOUSART_FlushFIFO(LPC_FIFO_T *pFIFO, int usartIndex, uint32_t flushMask)
+{
+	flushMask = flushMask & (LPC_PERIPFIFO_INT_RXFLUSH | LPC_PERIPFIFO_INT_TXFLUSH);
+
+	pFIFO->usart[usartIndex].CTLSET = flushMask;
+	pFIFO->usart[usartIndex].CTLCLR = flushMask;
+}
+
+/**
+ * @brief	Write data to a USART system FIFO (non-blocking)
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	sz8			: Set to true for 8-bit or less data, or false for >8-bit
+ * @brief	buff		: Pointer to data in buffer to write
+ * @brief	numData		: Maximum number of data values to write
+ * @return	The number of data values written to the USART system FIFO
+ */
+int Chip_FIFOUSART_WriteTX(LPC_FIFO_T *pFIFO, int usartIndex, bool sz8, void *buff, int numData);
+
+/**
+ * @brief	Read data from a USART system FIFO (non-blocking)
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	sz8			: Set to true for 8-bit or less data, or false for >8-bit
+ * @brief	buff		: Pointer to data buffer to read into
+ * @brief	numData		: Maximum number of data values to read
+ * @return	The number of data values read from the USART system FIFO
+ */
+int Chip_FIFOUSART_ReadRX(LPC_FIFO_T *pFIFO, int usartIndex, bool sz8, void *buff, int numData);
+
+/** USART FIFO read FIFO statuses */
+#define LPC_USARTRXFIFO_STAT_FRAMERR    (1 << 13)		/*!< Framing Error status flag */
+#define LPC_USARTRXFIFO_STAT_PARITYERR  (1 << 14)		/*!< Parity Error status flag */
+#define LPC_USARTRXFIFO_STAT_RXNOISE    (1 << 15)		/*!< Received Noise flag */
+
+/**
+ * @brief	Read data from a USART system FIFO with status (non-blocking)
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	usartIndex	: USART system FIFO index, 0 - 3
+ * @brief	buff		: Pointer to data buffer to read into
+ * @brief	numData		: Maximum number of data values to read
+ * @return	The number of data values with status read from the USART system FIFO. Mask
+ * the upper bits of each word in the buffer with the LPC_USARTRXFIFO_STAT_* flags to
+ * determine individual data status.
+ */
+int Chip_FIFOUSART_ReadRXStatus(LPC_FIFO_T *pFIFO, int usartIndex, uint16_t *buff, int numData);
+
+/**
+ * @}
+ */
+
+/** @defgroup FIFO_SPI_5410X CHIP: SPI FIFO functions
+ * These functions are for both the SPI configuration, control, and status.
+ * @{
+ */
+
+/**
+ * @brief	Configure the SPI system FIFO
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @brief	pUSARTCfg	: Pointer to SPI configuration
+ * @return	Nothing
+ */
+void Chip_FIFOSPI_Configure(LPC_FIFO_T *pFIFO, int spiIndex, LPC_FIFO_CFG_T *pSPICfg);
+
+/**
+ * @brief	Get SPI FIFO statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @return	SPI system FIFO statuses (mask with LPC_PERIPFIFO_STAT* values)
+ */
+__STATIC_INLINE uint32_t Chip_FIFOSPI_GetStatus(LPC_FIFO_T *pFIFO, int spiIndex)
+{
+	return pFIFO->spi[spiIndex].STAT;
+}
+
+/**
+ * @brief	Get SPI RX FIFO count
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @return	Returns how many entries may be read from the receive FIFO. 0 = FIFO empty.
+ */
+__STATIC_INLINE uint32_t Chip_FIFOSPI_GetRxCount(LPC_FIFO_T *pFIFO, int spiIndex)
+{
+	return (pFIFO->spi[spiIndex].STAT >> 16) & 0xFF;
+}
+
+/**
+ * @brief	Get SPI TX FIFO count
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @return	Returns how many entries may be written to the transmit FIFO. 0 = FIFO full.
+ */
+__STATIC_INLINE uint32_t Chip_FIFOSPI_GetTxCount(LPC_FIFO_T *pFIFO, int spiIndex)
+{
+	return (pFIFO->spi[spiIndex].STAT >> 24) & 0xFF;
+}
+
+/**
+ * @brief	Clear SPI FIFO statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @brief	clearMask	: Mask of latched bits to cleared, Or'ed values of LPC_PERIPFIFO_STATCLR*
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOSPI_ClearStatus(LPC_FIFO_T *pFIFO, int spiIndex, uint32_t clearMask)
+{
+	pFIFO->spi[spiIndex].STAT = clearMask;
+}
+
+/**
+ * @brief	Get SPI FIFO pending interrupt statuses
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @return	SPI system FIFO pending interrupt statuses (mask with LPC_PERIPFIFO_STAT* values)
+ */
+__STATIC_INLINE uint32_t Chip_FIFOSPI_GetIntStatus(LPC_FIFO_T *pFIFO, int spiIndex)
+{
+	return pFIFO->spi[spiIndex].INTSTAT;
+}
+
+/**
+ * @brief	Enable SPI system FIFO interrupts
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @brief	intMask		: Interrupts to enable (LPC_PERIPFIFO_INT_RXTH, LPC_PERIPFIFO_INT_TXTH, or LPC_PERIPFIFO_INT_RXTIMEOUT)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOSPI_EnableInts(LPC_FIFO_T *pFIFO, int spiIndex, uint32_t intMask)
+{
+	pFIFO->spi[spiIndex].CTLSET = intMask;
+}
+
+/**
+ * @brief	Disable SPI system FIFO interrupts
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @brief	intMask		: Interrupts to disable (LPC_PERIPFIFO_INT_RXTH, LPC_PERIPFIFO_INT_TXTH, or LPC_PERIPFIFO_INT_RXTIMEOUT)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOSPI_DisableInts(LPC_FIFO_T *pFIFO, int spiIndex, uint32_t intMask)
+{
+	pFIFO->spi[spiIndex].CTLCLR = intMask;
+}
+
+/**
+ * @brief	Flush TX and/or RX SPI system FIFOs
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	spiIndex	: SPI system FIFO index, 0 - 1
+ * @brief	flushMask	: FIFOS to flush (Or'ed LPC_PERIPFIFO_INT_RXFLUSH and/or LPC_PERIPFIFO_INT_TXFLUSH)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_FIFOSPI_FlushFIFO(LPC_FIFO_T *pFIFO, int spiIndex, uint32_t flushMask)
+{
+	flushMask = flushMask & (LPC_PERIPFIFO_INT_RXFLUSH | LPC_PERIPFIFO_INT_TXFLUSH);
+
+	pFIFO->spi[spiIndex].CTLSET = flushMask;
+	pFIFO->spi[spiIndex].CTLCLR = flushMask;
+}
+
+/** SPI transfer flags */
+#define LPC_SPIFIFO_FLAG_EOF            (1 << 21)		/*!< Add a delay between frames */
+#define LPC_SPIFIFO_FLAG_RXIGNORE       (1 << 22)		/*!< Ignore RX data */
+
+/** SPI transfer error statuses */
+#define LPC_SPIFIFO_STAT_BUSY           (0x0)		/*!< SPI transfer busy/in progress */
+#define LPC_SPIFIFO_STAT_BADPARAM       (0x1)		/*!< SPI paramaters for transfer are invalid */
+#define LPC_SPIFIFO_STAT_TXUNDERRUN     (0x2)		/*!< Slave mode only, transmit FIFO underrun */
+#define LPC_SPIFIFO_STAT_RXOVERRUN      (0x3)		/*!< Slave mode only, receive FIFO overrun */
+#define LPC_SPIFIFO_STAT_COMPLETE       (0xF)		/*!< SPI transfer completed successfully */
+
+#if 0	/* Sorry, not yet support */
+/** Stucture for SPI control */
+typedef struct {
+	uint32_t    start   : 1;		/*!< Indicates transfer start, 0 = transfer resume, 1 = transfer start (automatically set by Chip_FIFOSPI_StartTransfer()) */
+	uint32_t    end     : 1;		/*!< Transfer wil end once buffers are empty */
+	uint32_t    sz8     : 1;		/*!< Specifies the in and out buffer sizes, 0 = 16-bit, 1 = 8-bit */
+	uint32_t    sselNum : 2;		/*!< SPI chip select number, 0 - 3 */
+	void        *inBuff;			/*!< SPI transfer in data buffer pointer */
+	uint32_t    inIndex;			/*!< SPI transfer in buffer index */
+	void        *outBuff;			/*!< SPI transfer out data buffer pointer */
+	uint32_t    outIndex;			/*!< SPI transfer out buffer index */
+	uint32_t    numData;			/*!< Size of data both the receive and transfer buffers */
+	int         spiIndex;			/*!< SPI system FIFO index, 0 - 1 */
+} LPC_FIFO_SPICTL_T;
+
+/**
+ * @brief	Start a SPI data transfer (non-blocking)
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	pSetupData	: Pointer to SPI transfer setup structure
+ * @return	Nothing
+ * @note	Simply calls Chip_FIFOSPI_Transfer() with pSetupData->start = 1.
+ */
+void Chip_FIFOSPI_StartTransfer(LPC_FIFO_T *pFIFO, LPC_FIFO_SPICTL_T *pSetupData);
+
+/**
+ * @brief	Feed a SPI data transfer (non-blocking)
+ * @brief	pFIFO		: Pointer to system FIFO registers
+ * @brief	pSetupData	: Pointer to SPI transfer setup structure
+ * @return	Nothing
+ * @note	Continues SPI transfer usng the system FIFO.
+ */
+void Chip_FIFOSPI_Transfer(LPC_FIFO_T *pFIFO, LPC_FIFO_SPICTL_T *pSetupData);
+
+#endif
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __FIFO_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/fpu_init.h ./chip/inc/fpu_init.h
--- a_tnusFF/chip/inc/fpu_init.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/fpu_init.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,52 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __FPU_INIT_H_
+#define __FPU_INIT_H_
+
+/**
+ * @defgroup CHIP_FPU_CMX CHIP: FPU initialization
+ * @ingroup CHIP_Common
+ * Cortex FPU initialization
+ * @{
+ */
+
+/**
+ * @brief	Early initialization of the FPU
+ * @return	Nothing
+ */
+void fpuInit(void);
+
+/**
+ * @}
+ */
+
+#endif /* __FPU_INIT_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/gpio_5410x.h ./chip/inc/gpio_5410x.h
--- a_tnusFF/chip/inc/gpio_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/gpio_5410x.h	2016-10-22 23:17:43.552840278 -0300
@@ -0,0 +1,471 @@
+/*
+ * @brief LPC5410X GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIO_5410X_H_
+#define __GPIO_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIO_5410X CHIP: LPC5410X GPIO driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief  GPIO port register block structure
+ */
+typedef struct {				/*!< GPIO_PORT Structure */
+	__IO uint8_t B[128][32];	/*!< Offset 0x0000: Byte pin registers ports 0 to n; pins PIOn_0 to PIOn_31 */
+	__IO uint32_t W[32][32];	/*!< Offset 0x1000: Word pin registers port 0 to n */
+	__IO uint32_t DIR[32];		/*!< Offset 0x2000: Direction registers port n */
+	__IO uint32_t MASK[32];		/*!< Offset 0x2080: Mask register port n */
+	__IO uint32_t PIN[32];		/*!< Offset 0x2100: Portpin register port n */
+	__IO uint32_t MPIN[32];		/*!< Offset 0x2180: Masked port register port n */
+	__IO uint32_t SET[32];		/*!< Offset 0x2200: Write: Set register for port n Read: output bits for port n */
+	__O  uint32_t CLR[32];		/*!< Offset 0x2280: Clear port n */
+	__O  uint32_t NOT[32];		/*!< Offset 0x2300: Toggle port n */
+} LPC_GPIO_T;
+
+/**
+ * @brief	Initialize GPIO block
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief	De-Initialize GPIO block
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO);
+
+/**
+ * @brief	Set a GPIO port/pin state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set
+ * @param	setting	: true for high, false for low
+ * @return	Nothing
+ * @note	It is recommended to use the Chip_GPIO_SetPinState() function instead.
+ */
+__STATIC_INLINE void Chip_GPIO_WritePortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
+{
+	pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief	Set a GPIO pin state via the GPIO byte register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set
+ * @param	setting	: true for high, false for low
+ * @return	Nothing
+ * @note	This function replaces Chip_GPIO_WritePortBit()
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool setting)
+{
+	pGPIO->B[port][pin] = setting;
+}
+
+/**
+ * @brief	Read a GPIO pin state via the GPIO byte register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read
+ * @param	pin		: GPIO pin to read
+ * @return	true if the GPIO pin is high, false if low
+ * @note	It is recommended to use the Chip_GPIO_GetPinState() function instead.
+ */
+__STATIC_INLINE bool Chip_GPIO_ReadPortBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin)
+{
+	return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief	Get a GPIO pin state via the GPIO byte register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read
+ * @param	pin		: GPIO pin to get state for
+ * @return	true if the GPIO is high, false if low
+ * @note	This function replaces Chip_GPIO_ReadPortBit()
+ */
+__STATIC_INLINE bool Chip_GPIO_GetPinState(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	return (bool) pGPIO->B[port][pin];
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set
+ * @param	setting	: true for output, false for input
+ * @return	Nothing
+ * @note	It is recommended to use the Chip_GPIO_SetPinDIROutput(),
+ * Chip_GPIO_SetPinDIRInput() or Chip_GPIO_SetPinDIR() functions instead
+ * of this function.
+ */
+void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting);
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin to an output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set direction on as output
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->DIR[port] |= 1UL << pin;
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin to an input
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set direction on as input
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->DIR[port] &= ~(1UL << pin);
+}
+
+/**
+ * @brief	Set GPIO direction for a single GPIO pin
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to set
+ * @param	pin		: GPIO pin to set direction for
+ * @param	output	: true for output, false for input
+ * @return	Nothing
+ */
+void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output);
+
+/**
+ * @brief	Read a GPIO direction (out or in)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read
+ * @param	bit		: GPIO bit direction to read
+ * @return	true if the GPIO is an output, false if input
+ * @note	It is recommended to use the Chip_GPIO_GetPinDIR() function instead.
+ */
+__STATIC_INLINE bool Chip_GPIO_ReadDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t bit)
+{
+	return (bool) (((pGPIO->DIR[port]) >> bit) & 1);
+}
+
+/**
+ * @brief	Get GPIO direction for a single GPIO pin
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: GPIO port to read (supports port 0 only)
+ * @param	pin		: GPIO pin to get direction for
+ * @return	true if the GPIO is an output, false if input
+ */
+__STATIC_INLINE bool Chip_GPIO_GetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	return Chip_GPIO_ReadDirBit(pGPIO, port, pin);
+}
+
+/**
+ * @brief	Set Direction for a GPIO port
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port Number
+ * @param	bitValue	: GPIO bit to set
+ * @param	out			: Direction value, 0 = input, !0 = output
+ * @return	None
+ * @note	Bits set to '0' are not altered. It is recommended to use the
+ * Chip_GPIO_SetPortDIR() function instead.
+ */
+void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out);
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @param	pinMask	: GPIO pin mask to set direction on as output (bits 0..b for pins 0..n)
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the output direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortDIROutput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+	pGPIO->DIR[port] |= pinMask;
+}
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an input
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @param	pinMask	: GPIO pin mask to set direction on as input (bits 0..b for pins 0..n)
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortDIRInput(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask)
+{
+	pGPIO->DIR[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Set GPIO direction for a all selected GPIO pins to an input or output
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @param	pinMask	: GPIO pin mask to set direction on (bits 0..b for pins 0..n)
+ * @param	outSet	: Direction value, false = set as inputs, true = set as outputs
+ * @return	Nothing
+ * @note	Sets multiple GPIO pins to the input direction, each bit's position that is
+ * high sets the corresponding pin number for that bit to an input.
+ */
+void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask, bool outSet);
+
+/**
+ * @brief	Get GPIO direction for a all GPIO pins
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number
+ * @return	a bitfield containing the input and output states for each pin
+ * @note	For pins 0..n, a high state in a bit corresponds to an output state for the
+ * same pin, while a low  state corresponds to an input state.
+ */
+__STATIC_INLINE uint32_t Chip_GPIO_GetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->DIR[port];
+}
+
+/**
+ * @brief	Set GPIO port mask value for GPIO masked read and write
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	mask	: Mask value for read and write
+ * @return	Nothing
+ * @note	Controls which bits corresponding to PIO0_n are active in the P0MPORT
+ * register (bit 0 = PIO0_0, bit 1 = PIO0_1, ..., bit 17 = PIO0_17).
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortMask(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t mask)
+{
+	pGPIO->MASK[port] = mask;
+}
+
+/**
+ * @brief	Get GPIO port mask value used for GPIO masked read and write
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @return	Returns value set with the Chip_GPIO_SetPortMask() function.
+ */
+__STATIC_INLINE uint32_t Chip_GPIO_GetPortMask(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->MASK[port];
+}
+
+/**
+ * @brief	Set all GPIO raw pin states (regardless of masking)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	value	: Value to set all GPIO pin states (0..n) to
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+	pGPIO->PIN[port] = value;
+}
+
+/**
+ * @brief	Get all GPIO raw pin states (regardless of masking)
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @return	Current (raw) state of all GPIO pins
+ */
+__STATIC_INLINE uint32_t Chip_GPIO_GetPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->PIN[port];
+}
+
+/**
+ * @brief	Set all GPIO pin states, but mask via the MASKP0 register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	value	: Value to set all GPIO pin states (0..n) to
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIO_SetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t value)
+{
+	pGPIO->MPIN[port] = value;
+}
+
+/**
+ * @brief	Get all GPIO pin statesm but mask via the MASKP0 register
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @return	Current (masked) state of all GPIO pins
+ */
+__STATIC_INLINE uint32_t Chip_GPIO_GetMaskedPortValue(LPC_GPIO_T *pGPIO, uint8_t port)
+{
+	return pGPIO->MPIN[port];
+}
+
+/**
+ * @brief	Set a GPIO port/bit to the high state
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port number (supports port 0 only)
+ * @param	bitValue	: bit(s) in the port to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output. It is recommended to use the
+ * Chip_GPIO_SetPortOutHigh() function instead.
+ */
+__STATIC_INLINE void Chip_GPIO_SetValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+	pGPIO->SET[portNum] = bitValue;
+}
+
+/**
+ * @brief	Set selected GPIO output pins to the high state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pins	: pins (0..n) to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->SET[port] = pins;
+}
+
+/**
+ * @brief	Set an individual GPIO output pin to the high state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pin		: pin number (0..n) to set high
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinOutHigh(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->SET[port] = (1 << pin);
+}
+
+/**
+ * @brief	Set a GPIO port/bit to the low state
+ * @param	pGPIO		: The base of GPIO peripheral on the chip
+ * @param	portNum		: port number (support port 0 only)
+ * @param	bitValue	: bit(s) in the port to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output. It is recommended to use the
+ * Chip_GPIO_SetPortOutLow() function instead.
+ */
+__STATIC_INLINE void Chip_GPIO_ClearValue(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue)
+{
+	pGPIO->CLR[portNum] = bitValue;
+}
+
+/**
+ * @brief	Set selected GPIO output pins to the low state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pins	: pins (0..n) to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->CLR[port] = pins;
+}
+
+/**
+ * @brief	Set an individual GPIO output pin to the low state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pin		: pin number (0..n) to set low
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinOutLow(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->CLR[port] = (1 << pin);
+}
+
+/**
+ * @brief	Toggle selected GPIO output pins to the opposite state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pins	: pins (0..n) to toggle
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPortToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pins)
+{
+	pGPIO->NOT[port] = pins;
+}
+
+/**
+ * @brief	Toggle an individual GPIO output pin to the opposite state
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	port	: port Number (supports port 0 only)
+ * @param	pin		: pin number (0..n) to toggle
+ * @return	None
+ * @note	Any bit set as a '0' will not have it's state changed. This only
+ * applies to ports configured as an output.
+ */
+__STATIC_INLINE void Chip_GPIO_SetPinToggle(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin)
+{
+	pGPIO->NOT[port] = (1 << pin);
+}
+
+/**
+ * @brief	Read current bit states for the selected port
+ * @param	pGPIO	: The base of GPIO peripheral on the chip
+ * @param	portNum	: port number to read (supports port 0 only)
+ * @return	Current value of GPIO port
+ * @note	The current states of the bits for the port are read, regardless of
+ * whether the GPIO port bits are input or output. It is recommended to use the
+ * Chip_GPIO_GetPortValue() function instead.
+ */
+__STATIC_INLINE uint32_t Chip_GPIO_ReadValue(LPC_GPIO_T *pGPIO, uint8_t portNum)
+{
+	return pGPIO->PIN[portNum];
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIO_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/gpiogroup_5410x.h ./chip/inc/gpiogroup_5410x.h
--- a_tnusFF/chip/inc/gpiogroup_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/gpiogroup_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,223 @@
+/*
+ * @brief LPC5410x GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __GPIOGROUP_5410X_H_
+#define __GPIOGROUP_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup GPIOGP_5410X CHIP: LPC5410X GPIO group driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief GPIO grouped interrupt register block structure
+ */
+typedef struct {					/*!< GPIO_GROUP_INTn Structure */
+	__IO uint32_t  CTRL;			/*!< GPIO grouped interrupt control register */
+	__I  uint32_t  RESERVED0[7];
+	__IO uint32_t  PORT_POL[8];		/*!< GPIO grouped interrupt port polarity register */
+	__IO uint32_t  PORT_ENA[8];		/*!< GPIO grouped interrupt port m enable register */
+	uint32_t       RESERVED1[4072];
+} LPC_GPIOGROUPINT_T;
+
+/**
+ * LPC5410x GPIO group bit definitions
+ */
+#define GPIOGR_INT       (1 << 0)	/*!< GPIO interrupt pending/clear bit */
+#define GPIOGR_COMB      (1 << 1)	/*!< GPIO interrupt OR(0)/AND(1) mode bit */
+#define GPIOGR_TRIG      (1 << 2)	/*!< GPIO interrupt edge(0)/level(1) mode bit */
+
+/**
+ * @brief	Initialize GPIO group interrupt block
+ * @param	pGPIOGPINT	: The base of GPIO group peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIOGP_Init(LPC_GPIOGROUPINT_T *pGPIOGPINT)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GINT);
+	Chip_SYSCON_PeriphReset(RESET_GINT);
+}
+
+/**
+ * @brief	De-Initialize GPIO group interrupt block
+ * @param	pGPIOGPINT	: The base of GPIO group peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_GPIOGP_DeInit(LPC_GPIOGROUPINT_T *pGPIOGPINT)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GINT);
+}
+
+/**
+ * @brief	Clear interrupt pending status for the selected group
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_ClearIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL |= GPIOGR_INT;
+}
+
+/**
+ * @brief	Returns current GPIO group inetrrupt pending status
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	true if the group interrupt is pending, otherwise false.
+ */
+__STATIC_INLINE bool Chip_GPIOGP_GetIntStatus(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	return (bool) ((pGPIOGPINT[group].CTRL & GPIOGR_INT) != 0);
+}
+
+/**
+ * @brief	Selected GPIO group functionality for trigger on any pin in group (OR mode)
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectOrMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL &= ~(GPIOGR_COMB | GPIOGR_INT);
+}
+
+/**
+ * @brief	Selected GPIO group functionality for trigger on all matching pins in group (AND mode)
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectAndMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~GPIOGR_INT) | GPIOGR_COMB;
+}
+
+/**
+ * @brief	Selected GPIO group functionality edge trigger mode
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectEdgeMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL &= ~(GPIOGR_TRIG | GPIOGR_INT);
+}
+
+/**
+ * @brief	Selected GPIO group functionality level trigger mode
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectLevelMode(LPC_GPIOGROUPINT_T *pGPIOGPINT, uint8_t group)
+{
+	pGPIOGPINT[group].CTRL = (pGPIOGPINT[group].CTRL & ~GPIOGR_INT) | GPIOGR_TRIG;
+}
+
+/**
+ * @brief	Set selected pins for the group and port to low level trigger
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to select for low level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectLowLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+												uint8_t group,
+												uint8_t port,
+												uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_POL[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Set selected pins for the group and port to high level trigger
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to select for high level (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ */
+__STATIC_INLINE void Chip_GPIOGP_SelectHighLevel(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+												 uint8_t group,
+												 uint8_t port,
+												 uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_POL[port] |= pinMask;
+}
+
+/**
+ * @brief	Disabled selected pins for the group interrupt
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to disable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ * @note	Disabled pins do not contribute to the group interrupt.
+ */
+__STATIC_INLINE void Chip_GPIOGP_DisableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+												  uint8_t group,
+												  uint8_t port,
+												  uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_ENA[port] &= ~pinMask;
+}
+
+/**
+ * @brief	Enable selected pins for the group interrupt
+ * @param	pGPIOGPINT	: Pointer to GPIO group register block
+ * @param	group		: GPIO group number
+ * @param	port		: GPIO port number
+ * @param	pinMask		: Or'ed value of pins to enable interrupt for (bit 0 = pin 0, 1 = pin1, etc.)
+ * @return	None
+ * @note	Enabled pins contribute to the group interrupt.
+ */
+__STATIC_INLINE void Chip_GPIOGP_EnableGroupPins(LPC_GPIOGROUPINT_T *pGPIOGPINT,
+												 uint8_t group,
+												 uint8_t port,
+												 uint32_t pinMask)
+{
+	pGPIOGPINT[group].PORT_ENA[port] |= pinMask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GPIOGROUP_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/i2c_common_5410x.h ./chip/inc/i2c_common_5410x.h
--- a_tnusFF/chip/inc/i2c_common_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/i2c_common_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,526 @@
+/*
+ * @brief LPC5410x I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2C_COMMON_5410X_H_
+#define __I2C_COMMON_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2C_5410X CHIP: LPC5410x I2C driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief I2C register block structure
+ */
+typedef struct {					/* I2C0 Structure         */
+	__IO uint32_t CFG;				/*!< I2C Configuration Register common for Master, Slave and Monitor */
+	__IO uint32_t STAT;				/*!< I2C Status Register common for Master, Slave and Monitor */
+	__IO uint32_t INTENSET;			/*!< I2C Interrupt Enable Set Register common for Master, Slave and Monitor */
+	__O  uint32_t INTENCLR;			/*!< I2C Interrupt Enable Clear Register common for Master, Slave and Monitor */
+	__IO uint32_t TIMEOUT;			/*!< I2C Timeout value Register */
+	__IO uint32_t CLKDIV;			/*!< I2C Clock Divider Register */
+	__IO uint32_t INTSTAT;			/*!< I2C Interrupt Status Register */
+	__I  uint32_t RESERVED0;
+	__IO uint32_t MSTCTL;			/*!< I2C Master Control Register */
+	__IO uint32_t MSTTIME;			/*!< I2C Master Time Register for SCL */
+	__IO uint32_t MSTDAT;			/*!< I2C Master Data Register */
+	__I  uint32_t RESERVED1[5];
+	__IO uint32_t SLVCTL;			/*!< I2C Slave Control Register */
+	__IO uint32_t SLVDAT;			/*!< I2C Slave Data Register */
+	__IO uint32_t SLVADR[4];		/*!< I2C Slave Address Registers */
+	__IO uint32_t SLVQUAL0;			/*!< I2C Slave Address Qualifier 0 Register */
+	__I  uint32_t RESERVED2[9];
+	__IO uint32_t MONRXDAT;			/*!< I2C Monitor Data Register */
+} LPC_I2C_T;
+
+/*
+ * @brief I2C Configuration register Bit definition
+ */
+#define I2C_CFG_MSTEN             (1 << 0)			/*!< Master Enable/Disable Bit */
+#define I2C_CFG_SLVEN             (1 << 1)			/*!< Slave Enable/Disable Bit */
+#define I2C_CFG_MONEN             (1 << 2)			/*!< Monitor Enable/Disable Bit */
+#define I2C_CFG_TIMEOUTEN         (1 << 3)			/*!< Timeout Enable/Disable Bit */
+#define I2C_CFG_MONCLKSTR         (1 << 4)			/*!< Monitor Clock Stretching Bit */
+#define I2C_CFG_MASK              ((uint32_t) 0x1F)	/*!< Configuration Register Mask */
+
+/*
+ * @brief I2C Status register Bit definition
+ */
+#define I2C_STAT_MSTPENDING       (1 << 0)		/*!< Master Pending Status Bit */
+#define I2C_STAT_MSTSTATE         (0x7 << 1)	/*!< Master State Code */
+#define I2C_STAT_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Bit */
+#define I2C_STAT_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Bit */
+#define I2C_STAT_SLVPENDING       (1 << 8)		/*!< Slave Pending Status Bit */
+#define I2C_STAT_SLVSTATE         (0x3 << 9)	/*!< Slave State Code */
+#define I2C_STAT_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Bit */
+#define I2C_STAT_SLVIDX           (0x3 << 12)	/*!< Slave Address Index */
+#define I2C_STAT_SLVSEL           (1 << 14)		/*!< Slave Selected Bit */
+#define I2C_STAT_SLVDESEL         (1 << 15)		/*!< Slave Deselect Bit */
+#define I2C_STAT_MONRDY           (1 << 16)		/*!< Monitor Ready Bit */
+#define I2C_STAT_MONOV            (1 << 17)		/*!< Monitor Overflow Flag */
+#define I2C_STAT_MONACTIVE        (1 << 18)		/*!< Monitor Active Flag */
+#define I2C_STAT_MONIDLE          (1 << 19)		/*!< Monitor Idle Flag */
+#define I2C_STAT_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Flag */
+#define I2C_STAT_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Flag */
+
+#define I2C_STAT_MSTCODE_IDLE       (0)			/*!< Master Idle State Code */
+#define I2C_STAT_MSTCODE_RXREADY    (1)			/*!< Master Receive Ready State Code */
+#define I2C_STAT_MSTCODE_TXREADY    (2)			/*!< Master Transmit Ready State Code */
+#define I2C_STAT_MSTCODE_NACKADR    (3)			/*!< Master NACK by slave on address State Code */
+#define I2C_STAT_MSTCODE_NACKDAT    (4)			/*!< Master NACK by slave on data State Code */
+
+#define I2C_STAT_SLVCODE_ADDR         (0)		/*!< Master Idle State Code */
+#define I2C_STAT_SLVCODE_RX           (1)		/*!< Received data is available Code */
+#define I2C_STAT_SLVCODE_TX           (2)		/*!< Data can be transmitted Code */
+
+/*
+ * @brief I2C Interrupt Enable Set register Bit definition
+ */
+#define I2C_INTENSET_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Enable Bit */
+#define I2C_INTENSET_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Enable Bit */
+#define I2C_INTENSET_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Enable Bit */
+#define I2C_INTENSET_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Enable Bit */
+#define I2C_INTENSET_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Enable Bit */
+#define I2C_INTENSET_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Enable Bit */
+#define I2C_INTENSET_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Enable Bit */
+#define I2C_INTENSET_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Enable Bit */
+#define I2C_INTENSET_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Enable Bit */
+#define I2C_INTENSET_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Enable Bit */
+#define I2C_INTENSET_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Enable Bit */
+
+/*
+ * @brief I2C Interrupt Enable Clear register Bit definition
+ */
+#define I2C_INTENCLR_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Clear Bit */
+#define I2C_INTENCLR_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Clear Bit */
+#define I2C_INTENCLR_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Clear Bit */
+#define I2C_INTENCLR_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Clear Bit */
+#define I2C_INTENCLR_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Clear Bit */
+#define I2C_INTENCLR_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Clear Bit */
+#define I2C_INTENCLR_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Clear Bit */
+#define I2C_INTENCLR_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Clear Bit */
+
+/*
+ * @brief I2C TimeOut Value Macro
+ */
+#define I2C_TIMEOUT_VAL(n)              (((uint32_t) ((n) - 1) & 0xFFF0) | 0x000F)		/*!< Macro for Timeout value register */
+
+/*
+ * @brief I2C Interrupt Status register Bit definition
+ */
+#define I2C_INTSTAT_MSTPENDING      (1 << 0)		/*!< Master Pending Interrupt Status Bit */
+#define I2C_INTSTAT_MSTRARBLOSS     (1 << 4)		/*!< Master Arbitration Loss Interrupt Status Bit */
+#define I2C_INTSTAT_MSTSTSTPERR     (1 << 6)		/*!< Master Start Stop Error Interrupt Status Bit */
+#define I2C_INTSTAT_SLVPENDING      (1 << 8)		/*!< Slave Pending Interrupt Status Bit */
+#define I2C_INTSTAT_SLVNOTSTR       (1 << 11)		/*!< Slave not stretching Clock Interrupt Status Bit */
+#define I2C_INTSTAT_SLVDESEL        (1 << 15)		/*!< Slave Deselect Interrupt Status Bit */
+#define I2C_INTSTAT_MONRDY          (1 << 16)		/*!< Monitor Ready Interrupt Status Bit */
+#define I2C_INTSTAT_MONOV           (1 << 17)		/*!< Monitor Overflow Interrupt Status Bit */
+#define I2C_INTSTAT_MONIDLE         (1 << 19)		/*!< Monitor Idle Interrupt Status Bit */
+#define I2C_INTSTAT_EVENTTIMEOUT    (1 << 24)		/*!< Event Timeout Interrupt Status Bit */
+#define I2C_INTSTAT_SCLTIMEOUT      (1 << 25)		/*!< SCL Timeout Interrupt Status Bit */
+
+/*
+ * @brief I2C Master Control register Bit definition
+ */
+#define I2C_MSTCTL_MSTCONTINUE  (1 << 0)		/*!< Master Continue Bit */
+#define I2C_MSTCTL_MSTSTART     (1 << 1)		/*!< Master Start Control Bit */
+#define I2C_MSTCTL_MSTSTOP      (1 << 2)		/*!< Master Stop Control Bit */
+#define I2C_MSTCTL_MSTDMA       (1 << 3)		/*!< Master DMA Enable Bit */
+
+/*
+ * @brief I2C Master Time Register Field definition
+ */
+#define I2C_MSTTIME_MSTSCLLOW   (0x07 << 0)		/*!< Master SCL Low Time field */
+#define I2C_MSTTIME_MSTSCLHIGH  (0x07 << 4)		/*!< Master SCL High Time field */
+
+/*
+ * @brief I2C Master Data Mask
+ */
+#define I2C_MSTDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Master data mask */
+
+/*
+ * @brief I2C Slave Control register Bit definition
+ */
+#define I2C_SLVCTL_SLVCONTINUE    (1 << 0)		/*!< Slave Continue Bit */
+#define I2C_SLVCTL_SLVNACK        (1 << 1)		/*!< Slave NACK Bit */
+#define I2C_SLVCTL_SLVDMA         (1 << 3)		/*!< Slave DMA Enable Bit */
+
+/*
+ * @brief I2C Slave Data Mask
+ */
+#define I2C_SLVDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Slave data mask */
+
+/*
+ * @brief I2C Slave Address register Bit definition
+ */
+#define I2C_SLVADR_SADISABLE      (1 << 0)		/*!< Slave Address n Disable Bit */
+#define I2C_SLVADR_SLVADR         (0x7F << 1)	/*!< Slave Address field */
+#define I2C_SLVADR_MASK           ((uint32_t) 0x00FF)	/*!< Slave Address Mask */
+
+/*
+ * @brief I2C Slave Address Qualifier 0 Register Bit definition
+ */
+#define I2C_SLVQUAL_QUALMODE0     (1 << 0)		/*!< Slave Qualifier Mode Enable Bit */
+#define I2C_SLVQUAL_SLVQUAL0      (0x7F << 1)	/*!< Slave Qualifier Address for Address 0 */
+
+/*
+ * @brief I2C Monitor Data Register Bit definition
+ */
+#define I2C_MONRXDAT_DATA         (0xFF << 0)		/*!< Monitor Function Receive Data Field */
+#define I2C_MONRXDAT_MONSTART     (1 << 8)			/*!< Monitor Received Start Bit */
+#define I2C_MONRXDAT_MONRESTART   (1 << 9)			/*!< Monitor Received Repeated Start Bit */
+#define I2C_MONRXDAT_MONNACK      (1 << 10)			/*!< Monitor Received Nack Bit */
+
+/*
+ * @brief I2C Configuration register Bit definition
+ */
+#define I2C_CFG_MSTEN             (1 << 0)	/*!< Master Enable/Disable Bit */
+#define I2C_CFG_SLVEN             (1 << 1)	/*!< Slave Enable/Disable Bit */
+#define I2C_CFG_MONEN             (1 << 2)	/*!< Monitor Enable/Disable Bit */
+#define I2C_CFG_TIMEOUTEN         (1 << 3)	/*!< Timeout Enable/Disable Bit */
+#define I2C_CFG_MONCLKSTR         (1 << 4)	/*!< Monitor Clock Stretching Bit */
+#define I2C_CFG_MASK              ((uint32_t) 0x1F)	/*!< Configuration Register Mask */
+
+/*
+ * @brief I2C Status register Bit definition
+ */
+#define I2C_STAT_MSTPENDING       (1 << 0)		/*!< Master Pending Status Bit */
+#define I2C_STAT_MSTSTATE         (0x7 << 1)	/*!< Master State Code */
+#define I2C_STAT_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Bit */
+#define I2C_STAT_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Bit */
+#define I2C_STAT_SLVPENDING       (1 << 8)		/*!< Slave Pending Status Bit */
+#define I2C_STAT_SLVSTATE         (0x3 << 9)	/*!< Slave State Code */
+#define I2C_STAT_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Bit */
+#define I2C_STAT_SLVIDX           (0x3 << 12)	/*!< Slave Address Index */
+#define I2C_STAT_SLVSEL           (1 << 14)		/*!< Slave Selected Bit */
+#define I2C_STAT_SLVDESEL         (1 << 15)		/*!< Slave Deselect Bit */
+#define I2C_STAT_MONRDY           (1 << 16)		/*!< Monitor Ready Bit */
+#define I2C_STAT_MONOV            (1 << 17)		/*!< Monitor Overflow Flag */
+#define I2C_STAT_MONACTIVE        (1 << 18)		/*!< Monitor Active Flag */
+#define I2C_STAT_MONIDLE          (1 << 19)		/*!< Monitor Idle Flag */
+#define I2C_STAT_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Flag */
+#define I2C_STAT_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Flag */
+
+#define I2C_STAT_MSTCODE_IDLE       (0)			/*!< Master Idle State Code */
+#define I2C_STAT_MSTCODE_RXREADY    (1)			/*!< Master Receive Ready State Code */
+#define I2C_STAT_MSTCODE_TXREADY    (2)			/*!< Master Transmit Ready State Code */
+#define I2C_STAT_MSTCODE_NACKADR    (3)			/*!< Master NACK by slave on address State Code */
+#define I2C_STAT_MSTCODE_NACKDAT    (4)			/*!< Master NACK by slave on data State Code */
+
+#define I2C_STAT_SLVCODE_ADDR         (0)		/*!< Master Idle State Code */
+#define I2C_STAT_SLVCODE_RX           (1)		/*!< Received data is available Code */
+#define I2C_STAT_SLVCODE_TX           (2)		/*!< Data can be transmitted Code */
+
+/*
+ * @brief I2C Interrupt Enable Set register Bit definition
+ */
+#define I2C_INTENSET_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Enable Bit */
+#define I2C_INTENSET_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Enable Bit */
+#define I2C_INTENSET_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Enable Bit */
+#define I2C_INTENSET_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Enable Bit */
+#define I2C_INTENSET_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Enable Bit */
+#define I2C_INTENSET_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Enable Bit */
+#define I2C_INTENSET_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Enable Bit */
+#define I2C_INTENSET_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Enable Bit */
+#define I2C_INTENSET_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Enable Bit */
+#define I2C_INTENSET_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Enable Bit */
+#define I2C_INTENSET_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Enable Bit */
+
+/*
+ * @brief I2C Interrupt Enable Clear register Bit definition
+ */
+#define I2C_INTENCLR_MSTPENDING       (1 << 0)		/*!< Master Pending Interrupt Clear Bit */
+#define I2C_INTENCLR_MSTRARBLOSS      (1 << 4)		/*!< Master Arbitration Loss Interrupt Clear Bit */
+#define I2C_INTENCLR_MSTSTSTPERR      (1 << 6)		/*!< Master Start Stop Error Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVPENDING       (1 << 8)		/*!< Slave Pending Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVNOTSTR        (1 << 11)		/*!< Slave not stretching Clock Interrupt Clear Bit */
+#define I2C_INTENCLR_SLVDESEL         (1 << 15)		/*!< Slave Deselect Interrupt Clear Bit */
+#define I2C_INTENCLR_MONRDY           (1 << 16)		/*!< Monitor Ready Interrupt Clear Bit */
+#define I2C_INTENCLR_MONOV            (1 << 17)		/*!< Monitor Overflow Interrupt Clear Bit */
+#define I2C_INTENCLR_MONIDLE          (1 << 19)		/*!< Monitor Idle Interrupt Clear Bit */
+#define I2C_INTENCLR_EVENTTIMEOUT     (1 << 24)		/*!< Event Timeout Interrupt Clear Bit */
+#define I2C_INTENCLR_SCLTIMEOUT       (1 << 25)		/*!< SCL Timeout Interrupt Clear Bit */
+
+/*
+ * @brief I2C TimeOut Value Macro
+ */
+#define I2C_TIMEOUT_VAL(n)              (((uint32_t) ((n) - 1) & 0xFFF0) | 0x000F)		/*!< Macro for Timeout value register */
+
+/*
+ * @brief I2C Interrupt Status register Bit definition
+ */
+#define I2C_INTSTAT_MSTPENDING      (1 << 0)		/*!< Master Pending Interrupt Status Bit */
+#define I2C_INTSTAT_MSTRARBLOSS     (1 << 4)		/*!< Master Arbitration Loss Interrupt Status Bit */
+#define I2C_INTSTAT_MSTSTSTPERR     (1 << 6)		/*!< Master Start Stop Error Interrupt Status Bit */
+#define I2C_INTSTAT_SLVPENDING      (1 << 8)		/*!< Slave Pending Interrupt Status Bit */
+#define I2C_INTSTAT_SLVNOTSTR       (1 << 11)		/*!< Slave not stretching Clock Interrupt Status Bit */
+#define I2C_INTSTAT_SLVDESEL        (1 << 15)		/*!< Slave Deselect Interrupt Status Bit */
+#define I2C_INTSTAT_MONRDY          (1 << 16)		/*!< Monitor Ready Interrupt Status Bit */
+#define I2C_INTSTAT_MONOV           (1 << 17)		/*!< Monitor Overflow Interrupt Status Bit */
+#define I2C_INTSTAT_MONIDLE         (1 << 19)		/*!< Monitor Idle Interrupt Status Bit */
+#define I2C_INTSTAT_EVENTTIMEOUT    (1 << 24)		/*!< Event Timeout Interrupt Status Bit */
+#define I2C_INTSTAT_SCLTIMEOUT      (1 << 25)		/*!< SCL Timeout Interrupt Status Bit */
+
+/*
+ * @brief I2C Master Control register Bit definition
+ */
+#define I2C_MSTCTL_MSTCONTINUE  (1 << 0)		/*!< Master Continue Bit */
+#define I2C_MSTCTL_MSTSTART     (1 << 1)		/*!< Master Start Control Bit */
+#define I2C_MSTCTL_MSTSTOP      (1 << 2)		/*!< Master Stop Control Bit */
+#define I2C_MSTCTL_MSTDMA       (1 << 3)		/*!< Master DMA Enable Bit */
+
+/*
+ * @brief I2C Master Time Register Field definition
+ */
+#define I2C_MSTTIME_MSTSCLLOW   (0x07 << 0)		/*!< Master SCL Low Time field */
+#define I2C_MSTTIME_MSTSCLHIGH  (0x07 << 4)		/*!< Master SCL High Time field */
+
+/*
+ * @brief I2C Master Data Mask
+ */
+#define I2C_MSTDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Master data mask */
+
+/*
+ * @brief I2C Slave Control register Bit definition
+ */
+#define I2C_SLVCTL_SLVCONTINUE    (1 << 0)		/*!< Slave Continue Bit */
+#define I2C_SLVCTL_SLVNACK        (1 << 1)		/*!< Slave NACK Bit */
+#define I2C_SLVCTL_SLVDMA         (1 << 3)		/*!< Slave DMA Enable Bit */
+
+/*
+ * @brief I2C Slave Data Mask
+ */
+#define I2C_SLVDAT_DATAMASK         ((uint32_t) 0x00FF << 0)	/*!< Slave data mask */
+
+/*
+ * @brief I2C Slave Address register Bit definition
+ */
+#define I2C_SLVADR_SADISABLE      (1 << 0)		/*!< Slave Address n Disable Bit */
+#define I2C_SLVADR_SLVADR         (0x7F << 1)	/*!< Slave Address field */
+#define I2C_SLVADR_MASK           ((uint32_t) 0x00FF)	/*!< Slave Address Mask */
+
+/*
+ * @brief I2C Slave Address Qualifier 0 Register Bit definition
+ */
+#define I2C_SLVQUAL_QUALMODE0     (1 << 0)		/*!< Slave Qualifier Mode Enable Bit */
+#define I2C_SLVQUAL_SLVQUAL0      (0x7F << 1)	/*!< Slave Qualifier Address for Address 0 */
+
+/*
+ * @brief I2C Monitor Data Register Bit definition
+ */
+#define I2C_MONRXDAT_DATA         (0xFF << 0)		/*!< Monitor Function Receive Data Field */
+#define I2C_MONRXDAT_MONSTART     (1 << 8)			/*!< Monitor Received Start Bit */
+#define I2C_MONRXDAT_MONRESTART   (1 << 9)			/*!< Monitor Received Repeated Start Bit */
+#define I2C_MONRXDAT_MONNACK      (1 << 10)			/*!< Monitor Received Nack Bit */
+
+/**
+ * @brief	Initialize I2C Interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function enables the I2C clock for both the master and
+ * slave interfaces if the I2C channel.
+
+ */
+__STATIC_INLINE void Chip_I2C_Init(LPC_I2C_T *pI2C)
+{
+	/* Compiler must be able to optimize out non applicable cases */
+	switch ((uint32_t) pI2C) {
+	case LPC_I2C2_BASE:
+		/* Enable clock to I2C peripheral and reset */
+		Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_I2C2);
+		Chip_SYSCON_PeriphReset(RESET_I2C2);
+		return;
+
+	case LPC_I2C1_BASE:
+		/* Enable clock to I2C peripheral and reset */
+		Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_I2C1);
+		Chip_SYSCON_PeriphReset(RESET_I2C1);
+		return;
+
+	default:
+		/* Enable clock to I2C peripheral and reset */
+		Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_I2C0);
+		Chip_SYSCON_PeriphReset(RESET_I2C0);
+		return;
+	}
+}
+
+/**
+ * @brief	Shutdown I2C Interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function disables the I2C clock for both the master and
+ * slave interfaces if the I2C channel.
+ */
+__STATIC_INLINE void Chip_I2C_DeInit(LPC_I2C_T *pI2C)
+{
+	/* Compiler must be able to optimize out non applicable cases */
+	switch ((uint32_t) pI2C) {
+	case LPC_I2C2_BASE:
+		Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_I2C2);
+		return;
+
+	case LPC_I2C1_BASE:
+		Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_I2C1);
+		return;
+
+	default:
+		Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_I2C0);
+		return;
+	}
+}
+
+/**
+ * @brief	Sets register bit values with mask
+ * @param	pReg32	: Pointer to 32-bit register to set bits for
+ * @param	mask	: Zero write mask, will mask these bits are write back as 0
+ * @param	bits	: Bits to set
+ * @return	Nothing
+ * @note	This function is needed for read-modify-write operations where the register
+ * being changed has read bits that are undefined, but must be written back as 0.
+ */
+static INLINE void Chip_I2C_SetRegMask(volatile uint32_t *pReg32, uint32_t mask, uint32_t bits)
+{
+	*pReg32 = (*pReg32 & mask) | bits;
+}
+
+/**
+ * @brief	Clears register bit values with mask
+ * @param	pReg32	: Pointer to 32-bit register to clear bits for
+ * @param	mask	: Zero write mask, will mask these bits are write back as 0
+ * @param	bits	: Bits to clear
+ * @return	Nothing
+ * @note	This function is needed for read-modify-write operations where the register
+ * being changed has read bits that are undefined, but must be written back as 0.
+ */
+static INLINE void Chip_I2C_ClearRegMask(volatile uint32_t *pReg32, uint32_t mask, uint32_t bits)
+{
+	*pReg32 = (*pReg32 & mask) & ~bits;
+}
+
+/**
+ * @brief	Sets I2C Clock Divider registers
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	clkdiv	: Clock Divider value for I2C, value is between (1 - 65536)
+ * @return	Nothing
+ * @note	The clock to I2C block is determined by the following formula (I2C_PCLK
+ *          is the frequency of the system clock): <br>
+ *              I2C Clock Frequency = (I2C_PCLK)/clkdiv;<br>
+ * This divider must be setup for both the master and slave modes of the
+ * controller. When used in master mode, this divider is used with the MSTTIME
+ * register to generate the master I2C clock. Since the MSTTIME register has a
+ * limited range of divide values, this value should be selected to give an I2C
+ * clock rate that is about 2x to 18x greater than the desired master clock rate.
+ */
+__STATIC_INLINE void Chip_I2C_SetClockDiv(LPC_I2C_T *pI2C, uint32_t clkdiv)
+{
+	if ((clkdiv >= 1) && (clkdiv <= 65536)) {
+		pI2C->CLKDIV = clkdiv - 1;
+	}
+	else {
+		pI2C->CLKDIV = 0;
+	}
+}
+
+/**
+ * @brief	Get I2C Clock Divider registers
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Clock Divider value
+ * @note	Return the divider value for the I2C block
+ *          It is the CLKDIV register value + 1
+ */
+static INLINE uint32_t Chip_I2C_GetClockDiv(LPC_I2C_T *pI2C)
+{
+	return (pI2C->CLKDIV & 0xFFFF) + 1;
+}
+
+/**
+ * @brief	Enable I2C Interrupts
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	intEn	: ORed Value of I2C_INTENSET_* values to enable
+ * @return	Nothing
+ */
+static INLINE void Chip_I2C_EnableInt(LPC_I2C_T *pI2C, uint32_t intEn)
+{
+	pI2C->INTENSET = intEn;
+}
+
+/**
+ * @brief	Disable I2C Interrupts
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
+ * @return	Nothing
+ */
+static INLINE void Chip_I2C_DisableInt(LPC_I2C_T *pI2C, uint32_t intClr)
+{
+	pI2C->INTENCLR = intClr;
+}
+
+/**
+ * @brief	Disable I2C Interrupts
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	intClr	: ORed Value of I2C_INTENSET_* values to disable
+ * @return	Nothing
+ * @note	It is recommended to use the Chip_I2C_DisableInt() function
+ * instead of this function.
+ */
+static INLINE void Chip_I2C_ClearInt(LPC_I2C_T *pI2C, uint32_t intClr)
+{
+	Chip_I2C_DisableInt(pI2C, intClr);
+}
+
+/**
+ * @brief	Returns pending I2C Interrupts
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	All pending interrupts, mask with I2C_INTENSET_* to determine specific interrupts
+ */
+static INLINE uint32_t Chip_I2C_GetPendingInt(LPC_I2C_T *pI2C)
+{
+	return pI2C->INTSTAT;
+}
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2C_COMMON_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/i2cm_5410x.h ./chip/inc/i2cm_5410x.h
--- a_tnusFF/chip/inc/i2cm_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/i2cm_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,318 @@
+/*
+ * @brief LPC5410x I2C driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2CM_5410X_H_
+#define __I2CM_5410X_H_
+
+#include "i2c_common_5410x.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2CM_5410X CHIP: LPC5410X I2C master-only driver
+ * @ingroup I2C_5410X
+ * This driver only works in master mode. To describe the I2C transactions
+ * following symbols are used in driver documentation.
+ *
+ * Key to symbols
+ * ==============
+ * S     (1 bit) : Start bit
+ * P     (1 bit) : Stop bit
+ * Rd/Wr (1 bit) : Read/Write bit. Rd equals 1, Wr equals 0.
+ * A, NA (1 bit) : Acknowledge and Not-Acknowledge bit.
+ * Addr  (7 bits): I2C 7 bit address. Note that this can be expanded as usual to
+ *                 get a 10 bit I2C address.
+ * Data  (8 bits): A plain data byte. Sometimes, I write DataLow, DataHigh
+ *                 for 16 bit data.
+ * [..]: Data sent by I2C device, as opposed to data sent by the host adapter.
+ * @{
+ */
+
+/** I2CM_5410X_STATUS_TYPES I2C master transfer status types
+ */
+
+#define I2CM_STATUS_OK              0x00		/*!< Requested Request was executed successfully. */
+#define I2CM_STATUS_ERROR           0x01		/*!< Unknown error condition. */
+#define I2CM_STATUS_NAK_ADR         0x02		/*!< No acknowledgement received from slave during address phase. */
+#define I2CM_STATUS_BUS_ERROR       0x03		/*!< I2C bus error */
+#define I2CM_STATUS_NAK_DAT           0x04		/*!< No acknowledgement received from slave during address phase. */
+#define I2CM_STATUS_ARBLOST         0x05		/*!< Arbitration lost. */
+#define I2CM_STATUS_BUSY            0xFF		/*!< I2C transmistter is busy. */
+
+/**
+ * @brief Master transfer data structure definitions
+ */
+typedef struct {
+	const uint8_t *txBuff;		/*!< Pointer to array of bytes to be transmitted */
+	uint8_t *rxBuff;			/*!< Pointer memory where bytes received from I2C be stored */
+	volatile uint16_t txSz;		/*!< Number of bytes in transmit array,
+								         if 0 only receive transfer will be carried on */
+	volatile uint16_t rxSz;		/*!< Number of bytes to received,
+								         if 0 only transmission we be carried on */
+	volatile uint16_t status;	/*!< Status of the current I2C transfer */
+	uint8_t slaveAddr;			/*!< 7-bit I2C Slave address */
+} I2CM_XFER_T;
+
+/**
+ * @brief	Sets HIGH and LOW duty cycle registers
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	sclH	: Number of I2C_PCLK cycles for the SCL HIGH time value between (2 - 9).
+ * @param	sclL	: Number of I2C_PCLK cycles for the SCL LOW time value between (2 - 9).
+ * @return	Nothing
+ * @note	The I2C clock divider should be set to the appropriate value before calling this function
+ *				The I2C baud is determined by the following formula: <br>
+ *        I2C_bitFrequency = (I2C_PCLK)/(I2C_CLKDIV * (sclH + sclL)) <br>
+ *				where I2C_PCLK is the frequency of the System clock and I2C_CLKDIV is I2C clock divider
+ */
+void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL);
+
+/**
+ * @brief	Set up bus speed for LPC_I2C controller
+ * @param	pI2C		: Pointer to selected I2C peripheral
+ * @param	busSpeed	: I2C bus clock rate
+ * @return	Nothing
+ * @note	Per I2C specification the busSpeed should be
+ *          @li 100000 for Standard mode
+ *          @li 400000 for Fast mode
+ *          @li 1000000 for Fast mode plus
+ *          IOCON registers corresponding to I2C pads should be updated
+ *          according to the bus mode.
+ */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed);
+
+/**
+ * @brief	Enable I2C Master interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_Enable(LPC_I2C_T *pI2C)
+{
+	Chip_I2C_SetRegMask(&pI2C->CFG, I2C_CFG_MASK, I2C_CFG_MSTEN);
+}
+
+/**
+ * @brief	Disable I2C Master interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note
+ */
+static INLINE void Chip_I2CM_Disable(LPC_I2C_T *pI2C)
+{
+	Chip_I2C_ClearRegMask(&pI2C->CFG, I2C_CFG_MASK, I2C_CFG_MSTEN);
+}
+
+/**
+ * @brief	Get I2C Status
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	I2C Status register value
+ * @note	This function returns the value of the status register.
+ */
+static INLINE uint32_t Chip_I2CM_GetStatus(LPC_I2C_T *pI2C)
+{
+	return pI2C->STAT;
+}
+
+/**
+ * @brief	Clear I2C status bits (master)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param clrStatus : Status bit to clear, ORed Value of I2C_STAT_MSTRARBLOSS and I2C_STAT_MSTSTSTPERR
+ * @return	Nothing
+ * @note	This function clears selected status flags.
+ */
+static INLINE void Chip_I2CM_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
+{
+	/* Clear Master Arbitration Loss and Start, Stop Error */
+	pI2C->STAT = clrStatus & (I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
+}
+
+/**
+ * @brief	Check if I2C Master is pending
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns TRUE if the Master is pending else returns FALSE
+ * @note
+ */
+static INLINE bool Chip_I2CM_IsMasterPending(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_MSTPENDING) != 0;
+}
+
+/**
+ * @brief	Get current state of the I2C Master
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Master State Code, a value in the range of 0 - 4
+ * @note	After the Master is pending this state code tells the reason
+ *        for Master pending.
+ */
+static INLINE uint32_t Chip_I2CM_GetMasterState(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_MSTSTATE) >> 1;
+}
+
+/**
+ * @brief	Transmit START or Repeat-START signal on I2C bus
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to transmit START condition when
+ *        the bus becomes free. This should be called only when master is pending.
+ *				The function writes a complete value to Master Control register, ORing is not advised.
+ */
+static INLINE void Chip_I2CM_SendStart(LPC_I2C_T *pI2C)
+{
+	pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
+}
+
+/**
+ * @brief	Transmit STOP signal on I2C bus
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the controller to transmit STOP condition.
+ *				This should be called only when master is pending. The function writes a
+ *				complete value to Master Control register, ORing is not advised.
+ */
+static INLINE void Chip_I2CM_SendStop(LPC_I2C_T *pI2C)
+{
+	pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
+}
+
+/**
+ * @brief	Master Continue transfer operation
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the master controller to continue transmission.
+ *				This should be called only when master is pending. The function writes a
+ *				complete value to Master Control register, ORing is not advised.
+ */
+static INLINE void Chip_I2CM_MasterContinue(LPC_I2C_T *pI2C)
+{
+	pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+}
+
+/**
+ * @brief	Transmit a single data byte through the I2C peripheral (master)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	data	: Byte to transmit
+ * @return	Nothing
+ * @note	This function attempts to place a byte into the I2C Master
+ *			Data Register
+ *
+ */
+static INLINE void Chip_I2CM_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
+{
+	pI2C->MSTDAT = (uint32_t) data;
+}
+
+/**
+ * @brief	Read a single byte data from the I2C peripheral (master)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	A single byte of data read
+ * @note	This function reads a byte from the I2C receive hold register
+ *			regardless of I2C state.
+ */
+static INLINE uint8_t Chip_I2CM_ReadByte(LPC_I2C_T *pI2C)
+{
+	return (uint8_t) (pI2C->MSTDAT & I2C_MSTDAT_DATAMASK);
+}
+
+/**
+ * @brief	Transfer state change handler
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on completion of transfer. The @a status
+ *         member of @a xfer structure contains the current status of the
+ *         transfer at the end of the call.
+ * @note
+ * The parameter @a xfer should be same as the one passed to Chip_I2CM_Xfer()
+ * routine. This function should be called from the I2C interrupt handler
+ * only when a master interrupt occurs.
+ */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief	Transmit and Receive data in master mode
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return	Nothing
+ * @note
+ * The parameter @a xfer should have its member @a slaveAddr initialized
+ * to the 7-Bit slave address to which the master will do the xfer, Bit0
+ * to bit6 should have the address and Bit8 is ignored. During the transfer
+ * no code (like event handler) must change the content of the memory
+ * pointed to by @a xfer. The member of @a xfer, @a txBuff and @a txSz be
+ * initialized to the memory from which the I2C must pick the data to be
+ * transfered to slave and the number of bytes to send respectively, similarly
+ * @a rxBuff and @a rxSz must have pointer to memroy where data received
+ * from slave be stored and the number of data to get from slave respectilvely.
+ * Following types of transfers are possible:
+ * - Write-only transfer: When @a rxSz member of @a xfer is set to 0.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A] P
+ *
+ *      - If I2CM_XFER_OPTION_IGNORE_NACK is set in @a options memeber
+ *
+ *          S Addr Wr [A] txBuff0 [A or NA] ... txBuffN [A or NA] P
+ *
+ * - Read-only transfer: When @a txSz member of @a xfer is set to 0.
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ *      - If I2CM_XFER_OPTION_LAST_RX_ACK is set in @a options memeber
+ *
+ *          S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] A P
+ *
+ * - Read-Write transfer: When @a rxSz and @ txSz members of @a xfer are non-zero.
+ *
+ *          S Addr Wr [A] txBuff0 [A] txBuff1 [A] ... txBuffN [A]
+ *              S Addr Rd [A] [rxBuff0] A [rxBuff1] A ... [rxBuffN] NA P
+ *
+ */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @brief	Transmit and Receive data in master mode
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfer	: Pointer to a I2CM_XFER_T structure see notes below
+ * @return Returns non-zero value on successful completion of transfer.
+ * @note
+ * This function operates same as Chip_I2CM_Xfer(), but is a blocking call.
+ */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer);
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2CM_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/i2cs_5410x.h ./chip/inc/i2cs_5410x.h
--- a_tnusFF/chip/inc/i2cs_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/i2cs_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,369 @@
+/*
+ * @brief LPC5410X I2C slave driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __I2CS_5410X_H_
+#define __I2CS_5410X_H_
+
+#include "i2c_common_5410x.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup I2CS_5410X CHIP: LPC5410X I2C slave-only driver
+ * @ingroup I2C_5410X
+ * This driver only works in slave mode.
+ * @{
+ */
+
+/** @brief I2C slave service start callback
+ * This callback is called from the I2C slave handler when an I2C slave address is
+ * received and needs servicing. It's used to indicate the start of a slave transfer
+ * that will happen on the slave bus.
+ */
+typedef void (*I2CSlaveXferStart)(uint8_t addr);
+
+/** @brief I2C slave send data callback
+ * This callback is called from the I2C slave handler when an I2C slave address needs
+ * data to send.<br>
+ * If you want to NAK the master, return I2C_SLVCTL_SLVNACK to the caller.
+ * Return I2C_SLVCTL_SLVCONTINUE or 0 to the caller for normal non-DMA data transfer.
+ * If you've setup a DMA descriptor for the transfer, return I2C_SLVCTL_SLVDMA to the caller.<br>
+ */
+typedef uint8_t (*I2CSlaveXferSend)(uint8_t *data);
+
+/** @brief I2C slave receive data callback
+ * This callback is called from the I2C slave handler when an I2C slave address has
+ * receive data.<br>
+ * If you want to NAK the master, return I2C_SLVCTL_SLVNACK to the caller.
+ * Return I2C_SLVCTL_SLVCONTINUE or 0 to the caller for normal non-DMA data transfer.
+ * If you've setup a DMA descriptor for the transfer, return I2C_SLVCTL_SLVDMA to the caller.<br>
+ */
+typedef uint8_t (*I2CSlaveXferRecv)(uint8_t data);
+
+/** @brief I2C slave service done callback
+ * This callback is called from the I2C slave handler when an I2C slave transfer is
+ * completed. It's used to indicate the end of a slave transfer.
+ */
+typedef void (*I2CSlaveXferDone)(void);
+
+/**
+ * Slave transfer are performed using 4 callbacks. These 3 callbacks handle most I2C
+ * slave transfer cases. When the slave is setup and a slave interrupt is receive
+ * and processed with the Chip_I2CS_XferHandler() function in the I2C interrupt handler,
+ * one of these 4 callbacks is called. The callbacks can be used for unsized transfers
+ * from the master.
+ *
+ * When an address is received, the SlaveXferAddr() callback is called with the
+ * received address. Only addresses enabled in the slave controller will be handled.
+ * The slave controller can support up to 4 slave addresses.
+ *
+ * If the master is going to perform a read operation, the SlaveXferSend() callback
+ * is called. Place the data byte to send in *data and return a value of 0 or
+ * I2C_SLVCTL_SLVCONTINUE to the caller, or return a value o I2C_SLVCTL_SLVNACK to
+ * NACK the master. If you are using DMA and have setup a DMA descriptor in the
+ * callback, return I2C_SLVCTL_SLVDMA.<br>
+ *
+ * If the master performs a write operation, the SlaveXferRecv() callback is called
+ * with the received data. Return a value of 0 or I2C_SLVCTL_SLVCONTINUE to the caller
+ * to continue data transfer. Return I2C_SLVCTL_SLVNACK to NACk the master. If you
+ * are using DMA and have setup a DMA descriptor in the callback, return
+ * I2C_SLVCTL_SLVDMA.<br>
+ *
+ * Once the transfer completes, the SlaveXferDone() callback will be called.<br>
+ */
+typedef struct {
+	I2CSlaveXferStart slaveStart;	/*!< Called when an matching I2C slave address is received */
+	I2CSlaveXferSend slaveSend;		/*!< Called when a byte is needed to send to master */
+	I2CSlaveXferRecv slaveRecv;		/*!< Called when a byte is received from master */
+	I2CSlaveXferDone slaveDone;		/*!< Called when a slave transfer is complete */
+} I2CS_XFER_T;
+
+/**
+ * @brief	Enable I2C slave interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	Do not call this function until the slave interface is fully configured.
+ */
+__STATIC_INLINE void Chip_I2CS_Enable(LPC_I2C_T *pI2C)
+{
+	Chip_I2C_SetRegMask(&pI2C->CFG, I2C_CFG_MASK, I2C_CFG_SLVEN);
+}
+
+/**
+ * @brief	Disable I2C slave interface
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_I2CS_Disable(LPC_I2C_T *pI2C)
+{
+	Chip_I2C_ClearRegMask(&pI2C->CFG, I2C_CFG_MASK, I2C_CFG_SLVEN);
+}
+
+/**
+ * @brief	Get I2C Status
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	I2C Status register value
+ * @note	This function returns the value of the status register.
+ */
+__STATIC_INLINE uint32_t Chip_I2CS_GetStatus(LPC_I2C_T *pI2C)
+{
+	return pI2C->STAT;
+}
+
+/**
+ * @brief	Clear I2C status bits (slave)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param clrStatus : Status bit to clear, must be I2C_STAT_SLVDESEL
+ * @return	Nothing
+ * @note	This function clears selected status flags.
+ */
+__STATIC_INLINE void Chip_I2CS_ClearStatus(LPC_I2C_T *pI2C, uint32_t clrStatus)
+{
+	pI2C->STAT = clrStatus & I2C_STAT_SLVDESEL;
+}
+
+/**
+ * @brief	Check if I2C slave is pending
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns TRUE if the slave is pending else returns FALSE
+ * @note
+ */
+__STATIC_INLINE bool Chip_I2CS_IsSlavePending(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_SLVPENDING) != 0;
+}
+
+/**
+ * @brief	Check if I2C slave is selected
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns TRUE if the slave is is selected, otherwise FALSE
+ * @note
+ */
+__STATIC_INLINE bool Chip_I2CS_IsSlaveSelected(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_SLVSEL) != 0;
+}
+
+/**
+ * @brief	Check if I2C slave is deselected
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Returns TRUE if the slave is is deselected, otherwise FALSE
+ * @note
+ */
+__STATIC_INLINE bool Chip_I2CS_IsSlaveDeSelected(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_SLVDESEL) != 0;
+}
+
+/**
+ * @brief	Get current state of the I2C slave
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	slave State Code, a value of type I2C_STAT_SLVCODE_*
+ * @note	After the slave is pending this state code tells the reason
+ *        for slave pending.
+ */
+__STATIC_INLINE uint32_t Chip_I2CS_GetSlaveState(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_SLVSTATE) >> 9;
+}
+
+/**
+ * @brief	Returns the current slave address match index
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	slave match index, 0 - 3
+ */
+__STATIC_INLINE uint32_t Chip_I2CS_GetSlaveMatchIndex(LPC_I2C_T *pI2C)
+{
+	return (pI2C->STAT & I2C_STAT_SLVIDX) >> 12;
+}
+
+/**
+ * @brief	Slave Continue transfer operation (ACK)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the slave controller to continue transmission.
+ *				This should be called only when slave is pending. The function writes a
+ *				complete value to slave Control register, ORing is not advised.
+ */
+__STATIC_INLINE void Chip_I2CS_SlaveContinue(LPC_I2C_T *pI2C)
+{
+	pI2C->SLVCTL = I2C_SLVCTL_SLVCONTINUE;
+}
+
+/**
+ * @brief	Slave NACK operation
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function sets the slave controller to NAK the master.
+ */
+__STATIC_INLINE void Chip_I2CS_SlaveNACK(LPC_I2C_T *pI2C)
+{
+	pI2C->SLVCTL = I2C_SLVCTL_SLVNACK;
+}
+
+/**
+ * @brief	Enable slave DMA operation
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function enables DMA mode for the slave controller. In DMA
+ * mode, the 'continue' and 'NACK' operations aren't used and the I2C slave
+ * controller will automatically NACK any bytes beyond the available DMA
+ * buffer size.
+ */
+__STATIC_INLINE void Chip_I2CS_SlaveEnableDMA(LPC_I2C_T *pI2C)
+{
+	pI2C->SLVCTL = I2C_SLVCTL_SLVDMA;
+}
+
+/**
+ * @brief	Disable slave DMA operation
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	Nothing
+ * @note	This function disables DMA mode for the slave controller.
+ */
+__STATIC_INLINE void Chip_I2CS_SlaveDisableDMA(LPC_I2C_T *pI2C)
+{
+	pI2C->SLVCTL = 0;
+}
+
+/**
+ * @brief	Transmit a single data byte through the I2C peripheral (slave)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	data	: Byte to transmit
+ * @return	Nothing
+ * @note	This function attempts to place a byte into the I2C slave
+ *			Data Register
+ *
+ */
+__STATIC_INLINE void Chip_I2CS_WriteByte(LPC_I2C_T *pI2C, uint8_t data)
+{
+	pI2C->SLVDAT = (uint32_t) data;
+}
+
+/**
+ * @brief	Read a single byte data from the I2C peripheral (slave)
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @return	A single byte of data read
+ * @note	This function reads a byte from the I2C receive hold register
+ *			regardless of I2C state.
+ */
+__STATIC_INLINE uint8_t Chip_I2CS_ReadByte(LPC_I2C_T *pI2C)
+{
+	return (uint8_t) (pI2C->SLVDAT & I2C_SLVDAT_DATAMASK);
+}
+
+/**
+ * @brief	Set a I2C slave address for slave operation
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	slvNum	: Possible slave address number, between 0 - 3
+ * @param	slvAddr	: Slave Address for the index (7-bits, bit 7 = 0)
+ * @return	Nothing
+ * @note	Setting a slave address also enables the slave address. Do
+ * not 'pre-shift' the slave address.
+ */
+__STATIC_INLINE void Chip_I2CS_SetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum, uint8_t slvAddr)
+{
+	pI2C->SLVADR[slvNum] = (uint32_t) (slvAddr << 1);
+}
+
+/**
+ * @brief	Return a I2C programmed slave address
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	slvNum	: Possible slave address number, between 0 - 3
+ * @return	Nothing
+ */
+__STATIC_INLINE uint8_t Chip_I2CS_GetSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
+{
+	return (pI2C->SLVADR[slvNum] >> 1) & 0x7F;
+}
+
+/**
+ * @brief	Enable a I2C address
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	slvNum	: Possible slave address number, between 0 - 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_I2CS_EnableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
+{
+	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) & ~I2C_SLVADR_SADISABLE;
+}
+
+/**
+ * @brief	Disable a I2C address
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	slvNum	: Possible slave address number, between 0 - 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_I2CS_DisableSlaveAddr(LPC_I2C_T *pI2C, uint8_t slvNum)
+{
+	pI2C->SLVADR[slvNum] = (pI2C->SLVADR[slvNum] & I2C_SLVADR_MASK) | I2C_SLVADR_SADISABLE;
+}
+
+/**
+ * @brief	Setup slave qialifier address
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	extend	: true to extend I2C slave detect address 0 range, or false to match to corresponding bits
+ * @param	slvAddr	: Slave address qualifier, see SLVQUAL0 register in User Manual
+ * @return	Nothing
+ * @note	Do not 'pre-shift' the slave address.
+ */
+__STATIC_INLINE void Chip_I2CS_SetSlaveQual0(LPC_I2C_T *pI2C, bool extend, uint8_t slvAddr)
+{
+	slvAddr = slvAddr << 1;
+	if (extend) {
+		slvAddr |= I2C_SLVQUAL_QUALMODE0;
+	}
+
+	pI2C->SLVQUAL0 = slvAddr;
+}
+
+/**
+ * @brief	Slave transfer state change handler
+ * @param	pI2C	: Pointer to selected I2C peripheral
+ * @param	xfers	: Pointer to a I2CS_MULTI_XFER_T structure see notes below
+ * @return	Returns non-zero value on completion of transfer or NAK
+ * @note	See @ref I2CS_XFER_T for more information on this function. When using
+ * this function, the I2C_INTENSET_SLVPENDING and I2C_INTENSET_SLVDESEL interrupts
+ * should be enabled and setup in the I2C interrupt handler to call this function
+ * when they fire.
+ */
+uint32_t Chip_I2CS_XferHandler(LPC_I2C_T *pI2C, const I2CS_XFER_T *xfers);
+
+/**
+ * @}
+ */
+
+ #ifdef __cplusplus
+}
+#endif
+
+#endif /* __I2CS_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/iap.h ./chip/inc/iap.h
--- a_tnusFF/chip/inc/iap.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/iap.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,184 @@
+/*
+ * @brief Common IAP support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IAP_H_
+#define __IAP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup COMMON_IAP CHIP: Common Chip ISP/IAP commands and return codes
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/* IAP command definitions */
+#define IAP_PREWRRITE_CMD           50	/*!< Prepare sector for write operation command */
+#define IAP_WRISECTOR_CMD           51	/*!< Write Sector command */
+#define IAP_ERSSECTOR_CMD           52	/*!< Erase Sector command */
+#define IAP_BLANK_CHECK_SECTOR_CMD  53	/*!< Blank check sector */
+#define IAP_REPID_CMD               54	/*!< Read PartID command */
+#define IAP_READ_BOOT_CODE_CMD      55	/*!< Read Boot code version */
+#define IAP_COMPARE_CMD             56	/*!< Compare two RAM address locations */
+#define IAP_REINVOKE_ISP_CMD        57	/*!< Reinvoke ISP */
+#define IAP_READ_UID_CMD            58	/*!< Read UID */
+#define IAP_ERASE_PAGE_CMD          59	/*!< Erase page */
+#define IAP_EEPROM_WRITE            61	/*!< EEPROM Write command */
+#define IAP_EEPROM_READ             62	/*!< EEPROM READ command */
+
+/* IAP response definitions */
+#define IAP_CMD_SUCCESS             0	/*!< Command is executed successfully */
+#define IAP_INVALID_COMMAND         1	/*!< Invalid command */
+#define IAP_SRC_ADDR_ERROR          2	/*!< Source address is not on word boundary */
+#define IAP_DST_ADDR_ERROR          3	/*!< Destination address is not on a correct boundary */
+#define IAP_SRC_ADDR_NOT_MAPPED     4	/*!< Source address is not mapped in the memory map */
+#define IAP_DST_ADDR_NOT_MAPPED     5	/*!< Destination address is not mapped in the memory map */
+#define IAP_COUNT_ERROR             6	/*!< Byte count is not multiple of 4 or is not a permitted value */
+#define IAP_INVALID_SECTOR          7	/*!< Sector number is invalid or end sector number is greater than start sector number */
+#define IAP_SECTOR_NOT_BLANK        8	/*!< Sector is not blank */
+#define IAP_SECTOR_NOT_PREPARED     9	/*!< Command to prepare sector for write operation was not executed */
+#define IAP_COMPARE_ERROR           10	/*!< Source and destination data not equal */
+#define IAP_BUSY                    11	/*!< Flash programming hardware interface is busy */
+#define IAP_PARAM_ERROR             12	/*!< nsufficient number of parameters or invalid parameter */
+#define IAP_ADDR_ERROR              13	/*!< Address is not on word boundary */
+#define IAP_ADDR_NOT_MAPPED         14	/*!< Address is not mapped in the memory map */
+#define IAP_CMD_LOCKED              15	/*!< Command is locked */
+#define IAP_INVALID_CODE            16	/*!< Unlock code is invalid */
+#define IAP_INVALID_BAUD_RATE       17	/*!< Invalid baud rate setting */
+#define IAP_INVALID_STOP_BIT        18	/*!< Invalid stop bit setting */
+#define IAP_CRP_ENABLED             19	/*!< Code read protection enabled */
+
+/* IAP_ENTRY API function type */
+typedef void (*IAP_ENTRY_T)(unsigned int[5], unsigned int[4]);
+
+/**
+ * @brief	Prepare sector for write operation
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	This command must be executed before executing "Copy RAM to flash"
+ *			or "Erase Sector" command.
+ *			The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief	Copy RAM to flash
+ * @param	dstAdd		: Destination flash address where data bytes are to be written
+ * @param	srcAdd		: Source flash address where data bytes are to be read
+ * @param	byteswrt	: Number of bytes to be written
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The addresses should be a 256 byte boundary and the number of bytes
+ *			should be 256 | 512 | 1024 | 4096
+ */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt);
+
+/**
+ * @brief	Erase sector
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief Blank check a sector or multiples sector of on-chip flash memory
+ * @param	strSector	: Start sector number
+ * @param	endSector	: End sector number
+ * @return	Offset of the first non blank word location if the status code is SECTOR_NOT_BLANK
+ * @note	The end sector must be greater than or equal to start sector number
+ */
+// FIXME - There are two return value (result[0] & result[1]
+// Result0:Offset of the first non blank word location if the Status Code is
+// SECTOR_NOT_BLANK.
+// Result1:Contents of non blank word location.
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector);
+
+/**
+ * @brief	Read part identification number
+ * @return	Part identification number
+ */
+uint32_t Chip_IAP_ReadPID(void);
+
+/**
+ * @brief	Read boot code version number
+ * @return	Boot code version number
+ */
+uint8_t Chip_IAP_ReadBootCode(void);
+
+/**
+ * @brief	Compare the memory contents at two locations
+ * @param	dstAdd		: Destination of the RAM address of data bytes to be compared
+ * @param	srcAdd		: Source of the RAM address of data bytes to be compared
+ * @param	bytescmp	: Number of bytes to be compared
+ * @return	Offset of the first mismatch of the status code is COMPARE_ERROR
+ * @note	The addresses should be a word boundary and number of bytes should be
+ *			a multiply of 4
+ */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp);
+
+/**
+ * @brief	IAP reinvoke ISP to invoke the bootloader in ISP mode
+ * @return	none
+ */
+uint8_t Chip_IAP_ReinvokeISP(void);
+
+/**
+ * @brief	Read the unique ID
+ * @return	Status code to indicate the command is executed successfully or not
+ */
+uint32_t Chip_IAP_ReadUID(void);
+
+/**
+ * @brief	Erase a page or multiple papers of on-chip flash memory
+ * @param	strPage	: Start page number
+ * @param	endPage	: End page number
+ * @return	Status code to indicate the command is executed successfully or not
+ * @note	The page number must be greater than or equal to start page number
+ */
+// FIXME - There are four return value
+// Result0:The first 32-bit word (at the lowest address)
+// Result1:The second 32-bit word.
+// Result2:The third 32-bit word.
+// Result3:The fourth 32-bit word.
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IAP_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/inmux_5410x.h ./chip/inc/inmux_5410x.h
--- a_tnusFF/chip/inc/inmux_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/inmux_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,162 @@
+/*
+ * @brief LPC5410X Input Mux Registers and Driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __INMUX_5410X_H_
+#define __INMUX_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup INMUX_5410X CHIP: LPC5410X Input Mux Registers and Driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X Input Mux Register Block Structure
+ */
+typedef struct {						/*!< INMUX Structure */
+	__IO uint32_t RESERVED0[6];
+	__I  uint32_t RESERVED1[42];
+	__IO uint32_t PINTSEL[8];			/*!< Pin interrupt select registers */
+	__IO uint32_t DMA_ITRIG_INMUX[22];	/*!< Input mux register for DMA trigger inputs */
+	__I  uint32_t RESERVED2[2];
+	__IO uint32_t DMA_OTRIG_INMUX[4];	/*!< Input mux register for DMA trigger inputs */
+	__I  uint32_t RESERVED3[4];
+	__IO uint32_t FREQMEAS_REF;			/*!< Clock selection for frequency measurement ref clock */
+	__IO uint32_t FREQMEAS_TARGET;		/*!< Clock selection for frequency measurement target clock */
+} LPC_INMUX_T;
+
+/**
+ * @brief	GPIO Pin Interrupt Pin Select (sets PINTSEL register)
+ * @param	pintSel	: GPIO PINTSEL interrupt, should be: 0 to 7
+ * @param	portNum	: GPIO port number interrupt, should be: 0 to 1
+ * @param	pinNum	: GPIO pin number Interrupt, should be: 0 to 31
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_INMUX_PinIntSel(uint8_t pintSel, uint8_t portNum, uint8_t pinNum)
+{
+	LPC_INMUX->PINTSEL[pintSel] = (portNum * 32) + pinNum;
+}
+
+/* DMA triggers that can mapped to DMA channels */
+typedef enum {
+	DMATRIG_ADC0_SEQA_IRQ = 0,			/*!< ADC0 sequencer A interrupt as trigger */
+	DMATRIG_ADC0_SEQB_IRQ,				/*!< ADC0 sequencer B interrupt as trigger */
+	DMATRIG_SCT0_DMA0,					/*!< SCT 0, DMA 0 as trigger */
+	DMATRIG_SCT0_DMA1,					/*!< SCT 1, DMA 1 as trigger */
+	DMATRIG_TIMER0_MATCH0,				/*!< Timer 0, match 0 trigger */
+	DMATRIG_TIMER0_MATCH1,				/*!< Timer 0, match 1 trigger */
+	DMATRIG_TIMER1_MATCH0,				/*!< Timer 1, match 0 trigger */
+	DMATRIG_TIMER1_MATCH1,				/*!< Timer 1, match 1 trigger */
+	DMATRIG_TIMER2_MATCH0,				/*!< Timer 2, match 0 trigger */
+	DMATRIG_TIMER2_MATCH1,				/*!< Timer 2, match 1 trigger */
+	DMATRIG_TIMER3_MATCH0,				/*!< Timer 3, match 0 trigger */
+	DMATRIG_TIMER3_MATCH1,				/*!< Timer 3, match 1 trigger */
+	DMATRIG_TIMER4_MATCH0,				/*!< Timer 4, match 0 trigger */
+	DMATRIG_TIMER4_MATCH1,				/*!< Timer 4, match 1 trigger */
+	DMATRIG_PININT0,					/*!< Pin interrupt 0 trigger */
+	DMATRIG_PININT1,					/*!< Pin interrupt 1 trigger */
+	DMATRIG_PININT2,					/*!< Pin interrupt 2 trigger */
+	DMATRIG_PININT3,					/*!< Pin interrupt 3 trigger */
+	DMATRIG_OUTMUX0,					/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
+	DMATRIG_OUTMUX1,					/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
+	DMATRIG_OUTMUX2,					/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
+	DMATRIG_OUTMUX3						/*!< DMA trigger tied to this source, Select with Chip_INMUX_SetDMAOutMux */
+} DMA_TRIGSRC_T;
+
+/**
+ * @brief	Select a trigger source for a DMA channel
+ * @param	ch		: DMA channel number
+ * @param	trig	: Trigger source for the DMA channel
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_INMUX_SetDMATrigger(uint8_t ch, DMA_TRIGSRC_T trig)
+{
+	LPC_INMUX->DMA_ITRIG_INMUX[ch] = (uint32_t) trig;
+}
+
+/**
+ * @brief	Selects a DMA trigger source for the DMATRIG_OUTMUXn IDs
+ * @param	index	: Select 0 to 3 to sets the source for DMATRIG_OUTMUX0 to DMATRIG_OUTMUX3
+ * @param	dmaCh	: DMA channel to select for DMATRIG_OUTMUXn source
+ * @return	Nothing
+ * @note	This function sets the DMA trigger (out) source used with the DMATRIG_OUTMUXn
+ *			trigger source.
+ */
+__STATIC_INLINE void Chip_INMUX_SetDMAOutMux(uint8_t index, uint8_t dmaCh)
+{
+	LPC_INMUX->DMA_OTRIG_INMUX[index] = (uint32_t) dmaCh;
+}
+
+/* Freqeuency measure reference and target clock sources */
+typedef enum {
+	FREQMSR_CLKIN = 0,				/*!< CLKIN pin */
+	FREQMSR_IRC,					/*!< Internal RC (IRC) oscillator */
+	FREQMSR_WDOSC,					/*!< Watchdog oscillator */
+	FREQMSR_32KHZOSC,				/*!< 32KHz (RTC) oscillator rate */
+	FREQ_MEAS_MAIN_CLK,				/*!< main system clock */
+	FREQMSR_PIO0_4,					/*!< External pin PIO0_4 as input rate */
+	FREQMSR_PIO0_20,				/*!< External pin PIO0_20 as input rate */
+	FREQMSR_PIO0_24,				/*!< External pin PIO0_24 as input rate */
+	FREQMSR_PIO1_4					/*!< External pin PIO1_4 as input rate */
+} FREQMSR_SRC_T;
+
+/**
+ * @brief	Selects a reference clock used with the frequency measure function
+ * @param	ref	: Frequency measure function reference clock
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_INMUX_SetFreqMeasRefClock(FREQMSR_SRC_T ref)
+{
+	LPC_INMUX->FREQMEAS_REF = (uint32_t) ref;
+}
+
+/**
+ * @brief	Selects a target clock used with the frequency measure function
+ * @param	targ	: Frequency measure function reference clock
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_INMUX_SetFreqMeasTargClock(FREQMSR_SRC_T targ)
+{
+	LPC_INMUX->FREQMEAS_TARGET = (uint32_t) targ;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __INMUX_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/iocon_5410x.h ./chip/inc/iocon_5410x.h
--- a_tnusFF/chip/inc/iocon_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/iocon_5410x.h	2016-10-22 23:17:43.556840278 -0300
@@ -0,0 +1,139 @@
+/*
+ * @brief LPC5410X IOCON register block and driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __IOCON_5410X_H_
+#define __IOCON_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup IOCON_5410X CHIP: LPC5410X IOCON register block and driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X IO Configuration Unit register block structure
+ */
+typedef struct {			/*!< LPC5410X IOCON Structure */
+	__IO uint32_t  PIO[2][32];
+} LPC_IOCON_T;
+
+/**
+ * @brief Array of IOCON pin definitions passed to Chip_IOCON_SetPinMuxing() must be in this format
+ */
+typedef struct {
+	uint32_t port : 8;			/* Pin port */
+	uint32_t pin : 8;			/* Pin number */
+	uint32_t modefunc : 16;		/* Function and mode */
+} PINMUX_GRP_T;
+
+/**
+ * IOCON function and mode selection definitions
+ * See the User Manual for specific modes and functions supported by the
+ * various LPC15XX pins.
+ */
+#define IOCON_FUNC0             0x0				/*!< Selects pin function 0 */
+#define IOCON_FUNC1             0x1				/*!< Selects pin function 1 */
+#define IOCON_FUNC2             0x2				/*!< Selects pin function 2 */
+#define IOCON_FUNC3             0x3				/*!< Selects pin function 3 */
+#define IOCON_FUNC4             0x4				/*!< Selects pin function 4 */
+#define IOCON_FUNC5             0x5				/*!< Selects pin function 5 */
+#define IOCON_FUNC6             0x6				/*!< Selects pin function 6 */
+#define IOCON_FUNC7             0x7				/*!< Selects pin function 7 */
+#define IOCON_MODE_INACT        (0x0 << 3)		/*!< No addition pin function */
+#define IOCON_MODE_PULLDOWN     (0x1 << 3)		/*!< Selects pull-down function */
+#define IOCON_MODE_PULLUP       (0x2 << 3)		/*!< Selects pull-up function */
+#define IOCON_MODE_REPEATER     (0x3 << 3)		/*!< Selects pin repeater function */
+#define IOCON_HYS_EN            (0x1 << 5)		/*!< Enables hysteresis */
+#define IOCON_GPIO_MODE         (0x1 << 5)		/*!< GPIO Mode */
+#define IOCON_I2C_SLEW          (0x1 << 5)		/*!< I2C Slew Rate Control */
+#define IOCON_INV_EN            (0x1 << 6)		/*!< Enables invert function on input */
+#define IOCON_ANALOG_EN         (0x0 << 7)		/*!< Enables analog function by setting 0 to bit 7 */
+#define IOCON_DIGITAL_EN        (0x1 << 7)		/*!< Enables digital function by setting 1 to bit 7(default) */
+#define IOCON_STDI2C_EN         (0x1 << 8)		/*!< I2C standard mode/fast-mode */
+#define IOCON_FASTI2C_EN        (0x3 << 8)		/*!< I2C Fast-mode Plus and high-speed slave */
+#define IOCON_INPFILT_OFF       (0x1 << 8)		/*!< Input filter Off for GPIO pins */
+#define IOCON_INPFILT_ON        (0x0 << 8)		/*!< Input filter On for GPIO pins */
+#define IOCON_OPENDRAIN_EN      (0x1 << 10)		/*!< Enables open-drain function */
+#define IOCON_S_MODE_0CLK       (0x0 << 11)		/*!< Bypass input filter */
+#define IOCON_S_MODE_1CLK       (0x1 << 11)		/*!< Input pulses shorter than 1 filter clock are rejected */
+#define IOCON_S_MODE_2CLK       (0x2 << 11)		/*!< Input pulses shorter than 2 filter clock2 are rejected */
+#define IOCON_S_MODE_3CLK       (0x3 << 11)		/*!< Input pulses shorter than 3 filter clock2 are rejected */
+#define IOCON_S_MODE(clks)      ((clks) << 11)	/*!< Select clocks for digital input filter mode */
+#define IOCON_CLKDIV(div)       ((div) << 13)	/*!< Select peripheral clock divider for input filter sampling clock, 2^n, n=0-6 */
+
+/**
+ * @brief	Sets I/O Control pin mux
+ * @param	pIOCON		: The base of IOCON peripheral on the chip
+ * @param	port		: GPIO port to mux
+ * @param	pin			: GPIO pin to mux
+ * @param	modefunc	: OR'ed values or type IOCON_*
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_IOCON_PinMuxSet(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint32_t modefunc)
+{
+	pIOCON->PIO[port][pin] = modefunc;
+}
+
+/**
+ * @brief	I/O Control pin mux
+ * @param	pIOCON	: The base of IOCON peripheral on the chip
+ * @param	port	: GPIO port to mux
+ * @param	pin		: GPIO pin to mux
+ * @param	mode	: OR'ed values or type IOCON_*
+ * @param	func	: Pin function, value of type IOCON_FUNC?
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_IOCON_PinMux(LPC_IOCON_T *pIOCON, uint8_t port, uint8_t pin, uint16_t mode, uint8_t func)
+{
+	Chip_IOCON_PinMuxSet(pIOCON, port, pin, (uint32_t) (mode | func));
+}
+
+/**
+ * @brief	Set all I/O Control pin muxing
+ * @param	pIOCON	    : The base of IOCON peripheral on the chip
+ * @param	pinArray    : Pointer to array of pin mux selections
+ * @param	arrayLength : Number of entries in pinArray
+ * @return	Nothing
+ */
+void Chip_IOCON_SetPinMuxing(LPC_IOCON_T *pIOCON, const PINMUX_GRP_T *pinArray, uint32_t arrayLength);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __IOCON_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/lpc_types.h ./chip/inc/lpc_types.h
--- a_tnusFF/chip/inc/lpc_types.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/lpc_types.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,223 @@
+/*
+ * @brief Common types used in LPC functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __LPC_TYPES_H_
+#define __LPC_TYPES_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+/** @defgroup LPC_Types CHIP: LPC Common Types
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/** @defgroup LPC_Types_Public_Types LPC Public Types
+ * @{
+ */
+
+/**
+ * @brief Boolean Type definition
+ */
+typedef enum {FALSE = 0, TRUE = !FALSE} Bool;
+
+/**
+ * @brief Boolean Type definition
+ */
+#if !defined(__cplusplus)
+// typedef enum {false = 0, true = !false} bool;
+#endif
+
+/**
+ * @brief Flag Status and Interrupt Flag Status type definition
+ */
+typedef enum {RESET = 0, SET = !RESET} FlagStatus, IntStatus, SetState;
+#define PARAM_SETSTATE(State) ((State == RESET) || (State == SET))
+
+/**
+ * @brief Functional State Definition
+ */
+typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
+#define PARAM_FUNCTIONALSTATE(State) ((State == DISABLE) || (State == ENABLE))
+
+/**
+ * @ Status type definition
+ */
+typedef enum {ERROR = 0, SUCCESS = !ERROR} Status;
+
+/**
+ * Read/Write transfer type mode (Block or non-block)
+ */
+typedef enum {
+	NONE_BLOCKING = 0,		/**< None Blocking type */
+	BLOCKING,				/**< Blocking type */
+} TRANSFER_BLOCK_T;
+
+/** Pointer to Function returning Void (any number of parameters) */
+typedef void (*PFV)();
+
+/** Pointer to Function returning int32_t (any number of parameters) */
+typedef int32_t (*PFI)();
+
+/**
+ * @}
+ */
+
+/** @defgroup LPC_Types_Public_Macros  LPC Public Macros
+ * @{
+ */
+
+/* _BIT(n) sets the bit at position "n"
+ * _BIT(n) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "(_BIT(3) | _BIT(7))".
+ */
+#undef _BIT
+/* Set bit macro */
+#define _BIT(n) (1 << (n))
+
+/* _SBF(f,v) sets the bit field starting at position "f" to value "v".
+ * _SBF(f,v) is intended to be used in "OR" and "AND" expressions:
+ * e.g., "((_SBF(5,7) | _SBF(12,0xF)) & 0xFFFF)"
+ */
+#undef _SBF
+/* Set bit field macro */
+#define _SBF(f, v) ((v) << (f))
+
+/* _BITMASK constructs a symbol with 'field_width' least significant
+ * bits set.
+ * e.g., _BITMASK(5) constructs '0x1F', _BITMASK(16) == 0xFFFF
+ * The symbol is intended to be used to limit the bit field width
+ * thusly:
+ * <a_register> = (any_expression) & _BITMASK(x), where 0 < x <= 32.
+ * If "any_expression" results in a value that is larger than can be
+ * contained in 'x' bits, the bits above 'x - 1' are masked off.  When
+ * used with the _SBF example above, the example would be written:
+ * a_reg = ((_SBF(5,7) | _SBF(12,0xF)) & _BITMASK(16))
+ * This ensures that the value written to a_reg is no wider than
+ * 16 bits, and makes the code easier to read and understand.
+ */
+#undef _BITMASK
+/* Bitmask creation macro */
+#define _BITMASK(field_width) ( _BIT(field_width) - 1)
+
+/* NULL pointer */
+#ifndef NULL
+#define NULL ((void *) 0)
+#endif
+
+/* Number of elements in an array */
+#define NELEMENTS(array)  (sizeof(array) / sizeof(array[0]))
+
+/* Static data/function define */
+#define STATIC static
+/* External data/function define */
+#define EXTERN extern
+
+#if !defined(MAX)
+#define MAX(a, b) (((a) > (b)) ? (a) : (b))
+#endif
+#if !defined(MIN)
+#define MIN(a, b) (((a) < (b)) ? (a) : (b))
+#endif
+
+/**
+ * @}
+ */
+
+/* Old Type Definition compatibility */
+/** @addtogroup LPC_Types_Public_Types
+ * @{
+ */
+
+/** LPC type for character type */
+typedef char CHAR;
+
+/** LPC type for 8 bit unsigned value */
+typedef uint8_t UNS_8;
+
+/** LPC type for 8 bit signed value */
+typedef int8_t INT_8;
+
+/** LPC type for 16 bit unsigned value */
+typedef uint16_t UNS_16;
+
+/** LPC type for 16 bit signed value */
+typedef int16_t INT_16;
+
+/** LPC type for 32 bit unsigned value */
+typedef uint32_t UNS_32;
+
+/** LPC type for 32 bit signed value */
+typedef int32_t INT_32;
+
+/** LPC type for 64 bit signed value */
+typedef int64_t INT_64;
+
+/** LPC type for 64 bit unsigned value */
+typedef uint64_t UNS_64;
+
+#ifdef __CODE_RED
+#define BOOL_32 bool
+#define BOOL_16 bool
+#define BOOL_8  bool
+#else
+/** 32 bit boolean type */
+typedef bool BOOL_32;
+
+/** 16 bit boolean type */
+typedef bool BOOL_16;
+
+/** 8 bit boolean type */
+typedef bool BOOL_8;
+#endif
+
+#ifdef __CC_ARM
+#define INLINE  __inline
+#else
+#define INLINE inline
+#endif
+
+#ifdef __ICCARM__
+#define ALIGNSTR(x) # x
+#define ALIGN(x) _Pragma(ALIGNSTR(data_alignment = x))
+#else /* __CC_ARM || __GNUC__ */
+#define ALIGN(x) __attribute__ ((aligned(x)))
+#endif
+
+/**
+ * @}
+ */
+
+/**
+ * @}
+ */
+
+#endif /* __LPC_TYPES_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/mailbox_5410x.h ./chip/inc/mailbox_5410x.h
--- a_tnusFF/chip/inc/mailbox_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/mailbox_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,173 @@
+/*
+ * @brief LPC5410X Mailbox M4/M0+ driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __MAILBOX_5410X_H_
+#define __MAILBOX_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup MAILBOX_5410X CHIP: LPC5410X Mailbox M4/M0+ driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/* Mailbox indexes */
+typedef enum {
+	MAILBOX_CM0PLUS = 0,
+	MAILBOX_CM4
+} MBOX_IDX_T;
+#define MAILBOX_AVAIL       (MAILBOX_CM4 + 1)	/* Number of available mailboxes */
+
+/** Individual mailbox IRQ structure */
+typedef struct {
+	__IO    uint32_t        IRQ;		/*!< Mailbox data */
+	__O     uint32_t        IRQSET;		/*!< Mailbox data set bits only */
+	__O     uint32_t        IRQCLR;		/*!< Mailbox dataclearset bits only */
+	__I     uint32_t        RESERVED;
+} LPC_MBOXIRQ_T;
+
+/** Mailbox register structure */
+typedef struct {						/*!< Mailbox register structure */
+	LPC_MBOXIRQ_T           BOX[MAILBOX_AVAIL];	/*!< Mailbox, offset 0 = M0+, offset 1 = M4 */
+	LPC_MBOXIRQ_T           RESERVED1[15 - MAILBOX_AVAIL];
+	__I     uint32_t        RESERVED2[2];
+	__IO    uint32_t        MUTEX;		/*!< Mutex */
+} LPC_MBOX_T;
+
+/**
+ * @brief	Initialize mailbox
+ * @param	pMBOX	: Pointer to the mailbox register structure
+ * @return	Nothing
+ * @note	Even if both cores use the amilbox, only 1 core should initialize it.
+ */
+__STATIC_INLINE void Chip_MBOX_Init(LPC_MBOX_T *pMBOX)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_MAILBOX);
+	Chip_SYSCON_PeriphReset(RESET_MAILBOX);
+}
+
+/**
+ * @brief	Shutdown mailbox
+ * @param	pMBOX	: Pointer to the mailbox register structure
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MBOX_DeInit(LPC_MBOX_T *pMBOX)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_MAILBOX);
+}
+
+/**
+ * @brief	Set data value in the mailbox based on the CPU ID
+ * @param	pMBOX		: Pointer to the mailbox register structure
+ * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
+ * @param	mboxData	: data to send in the mailbox
+ * @return	Nothing
+ * @note	Sets a data value to send via the MBOX to the other core.
+ */
+__STATIC_INLINE void Chip_MBOX_SetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxData)
+{
+	pMBOX->BOX[cpu_id].IRQ = mboxData;
+}
+
+/**
+ * @brief	Set data bits in the mailbox based on the CPU ID
+ * @param	pMBOX		: Pointer to the mailbox register structure
+ * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
+ * @param	mboxSetBits	: data bits to set in the mailbox
+ * @return	Nothing
+ * @note	Sets data bits to send via the MBOX to the other core, A value of 0 will
+ * do nothing.  Only sets bits selected with a 1 in it's bit position.
+ */
+__STATIC_INLINE void Chip_MBOX_SetValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxSetBits)
+{
+	pMBOX->BOX[cpu_id].IRQSET = mboxSetBits;
+}
+
+/**
+ * @brief	Clear data bits in the mailbox based on the CPU ID
+ * @param	pMBOX		: Pointer to the mailbox register structure
+ * @param	cpu_id		: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
+ * @param	mboxClrBits	: data bits to clear in the mailbox
+ * @return	Nothing
+ * @note	Clear data bits to send via the MBOX to the other core. A value of 0 will
+ * do nothing. Only clears bits selected with a 1 in it's bit position.
+ */
+__STATIC_INLINE void Chip_MBOX_ClearValueBits(LPC_MBOX_T *pMBOX, uint32_t cpu_id, uint32_t mboxClrBits)
+{
+	pMBOX->BOX[cpu_id].IRQCLR = mboxClrBits;
+}
+
+/**
+ * @brief	Get data in the mailbox based on the cpu_id
+ * @param	pMBOX	: Pointer to the mailbox register structure
+ * @param	cpu_id	: MAILBOX_CM0PLUS is M0+ or MAILBOX_CM4 is M4
+ * @return	Current mailbox data
+ */
+__STATIC_INLINE uint32_t Chip_MBOX_GetValue(LPC_MBOX_T *pMBOX, uint32_t cpu_id)
+{
+	return pMBOX->BOX[cpu_id].IRQ;
+}
+
+/**
+ * @brief	Get MUTEX state and lock mutex
+ * @param	pMBOX	: Pointer to the mailbox register structure
+ * @return	See note
+ * @note	Returns '1' if the mutex was taken or '0' if another resources has the
+ * mutex locked. Once a mutex is taken, it can be returned with the Chip_MBOX_SetMutex()
+ * function.
+ */
+__STATIC_INLINE uint32_t Chip_MBOX_GetMutex(LPC_MBOX_T *pMBOX)
+{
+	return pMBOX->MUTEX;
+}
+
+/**
+ * @brief	Set MUTEX state
+ * @param	pMBOX	: Pointer to the mailbox register structure
+ * @return	Nothing
+ * @note	Sets mutex state to '1' and allows other resources to get the mutex
+ */
+__STATIC_INLINE void Chip_MBOX_SetMutex(LPC_MBOX_T *pMBOX)
+{
+	pMBOX->MUTEX = 1;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MAILBOX_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/mrt_5410x.h ./chip/inc/mrt_5410x.h
--- a_tnusFF/chip/inc/mrt_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/mrt_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,340 @@
+/*
+ * @brief LPC5410X Multi-Rate Timer (MRT) registers and driver functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __MRT_5410X_H_
+#define __MRT_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup MRT_5410X CHIP: LPC5410X Multi-Rate Timer driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X MRT chip configuration
+ */
+#define MRT_CHANNELS_NUM      (4)
+#define MRT_NO_IDLE_CHANNEL   (0x40)
+
+/**
+ * @brief MRT register block structure
+ */
+typedef struct {
+	__IO uint32_t INTVAL;	/*!< Timer interval register */
+	__O  uint32_t TIMER;	/*!< Timer register */
+	__IO uint32_t CTRL;		/*!< Timer control register */
+	__IO uint32_t STAT;		/*!< Timer status register */
+} LPC_MRT_CH_T;
+
+/**
+ * @brief MRT register block structure
+ */
+typedef struct {
+	LPC_MRT_CH_T CHANNEL[MRT_CHANNELS_NUM];
+	uint32_t unused[44];
+	__IO uint32_t MODCFG;
+	__O  uint32_t IDLE_CH;
+	__IO uint32_t IRQ_FLAG;
+} LPC_MRT_T;
+
+/**
+ * @brief MRT Interrupt Modes enum
+ */
+typedef enum MRT_MODE {
+	MRT_MODE_REPEAT =  (0 << 1),	/*!< MRT Repeat interrupt mode */
+	MRT_MODE_ONESHOT = (1 << 1)		/*!< MRT One-shot interrupt mode */
+} MRT_MODE_T;
+
+/**
+ * @brief MRT register bit fields & masks
+ */
+/* MRT Time interval register bit fields */
+#define MRT_INTVAL_IVALUE        (0x7FFFFFFF)	/* Maximum interval load value and mask */
+#define MRT_INTVAL_LOAD          (0x80000000UL)	/* Force immediate load of timer interval register bit */
+
+/* MRT Control register bit fields & masks */
+#define MRT_CTRL_INTEN_MASK      (0x01)
+#define MRT_CTRL_MODE_MASK       (0x06)
+
+/* MRT Status register bit fields & masks */
+#define MRT_STAT_INTFLAG         (0x01)
+#define MRT_STAT_RUNNING         (0x02)
+
+/* Pointer to individual MR register blocks */
+#define LPC_MRT_CH0         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[0])
+#define LPC_MRT_CH1         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[1])
+#define LPC_MRT_CH2         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[2])
+#define LPC_MRT_CH3         ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[3])
+#define LPC_MRT_CH(ch)      ((LPC_MRT_CH_T *) &LPC_MRT->CHANNEL[(ch)])
+
+/* Global interrupt flag register interrupt mask/clear values */
+#define MRT0_INTFLAG        (1)
+#define MRT1_INTFLAG        (2)
+#define MRT2_INTFLAG        (4)
+#define MRT3_INTFLAG        (8)
+#define MRTn_INTFLAG(ch)    (1 << (ch))
+
+/**
+ * @brief	Initializes the MRT
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_Init(void)
+{
+	/* Enable the clock to the register interface */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_MRT);
+
+	/* Reset MRT */
+	Chip_SYSCON_PeriphReset(RESET_MRT);
+}
+
+/**
+ * @brief	De-initializes the MRT Channel
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_DeInit(void)
+{
+	/* Disable the clock to the MRT */
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_MRT);
+}
+
+/**
+ * @brief	Returns a pointer to the register block for a MRT channel
+ * @param	ch	: MRT channel tog et register block for (0..3)
+ * @return	Pointer to the MRT register block for the channel
+ */
+__STATIC_INLINE LPC_MRT_CH_T *Chip_MRT_GetRegPtr(uint8_t ch)
+{
+	return LPC_MRT_CH(ch);
+}
+
+/**
+ * @brief	Returns the timer time interval value
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	Timer time interval value (IVALUE)
+ */
+__STATIC_INLINE uint32_t Chip_MRT_GetInterval(LPC_MRT_CH_T *pMRT)
+{
+	return pMRT->INTVAL;
+}
+
+/**
+ * @brief	Sets the timer time interval value
+ * @param	pMRT	 : Pointer to selected MRT Channel
+ * @param   interval : The interval timeout (31-bits)
+ * @return	Nothing
+ * @note	Setting bit 31 in timer time interval register causes the time interval value
+ * to load immediately, otherwise the time interval value will be loaded in
+ * next timer cycle.<br>
+ * Example: Chip_MRT_SetInterval(pMRT, 0x500 | MRT_INTVAL_LOAD); // Will load timer interval immediately<br>
+ * Example: Chip_MRT_SetInterval(pMRT, 0x500); // Will load timer interval after internal expires
+ */
+__STATIC_INLINE void Chip_MRT_SetInterval(LPC_MRT_CH_T *pMRT, uint32_t interval)
+{
+	pMRT->INTVAL = interval;
+}
+
+/**
+ * @brief	Returns the current timer value
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	The current timer value
+ */
+__STATIC_INLINE uint32_t Chip_MRT_GetTimer(LPC_MRT_CH_T *pMRT)
+{
+	return pMRT->TIMER;
+}
+
+/**
+ * @brief	Returns true if the timer is enabled
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	True if enabled, Flase if not enabled
+ */
+__STATIC_INLINE bool Chip_MRT_GetEnabled(LPC_MRT_CH_T *pMRT)
+{
+	return (bool) ((pMRT->CTRL & MRT_CTRL_INTEN_MASK) != 0);
+}
+
+/**
+ * @brief	Enables the timer
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_SetEnabled(LPC_MRT_CH_T *pMRT)
+{
+	pMRT->CTRL |= MRT_CTRL_INTEN_MASK;
+}
+
+/**
+ * @brief	Disables the timer
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_SetDisabled(LPC_MRT_CH_T *pMRT)
+{
+	pMRT->CTRL &= ~MRT_CTRL_INTEN_MASK;
+}
+
+/**
+ * @brief	Returns the timer mode (repeat or one-shot)
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	The current timer mode
+ */
+__STATIC_INLINE MRT_MODE_T Chip_MRT_GetMode(LPC_MRT_CH_T *pMRT)
+{
+	return (MRT_MODE_T) (pMRT->CTRL & MRT_CTRL_MODE_MASK);
+}
+
+/**
+ * @brief	Sets the timer mode (repeat or one-shot)
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @param   mode    : Timer mode
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_SetMode(LPC_MRT_CH_T *pMRT, MRT_MODE_T mode)
+{
+	uint32_t reg;
+
+	reg = pMRT->CTRL & ~MRT_CTRL_MODE_MASK;
+	pMRT->CTRL = reg | (uint32_t) mode;
+}
+
+/**
+ * @brief	Check if the timer is configured in repeat mode
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	True if in repeat mode, False if in one-shot mode
+ */
+__STATIC_INLINE bool Chip_MRT_IsRepeatMode(LPC_MRT_CH_T *pMRT)
+{
+	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? false : true;
+}
+
+/**
+ * @brief	Check if the timer is configured in one-shot mode
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	True if in one-shot mode, False if in repeat mode
+ */
+__STATIC_INLINE bool Chip_MRT_IsOneShotMode(LPC_MRT_CH_T *pMRT)
+{
+	return ((pMRT->CTRL & MRT_CTRL_MODE_MASK) != 0) ? true : false;
+}
+
+/**
+ * @brief	Check if the timer has an interrupt pending
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	True if interrupt is pending, False if no interrupt is pending
+ */
+__STATIC_INLINE bool Chip_MRT_IntPending(LPC_MRT_CH_T *pMRT)
+{
+	return (bool) ((pMRT->STAT & MRT_STAT_INTFLAG) != 0);
+}
+
+/**
+ * @brief	Clears the pending interrupt (if any)
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_MRT_IntClear(LPC_MRT_CH_T *pMRT)
+{
+	pMRT->STAT |= MRT_STAT_INTFLAG;
+}
+
+/**
+ * @brief	Check if the timer is running
+ * @param	pMRT	: Pointer to selected MRT Channel
+ * @return	True if running, False if stopped
+ */
+__STATIC_INLINE bool Chip_MRT_Running(LPC_MRT_CH_T *pMRT)
+{
+	return (bool) ((pMRT->STAT & MRT_STAT_RUNNING) != 0);
+}
+
+/**
+ * @brief	Returns the IDLE channel value
+ * @return	IDLE channel value (unshifted in bits 7..4)
+ */
+__STATIC_INLINE uint8_t Chip_MRT_GetIdleChannel(void)
+{
+	return (uint8_t) (LPC_MRT->IDLE_CH);
+}
+
+/**
+ * @brief	Returns the IDLE channel value
+ * @return	IDLE channel value (shifted in bits 3..0)
+ */
+__STATIC_INLINE uint8_t Chip_MRT_GetIdleChannelShifted(void)
+{
+	return (uint8_t) (Chip_MRT_GetIdleChannel() >> 4);
+}
+
+/**
+ * @brief	Returns the interrupt pending status for all MRT channels
+ * @return	IRQ pending channel bitfield(bit 0 = MRT0, bit 1 = MRT1, etc.)
+ */
+__STATIC_INLINE uint32_t Chip_MRT_GetIntPending(void)
+{
+	return LPC_MRT->IRQ_FLAG;
+}
+
+/**
+ * @brief	Returns the interrupt pending status for a singel MRT channel
+ * @param	ch	: Channel to check pending interrupt status for
+ * @return	IRQ pending channel number
+ */
+__STATIC_INLINE bool Chip_MRT_GetIntPendingByChannel(uint8_t ch)
+{
+	return (bool) (((LPC_MRT->IRQ_FLAG >> ch) & 1) != 0);
+}
+
+/**
+ * @brief	Clears the interrupt pending status for one or more MRT channels
+ * @param	mask	: Channels to clear (bit 0 = MRT0, bit 1 = MRT1, etc.)
+ * @return	Nothing
+ * @note	Use this function to clear multiple interrupt pending states in
+ * a single call via the IRQ_FLAG register. Performs the same function for
+ * all MRT channels in a single call as the Chip_MRT_IntClear() does for a
+ * single channel.
+ */
+__STATIC_INLINE void Chip_MRT_ClearIntPending(uint32_t mask)
+{
+	LPC_MRT->IRQ_FLAG = mask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __MRT_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/pdm_api.h ./chip/inc/pdm_api.h
--- a_tnusFF/chip/inc/pdm_api.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/pdm_api.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,119 @@
+/*
+ * @brief PDM mic interface module
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PDM_API_H_
+#define __PDM_API_H_
+
+#include <stdint.h>
+#include <string.h>
+#include <stdbool.h>
+#include "lpc_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SH_PDM PDMLIB: PDM interface API
+ * @ingroup SENSOR_HUB
+ * @{
+ */
+
+/**
+ * @brief	Initialize PDM module
+ * @return	Nothing
+ * @note PDM Clock (Clk out or Timer1) should be configured by the application.
+ */
+extern void PDM_Init(void);
+
+/**
+ * @brief	Reset PDM interface
+ * @return	Nothing
+ * @note	This function resets the PDM (SI interface) state variables for a fresh start.
+ */
+extern void PDM_Reset(void);
+
+/**
+ * @brief	Start capturing PDM data
+ * @return	Nothing
+ */
+extern void PDM_Start(void);
+
+/**
+ * @brief	Stop capturing PDM data
+ * @return	Nothing
+ */
+extern void PDM_Stop(void);
+
+/******************************************************************************
+ *          Callback routines
+ *****************************************************************************/
+/**
+ * @brief	PDM data ready callback
+ * @return	Nothing
+ * @note	This function is called by PDM block when data is ready. Partially
+ *	decimated data is available through @ref pdm_audio buffer and audio envelope_buffer
+ *  data for voice activity detection is available through @ref envelope_buffer.
+ */
+extern void PDM_DataReady(void);
+
+/** @brief Audio envelop data.
+    Envelope information:
+     - envelope_buffer[0] Fast detector
+     - envelope_buffer[1] Slow detector
+     - envelope_buffer[2] Reserved for internal use
+     - envelope_buffer[3] Reserved for internal use
+     - envelope_buffer[4] Latest biggest difference between fast and slow detector
+     - envelope_buffer[5] latest output of pre envelope lowpass filter
+     - envelope_buffer[6] latest output of pre envelope highpass filter
+
+ */
+extern volatile int32_t envelope_buffer[];
+
+/** @brief Decimated PDM data.
+    A DC cut filter should be applied on this data to get 16bit PCM samples @ 16KHz
+ */
+extern volatile int32_t pdm_audio[];
+
+#define PDM_AUDIO_BUF_SIZE 32
+
+#define PDM_PONG (*((volatile unsigned *) 0x4004C044)) & (1 << 6)
+
+#define PDM_IRQn (IRQn_Type) 30
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PDM_API_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/pinint_5410x.h ./chip/inc/pinint_5410x.h
--- a_tnusFF/chip/inc/pinint_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/pinint_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,413 @@
+/*
+ * @brief LPC5410X Pin Interrupt and Pattern Match Registers and driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PININT_5410X_H_
+#define __PININT_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PININT_5410X CHIP: LPC5410X Pin Interrupt and Pattern Match driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X Pin Interrupt and Pattern Match register block structure
+ */
+typedef struct {			/*!< PIN_INT Structure */
+	__IO uint32_t ISEL;		/*!< Pin Interrupt Mode register */
+	__IO uint32_t IENR;		/*!< Pin Interrupt Enable (Rising) register */
+	__IO uint32_t SIENR;	/*!< Set Pin Interrupt Enable (Rising) register */
+	__IO uint32_t CIENR;	/*!< Clear Pin Interrupt Enable (Rising) register */
+	__IO uint32_t IENF;		/*!< Pin Interrupt Enable Falling Edge / Active Level register */
+	__IO uint32_t SIENF;	/*!< Set Pin Interrupt Enable Falling Edge / Active Level register */
+	__IO uint32_t CIENF;	/*!< Clear Pin Interrupt Enable Falling Edge / Active Level address */
+	__IO uint32_t RISE;		/*!< Pin Interrupt Rising Edge register */
+	__IO uint32_t FALL;		/*!< Pin Interrupt Falling Edge register */
+	__IO uint32_t IST;		/*!< Pin Interrupt Status register */
+	__IO uint32_t PMCTRL;	/*!< GPIO pattern match interrupt control register          */
+	__IO uint32_t PMSRC;	/*!< GPIO pattern match interrupt bit-slice source register */
+	__IO uint32_t PMCFG;	/*!< GPIO pattern match interrupt bit slice configuration register */
+} LPC_PIN_INT_T;
+
+/**
+ * LPC5410X Pin Interrupt and Pattern match engine register
+ * bit fields and macros
+ */
+
+/* PININT Interrupt Mode Mask */
+#define PININT_ISEL_PMODE_MASK   ((uint32_t) 0x00FF)
+
+/* PININT Pattern Match Control Register Mask */
+#define PININT_PMCTRL_MASK       ((uint32_t) 0xFF000003)
+
+/* PININT interrupt control register */
+#define PININT_PMCTRL_PMATCH_SEL (1 << 0)
+#define PININT_PMCTRL_RXEV_ENA   (1 << 1)
+
+/* PININT Bit slice source register bits */
+#define PININT_SRC_BITSOURCE_START  8
+#define PININT_SRC_BITSOURCE_MASK   7
+
+/* PININT Bit slice configuration register bits */
+#define PININT_SRC_BITCFG_START  8
+#define PININT_SRC_BITCFG_MASK   7
+
+/**
+ * LPC5410X Pin Interrupt channel values
+ */
+#define PININTCH0         (1 << 0)
+#define PININTCH1         (1 << 1)
+#define PININTCH2         (1 << 2)
+#define PININTCH3         (1 << 3)
+#define PININTCH4         (1 << 4)
+#define PININTCH5         (1 << 5)
+#define PININTCH6         (1 << 6)
+#define PININTCH7         (1 << 7)
+#define PININTCH(ch)      (1 << (ch))
+
+/**
+ * LPC5410X Pin Interrupt select enum values
+ */
+typedef enum Chip_PININT_SELECT {
+	PININTSELECT0 = 0,
+	PININTSELECT1 = 1,
+	PININTSELECT2 = 2,
+	PININTSELECT3 = 3,
+	PININTSELECT4 = 4,
+	PININTSELECT5 = 5,
+	PININTSELECT6 = 6,
+	PININTSELECT7 = 7
+} Chip_PININT_SELECT_T;
+
+/**
+ * LPC5410X Pin Matching Interrupt bit slice enum values
+ */
+typedef enum Chip_PININT_BITSLICE {
+	PININTBITSLICE0 = 0,	/*!< PININT Bit slice 0 */
+	PININTBITSLICE1 = 1,	/*!< PININT Bit slice 1 */
+	PININTBITSLICE2 = 2,	/*!< PININT Bit slice 2 */
+	PININTBITSLICE3 = 3,	/*!< PININT Bit slice 3 */
+	PININTBITSLICE4 = 4,	/*!< PININT Bit slice 4 */
+	PININTBITSLICE5 = 5,	/*!< PININT Bit slice 5 */
+	PININTBITSLICE6 = 6,	/*!< PININT Bit slice 6 */
+	PININTBITSLICE7 = 7		/*!< PININT Bit slice 7 */
+} Chip_PININT_BITSLICE_T;
+
+/**
+ * LPC5410X Pin Matching Interrupt bit slice configuration enum values
+ */
+typedef enum Chip_PININT_BITSLICE_CFG {
+	PININT_PATTERNCONST1           = 0x0,	/*!< Contributes to product term match */
+	PININT_PATTERNRISING           = 0x1,	/*!< Rising edge */
+	PININT_PATTERNFALLING          = 0x2,	/*!< Falling edge */
+	PININT_PATTERNRISINGORFALLING  = 0x3,	/*!< Rising or Falling edge */
+	PININT_PATTERNHIGH             = 0x4,	/*!< High level */
+	PININT_PATTERNLOW              = 0x5,	/*!< Low level */
+	PININT_PATTERNCONST0           = 0x6,	/*!< Never contributes for match */
+	PININT_PATTERNEVENT            = 0x7	/*!< Match occurs on event */
+} Chip_PININT_BITSLICE_CFG_T;
+
+/**
+ * @brief	Initialize Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ * @note	This function should be used after the Chip_GPIO_Init() function.
+ */
+__STATIC_INLINE void Chip_PININT_Init(LPC_PIN_INT_T *pPININT)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_PINT);
+	Chip_SYSCON_PeriphReset(RESET_PINT);
+}
+
+/**
+ * @brief	De-Initialize Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_DeInit(LPC_PIN_INT_T *pPININT)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_PINT);
+}
+
+/**
+ * @brief	Configure the pins as edge sensitive in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_SetPinModeEdge(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->ISEL = (pPININT->ISEL & PININT_ISEL_PMODE_MASK) & ~pins;
+}
+
+/**
+ * @brief	Configure the pins as level sensitive in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_SetPinModeLevel(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->ISEL = (pPININT->ISEL & PININT_ISEL_PMODE_MASK) | pins;
+}
+
+/**
+ * @brief	Return current PININT edge or level sensitive interrupt selection state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	A bifield containing the edge/level sensitive selection for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the edge sensitive interrupt is selected, while a 1
+ * means the level sensitive interrupt is selected.
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetPinMode(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->ISEL & PININT_ISEL_PMODE_MASK;
+}
+
+/**
+ * @brief	Return current PININT rising edge or level interrupt enable state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	A bifield containing the rising edge/level enable for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the rising edge/level interrupt is disabled, while a 1
+ * means it's enabled.
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetHighEnabled(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IENR;
+}
+
+/**
+ * @brief	Enable rising edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to enable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_EnableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->SIENR = pins;
+}
+
+/**
+ * @brief	Disable rising edge/level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to disable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_DisableIntHigh(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->CIENR = pins;
+}
+
+/**
+ * @brief	Return current PININT falling edge or level interrupt active level enable state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	A bifield containing the falling edge/level interrupt active level enable for each
+ * interrupt. Bit 0 = PININT0, 1 = PININT1, etc.
+ * For each bit, a 0 means the falling edge is disabled/level interrupt active low is enabled, while a 1
+ * means the falling edge is enabled/level interrupt active high is enabled.
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetLowEnabled(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IENF;
+}
+
+/**
+ * @brief	Enable falling edge/level active level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to enable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_EnableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->SIENF = pins;
+}
+
+/**
+ * @brief	Disable low edge/level active level PININT interrupts for pins
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins to disable (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_DisableIntLow(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->CIENF = pins;
+}
+
+/**
+ * @brief	Return pin states that have a detected latched rising edge (RISE) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	PININT states (bit n = high) with a latched rise state detected
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetRiseStates(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->RISE;
+}
+
+/**
+ * @brief	Clears pin states that had a latched rising edge (RISE) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins with latched states to clear
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_ClearRiseStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->RISE = pins;
+}
+
+/**
+ * @brief	Return pin states that have a detected latched falling edge (FALL) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	PININT states (bit n = high) with a latched rise state detected
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetFallStates(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->FALL;
+}
+
+/**
+ * @brief	Clears pin states that had a latched falling edge (FALL) state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pins with latched states to clear
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_ClearFallStates(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->FALL = pins;
+}
+
+/**
+ * @brief	Get interrupt status from Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Interrupt status (bit n for PININTn = high means interrupt ie pending)
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetIntStatus(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->IST;
+}
+
+/**
+ * @brief	Clear interrupt status in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	pins	: Pin interrupts to clear (ORed value of PININTCH*)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_ClearIntStatus(LPC_PIN_INT_T *pPININT, uint32_t pins)
+{
+	pPININT->IST = pins;
+}
+
+/**
+ * @brief	Set source for pattern match in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	channelNum : PININT channel number (From 0 to 7)
+ * @param	sliceNum	: PININT slice number
+ * @return	Nothing
+ */
+void Chip_PININT_SetPatternMatchSrc(LPC_PIN_INT_T *pPININT,
+									Chip_PININT_SELECT_T channelNum,
+									Chip_PININT_BITSLICE_T sliceNum);
+
+/**
+ * @brief	Configure the pattern matcch in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @param	sliceNum : PININT slice number
+ * @param	slice_cfg	: PININT slice configuration value (enum Chip_PININT_BITSLICE_CFG_T)
+ * @param	end_point	: If true, current slice is final component
+ * @return	Nothing
+ */
+void Chip_PININT_SetPatternMatchConfig(LPC_PIN_INT_T *pPININT, Chip_PININT_BITSLICE_T sliceNum,
+									   Chip_PININT_BITSLICE_CFG_T slice_cfg, bool end_point);
+
+/**
+ * @brief	Enable pattern match interrupts in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_EnablePatternMatch(LPC_PIN_INT_T *pPININT)
+{
+	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) | PININT_PMCTRL_PMATCH_SEL;
+}
+
+/**
+ * @brief	Disable pattern match interrupts in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_DisablePatternMatch(LPC_PIN_INT_T *pPININT)
+{
+	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) & ~PININT_PMCTRL_PMATCH_SEL;
+}
+
+/**
+ * @brief	Enable RXEV output in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_EnablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
+{
+	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) | PININT_PMCTRL_RXEV_ENA;
+}
+
+/**
+ * @brief	Disable RXEV output in Pin interrupt block
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PININT_DisablePatternMatchRxEv(LPC_PIN_INT_T *pPININT)
+{
+	pPININT->PMCTRL = (pPININT->PMCTRL & PININT_PMCTRL_MASK) & ~PININT_PMCTRL_RXEV_ENA;
+}
+
+/**
+ * @brief	Return pattern match state
+ * @param	pPININT	: The base address of Pin interrupt block
+ * @return	8 bit pattern match state, where a 1 in any bit indicates that
+ *					the corresponding product term has matched by the current state
+ *					of its inputs.
+ */
+__STATIC_INLINE uint32_t Chip_PININT_GetPatternMatchState(LPC_PIN_INT_T *pPININT)
+{
+	return pPININT->PMCTRL >> 24;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PININT_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/pintable_5410x.h ./chip/inc/pintable_5410x.h
--- a_tnusFF/chip/inc/pintable_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/pintable_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,124 @@
+/*
+ * @brief LPC5410x enhanced boot block
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PINTABLE_5410X_H_
+#define __PINTABLE_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PINTAB_5410X CHIP: LPC5410X Enhanced boot block support
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/* Enhanced image signature offset */
+#define IMAGE_ENH_MARKER_OFF        0x24
+
+/* Enhanced single image signature */
+#define IMAGE_SINGLE_ENH_SIG        0xEDDC9494
+
+/* Enhanced dual image signature */
+#define IMAGE_DUAL_ENH_SIG          0x0FFEB6B6
+
+/* Boot block offset */
+#define IMAGE_BOOT_BLOCK_OFF        0x28
+
+/* Enhanced image block marker */
+#define IMAGE_ENH_BLOCK_MARKER  0xFEEDA5A5
+
+/* Macro for assigning a pin to a PINTABLE pin entry */
+#define SETPORTPIN(port, pin) (((port) & 0x7) << 5) | ((pin) & 0x1F)
+
+/** Image type (img_type) for the pin table structure */
+typedef enum {
+	IMG_NORMAL = 0,				/*!< Normal image check, assert dynamic ISP to halt boot */
+	IMG_ISP_WAIT,					/*!< Wait for host system to send SH_CMD_BOOT command */
+	IMG_NO_WAIT,					/*!< Boot image without checking dynamic ISP, CRC is still done */
+	IMG_NO_CRC,						/*!< No CRC check made. Used during development. Dynamic ISP still works */
+	IMG_JUST_BOOT   = 0xFF	/*!< Disables XOR and CRC checks, will always boot */
+} IMAGE_T;
+
+/** Host interface sources (ifSel) for the pin table structure */
+typedef enum {
+	SL_AUTO = 0,		/*!< Auto-detect used for host interface */
+	SL_I2C0,				/*!< I2C0 used for host interface */
+	SL_I2C1,				/*!< I2C1 used for host interface */
+	SL_I2C2,				/*!< I2C2 used for host interface */
+	SL_SPI0,				/*!< SPI0 used for host interface */
+	SL_SPI1,				/*!< SPI1 used for host interface */
+} IFSEL_T;
+
+/**
+ * @brief LPC5410X Pin table structure used for enhanced boot block support
+ */
+typedef struct PINTABLE {
+	/* pin table marker: Should be 0xFEEDA5A5 */
+	uint32_t marker;
+	/* img_type: Image type (IMAGE_T)
+	    0    = Normal image check, assert dynamic ISP to halt boot
+	    1    = Wait for host system to send SH_CMD_BOOT command
+	    2    = Boot image without checking dynamic ISP, CRC is still done
+	    3    = No CRC check made. Used during development. Dynamic ISP still works.
+	    0xFF = Disables XOR and CRC checks, will always boot */
+	uint8_t img_type;
+	/* ifSel: Interface selection for host (IFSEL_T)
+	    (0,=AUTODETECT, 1=I2C0, 2=I2C1, 3=I2C2, 4=SPI0, 5=SPI1) */
+	uint8_t ifSel;
+	/* hostIrqPortPin:	Host IRQ port (bits 7:5) and pins (bits 4:0) */
+	uint8_t hostIrqPortPin;
+	/* hostMisoPortPin:	SPI MISO port (bits 7:5) and pins (bits 4:0) */
+	uint8_t hostMisoPortPin;
+	/* hostMosiPortPin:	SPI MOSI port (bits 7:5) and pins (bits 4:0) */
+	uint8_t hostMosiPortPin;
+	/* hostSselPortPin:	SPI SEL port (bits 7:5) and pins (bits 4:0) */
+	uint8_t hostSselPortPin;
+	/* hostSckPortPin:	SPI SCK port (bits 7:5) and pins (bits 4:0) */
+	uint8_t hostSckPortPin;
+	/* xorVal: XOR value of the 7 bytes above */
+	uint8_t xorVal;
+	/* CRC32 length and value fields */
+	uint32_t crc32_len;
+	uint32_t crc32_val;
+	/* Application image version number */
+	uint32_t version;
+} PINTABLE_T;
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PINTAB_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/pll_5410x.h ./chip/inc/pll_5410x.h
--- a_tnusFF/chip/inc/pll_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/pll_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,305 @@
+/*
+ * @brief LPC5410X PLL driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PLL_5410X_H_
+#define __PLL_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PLL_5410X CHIP: LPC5410X PLL Driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * The PLL in the LPC5410x is flexible, but can be complex to use. This driver
+ * provides functions to help setup and use the PLL in it's various supported
+ * modes.<br>
+ *
+ * This driver does not alter PLL clock source or system clocks outside the
+ * PLL (like the main clock source) that may be referenced from the PLL. It
+ * may optionally setup system voltages, wait for PLL lock, and power cycle
+ * the PLL during setup based on setup flags.
+ *
+ * The driver works by first generating a PLL setup structure from a desired
+ * PLL configuration structure. The PLL setup structure is then passed to the
+ * PLL setup function to setup the PLL. In a user spplication, the PLL setup
+ * structure can be pre-populated with PLL setup data to avoid using the PLL
+ * configuration structure (or multiple PLL setup structures can be used to
+ * more dynamically control PLL output rate).
+ *
+ * <b>How to use this driver</b><br>
+   @verbatim
+   // Setup PLL configuration
+   PLL_CONFIG_T pllConfig = {
+    75000000,		// desiredRate = 75MHz
+    0,				// InputRate = 0Hz (not used)
+    0				// No flags, function will determine best setup to get closest rate
+   };
+
+   // Get closest PLL setup to get the desired configuration
+   PLL_SETUP_T pllSetup;
+   uint32_t actualPllRate;
+   PLL_ERROR_T pllError;
+   pllError = Chip_Clock_SetupPLLData(&pllConfig, &pllSetup, &actualPllRate);
+   if (pllError != PLL_ERROR_SUCCESS) {
+    printf("PLL setup error #%x\r\n", (uint32_t) pllError);
+    while (1);
+   }
+   else {
+    printf("PLL config successful, actual config rate = %uHz\r\n", actualPllRate);
+   }
+
+   // Make sure main system clock is not using PLL, as the PLL setup
+   // function will power off and optionally power on the PLL
+   Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_IRC);
+
+   // Setup PLL source
+   Chip_Clock_SetSystemPLLSource(SYSCON_PLLCLKSRC_IRC);
+
+   // Now to apply the configuration to the PLL
+   pllSetup.flags = PLL_SETUPFLAG_WAITLOCK;
+   Chip_Clock_SetupSystemPLLPrec(&pllSetup);
+
+   // Switch main system clock to PLL
+   Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_PLLOUT);
+   @endverbatim
+ *
+ * @{
+ */
+
+/**
+ * Clock sources for system PLLs
+ */
+typedef enum CHIP_SYSCON_PLLCLKSRC {
+	SYSCON_PLLCLKSRC_IRC = 0,		/*!< Internal oscillator */
+	SYSCON_PLLCLKSRC_CLKIN,			/*!< External clock input pin */
+	SYSCON_PLLCLKSRC_WDTOSC,		/*!< WDT oscillator */
+	SYSCON_PLLCLKSRC_RTC,			/*!< RTC 32KHz oscillator */
+} CHIP_SYSCON_PLLCLKSRC_T;
+
+/**
+ * @brief	Set System PLL clock source
+ * @param	src	: Clock source for system PLL
+ * @return	Nothing
+ * @note	The PLL should be pwoered down prior to changing the source.
+ */
+__STATIC_INLINE void Chip_Clock_SetSystemPLLSource(CHIP_SYSCON_PLLCLKSRC_T src)
+{
+	LPC_SYSCON->SYSPLLCLKSEL = (uint32_t) src;
+}
+
+/**
+ * @brief	Return System PLL input clock rate
+ * @return	System PLL input clock rate
+ */
+uint32_t Chip_Clock_GetSystemPLLInClockRate(void);
+
+/**
+ * @brief	Return System PLL output clock rate
+ * @param	recompute	: Forces a PLL rate recomputation if true
+ * @return	System PLL output clock rate
+ * @note	The PLL rate is cached in the driver in a variable as
+ * the rate computation function can take some time to perform. It
+ * is recommended to use 'false' with the 'recompute' parameter.
+ */
+uint32_t Chip_Clock_GetSystemPLLOutClockRate(bool recompute);
+
+/**
+ * @brief	Enables and disables PLL bypass mode
+ * @brief	bypass	: true to bypass PLL (PLL output = PLL input, false to disable bypass
+ * @return	System PLL output clock rate
+ */
+void Chip_Clock_SetBypassPLL(bool bypass);
+
+/**
+ * @brief	Check if PLL is locked or not
+ * @return	true if the PLL is locked, false if not locked
+ */
+__STATIC_INLINE bool Chip_Clock_IsSystemPLLLocked(void)
+{
+	return (bool) ((LPC_SYSCON->SYSPLLSTAT & 1) != 0);
+}
+
+/** @brief PLL configuration structure flags for 'flags' field
+ * These flags control how the PLL configuration function sets up the PLL setup structure.<br>
+ *
+ * When the PLL_CONFIGFLAG_USEINRATE flag is selected, the 'InputRate' field in the
+ * configuration structure must be assigned with the expected PLL frequency. If the
+ * PLL_CONFIGFLAG_USEINRATE is not used, 'InputRate' is ignored in the configuration
+ * function and the driver will determine the PLL rate from the currently selected
+ * PLL source. This flag might be used to configure the PLL input clock more accurately
+ * when using the WDT oscillator or a more dyanmic CLKIN source.<br>
+ *
+ * When the PLL_CONFIGFLAG_FORCENOFRACT flag is selected, the PLL hardware for the
+ * automatic bandwidth selection, Spread Spectrum (SS) support, and fractional M-divider
+ * are not used.<br>
+ */
+#define PLL_CONFIGFLAG_USEINRATE    (1 << 0)	/*!< Flag to use InputRate in PLL configuration structure for setup */
+#define PLL_CONFIGFLAG_FORCENOFRACT (1 << 2)	/*!< Force non-fractional output mode, PLL output will not use the fractional, automatic bandwidth, or SS hardware */
+
+/** @brief PLL Spread Spectrum (SS) Programmable modulation frequency
+ * See (MF) field in the SYSPLLSSCTRL1 register in the UM.
+ */
+typedef enum {
+	SS_MF_512 = (0 << 20),		/*!< Nss = 512 (fm ˜ 3.9 - 7.8 kHz) */
+	SS_MF_384 = (1 << 20),		/*!< Nss ˜= 384 (fm ˜ 5.2 - 10.4 kHz) */
+	SS_MF_256 = (2 << 20),		/*!< Nss = 256 (fm ˜ 7.8 - 15.6 kHz) */
+	SS_MF_128 = (3 << 20),		/*!< Nss = 128 (fm ˜ 15.6 - 31.3 kHz) */
+	SS_MF_64  = (4 << 20),		/*!< Nss = 64 (fm ˜ 32.3 - 64.5 kHz) */
+	SS_MF_32  = (5 << 20),		/*!< Nss = 32 (fm ˜ 62.5- 125 kHz) */
+	SS_MF_24  = (6 << 20),		/*!< Nss ˜= 24 (fm ˜ 83.3- 166.6 kHz) */
+	SS_MF_16  = (7 << 20)		/*!< Nss = 16 (fm ˜ 125- 250 kHz) */
+} SS_PROGMODFM_T;
+
+/** @brief PLL Spread Spectrum (SS) Programmable frequency modulation depth
+ * See (MR) field in the SYSPLLSSCTRL1 register in the UM.
+ */
+typedef enum {
+	SS_MR_K0   = (0 << 23),		/*!< k = 0 (no spread spectrum) */
+	SS_MR_K1   = (1 << 23),		/*!< k = 1 */
+	SS_MR_K1_5 = (2 << 23),		/*!< k = 1.5 */
+	SS_MR_K2   = (3 << 23),		/*!< k = 2 */
+	SS_MR_K3   = (4 << 23),		/*!< k = 3 */
+	SS_MR_K4   = (5 << 23),		/*!< k = 4 */
+	SS_MR_K6   = (6 << 23),		/*!< k = 6 */
+	SS_MR_K8   = (7 << 23)		/*!< k = 8 */
+} SS_PROGMODDP_T;
+
+/** @brief PLL Spread Spectrum (SS) Modulation waveform control
+ * See (MC) field in the SYSPLLSSCTRL1 register in the UM.<br>
+ * Compensation for low pass filtering of the PLL to get a triangular
+ * modulation at the output of the PLL, giving a flat frequency spectrum.
+ */
+typedef enum {
+	SS_MC_NOC  = (0 << 26),		/*!< no compensation */
+	SS_MC_RECC = (2 << 26),		/*!< recommended setting */
+	SS_MC_MAXC = (3 << 26),		/*!< max. compensation */
+} SS_MODWVCTRL_T;
+
+/** @brief PLL configuration structure
+ * This structure can be used to configure the settings for a PLL
+ * setup structure. Fill in the desired configuration for the PLL
+ * and call the PLL setup function to fill in a PLL setup structure.
+ */
+typedef struct {
+	uint32_t        desiredRate;	/*!< Desired PLL rate in Hz */
+	uint32_t        InputRate;		/*!< PLL input clock in Hz, only used if PLL_CONFIGFLAG_USEINRATE flag is set */
+	uint32_t        flags;			/*!< PLL configuration flags, Or'ed value of PLL_CONFIGFLAG_* definitions */
+	SS_PROGMODFM_T  ss_mf;			/*!< SS Programmable modulation frequency, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
+	SS_PROGMODDP_T  ss_mr;			/*!< SS Programmable frequency modulation depth, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
+	SS_MODWVCTRL_T  ss_mc;			/*!< SS Modulation waveform control, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
+	bool            mfDither;		/*!< false for fixed modulation frequency or true for dithering, only applicable when not using PLL_CONFIGFLAG_FORCENOFRACT flag */
+} PLL_CONFIG_T;
+
+/** @brief PLL setup structure flags for 'flags' field
+ * These flags control how the PLL setup function sets up the PLL
+ */
+#define PLL_SETUPFLAG_POWERUP       (1 << 0)	/*!< Setup will power on the PLL after setup */
+#define PLL_SETUPFLAG_WAITLOCK      (1 << 1)	/*!< Setup will wait for PLL lock, implies the PLL will be pwoered on */
+#define PLL_SETUPFLAG_ADGVOLT       (1 << 2)	/*!< Optimize system voltage for the new PLL rate */
+
+/** @brief PLL setup structure
+ * This structure can be used to pre-build a PLL setup configuration
+ * at run-time and quickly set the PLL to the configuration. It can be
+ * populated with the PLL setup function. If powering up or waiting
+ * for PLL lock, the PLL input clock source should be configured prior
+ * to PLL setup.
+ */
+typedef struct {
+	uint32_t    flags;				/*!< PLL setup flags, Or'ed value of PLL_SETUPFLAG_* definitions */
+	uint32_t    SYSPLLCTRL;			/*!< PLL control register */
+	uint32_t    SYSPLLNDEC;			/*!< PLL NDEC register */
+	uint32_t    SYSPLLPDEC;			/*!< PLL PDEC register */
+	uint32_t    SYSPLLSSCTRL[2];	/*!< PLL SSCTL registers */
+} PLL_SETUP_T;
+
+/** @brief PLL status definitions
+ */
+typedef enum {
+	PLL_ERROR_SUCCESS = 0,			/*!< PLL operation was successful */
+	PLL_ERROR_OUTPUT_TOO_LOW,		/*!< PLL output rate request was too low */
+	PLL_ERROR_OUTPUT_TOO_HIGH,		/*!< PLL output rate request was too high */
+	PLL_ERROR_INPUT_TOO_LOW,		/*!< PLL input rate is too low */
+	PLL_ERROR_INPUT_TOO_HIGH,		/*!< PLL input rate is too high */
+	PLL_ERROR_OUTSIDE_INTLIMIT		/*!< Requested output rate isn't possible */
+} PLL_ERROR_T;
+
+/**
+ * @brief	Return System PLL output clock rate from setup structure
+ * @param	pSetup	: Pointer to a PLL setup structure
+ * @return	System PLL output clock rate the setup structure will generate
+ */
+uint32_t Chip_Clock_GetSystemPLLOutFromSetup(PLL_SETUP_T *pSetup);
+
+/**
+ * @brief	Set PLL output based on the passed PLL setup data
+ * @param	pControl	: Pointer to populated PLL control structure to generate setup with
+ * @param	pSetup		: Pointer to PLL setup structure to be filled
+ * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
+ * @note	Actual frequency for setup may vary from the desired frequency based on the
+ * accuracy of input clocks, rounding, non-fractional PLL mode, etc.
+ */
+PLL_ERROR_T Chip_Clock_SetupPLLData(PLL_CONFIG_T *pControl, PLL_SETUP_T *pSetup);
+
+/**
+ * @brief	Set PLL output from PLL setup structure (precise frequency)
+ * @param	pSetup	: Pointer to populated PLL setup structure
+ * @return	PLL_ERROR_SUCCESS on success, or PLL setup error code
+ * @note	This function will power off the PLL, setup the PLL with the
+ * new setup data, and then optionally powerup the PLL, wait for PLL lock,
+ * and adjust system voltages to the new PLL rate. The function will not
+ * alter any source clocks (ie, main systen clock) that may use the PLL,
+ * so these should be setup prior to and after exiting the function.
+ */
+PLL_ERROR_T Chip_Clock_SetupSystemPLLPrec(PLL_SETUP_T *pSetup);
+
+/**
+ * @brief	Set PLL output based on the multiplier and input frequency
+ * @param	multiply_by	: multiplier
+ * @param	input_freq	: Clock input frequency of the PLL
+ * @return	Nothing
+ * @note	Unlike the Chip_Clock_SetupSystemPLLPrec() function, this
+ * function does not disable or enable PLL power, wait for PLL lock,
+ * or adjust system voltages. These must be done in the application.
+ * The function will not alter any source clocks (ie, main systen clock)
+ * that may use the PLL, so these should be setup prior to and after
+ * exiting the function.
+ */
+void Chip_Clock_SetupSystemPLL(uint32_t multiply_by, uint32_t input_freq);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PLL_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/pmu_5410x.h ./chip/inc/pmu_5410x.h
--- a_tnusFF/chip/inc/pmu_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/pmu_5410x.h	2016-10-22 23:17:43.560840278 -0300
@@ -0,0 +1,184 @@
+/*
+ * @brief LPC5410X Power Management declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __PMU_5410X_H_
+#define __PMU_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup PMU_5410X CHIP: LPC5410X Power Management declarations and functions
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief PMU register block structure
+ * @note Most of the PMU support is handled by the PMU library.
+ */
+typedef struct {
+	__I  uint32_t RESERVED0[4];
+	__I  uint32_t RESERVED1[4];
+	__I  uint32_t RESERVED2[4];
+	__I  uint32_t RESERVED3[4];
+	__I  uint32_t RESERVED4;
+	__IO uint32_t BODCTRL;
+	__I  uint32_t RESERVED5;
+	__I  uint32_t RESERVED6;
+	__IO uint32_t DPDWAKESRC;
+} LPC_PMU_T;
+
+/**
+ * Brown-out detector reset level
+ */
+typedef enum {
+	PMU_BODRSTLVL_0,	/*!< Brown-out reset at ~1.5v */
+	PMU_BODRSTLVL_1_50V = PMU_BODRSTLVL_0,
+	PMU_BODRSTLVL_1,	/*!< Brown-out reset at ~1.85v */
+	PMU_BODRSTLVL_1_85V = PMU_BODRSTLVL_1,
+	PMU_BODRSTLVL_2,	/*!< Brown-out reset at ~2.0v */
+	PMU_BODRSTLVL_2_00V = PMU_BODRSTLVL_2,
+	PMU_BODRSTLVL_3,	/*!< Brown-out reset at ~2.3v */
+	PMU_BODRSTLVL_2_30V = PMU_BODRSTLVL_3
+} CHIP_PMU_BODRSTLVL_T;
+
+/**
+ * Brown-out detector interrupt level
+ */
+typedef enum CHIP_PMU_BODRINTVAL {
+	PMU_BODINTVAL_LVL0,	/*!< Brown-out interrupt at ~2.05v */
+	PMU_BODINTVAL_2_05v = PMU_BODINTVAL_LVL0,
+	PMU_BODINTVAL_LVL1,	/*!< Brown-out interrupt at ~2.45v */
+	PMU_BODINTVAL_2_45v = PMU_BODINTVAL_LVL1,
+	PMU_BODINTVAL_LVL2,	/*!< Brown-out interrupt at ~2.75v */
+	PMU_BODINTVAL_2_75v = PMU_BODINTVAL_LVL2,
+	PMU_BODINTVAL_LVL3,	/*!< Brown-out interrupt at ~3.05v */
+	PMU_BODINTVAL_3_05v = PMU_BODINTVAL_LVL3
+} CHIP_PMU_BODRINTVAL_T;
+
+/**
+ * brown-out detection reset status (in BODCTRL register)
+ */
+#define PMU_BOD_RST     (1 << 6)
+/**
+ * brown-out detection interrupt status (in BODCTRL register)
+ */
+#define PMU_BOD_INT     (1 << 7)
+
+/**
+ * @brief	Set brown-out detection interrupt and reset levels
+ * @param	rstlvl	: Brown-out detector reset level
+ * @param	intlvl	: Brown-out interrupt level
+ * @return	Nothing
+ * @note	Brown-out detection reset will be disabled upon exiting this function.
+ * Use Chip_PMU_EnableBODReset() to re-enable.
+ */
+__STATIC_INLINE void Chip_PMU_SetBODLevels(CHIP_PMU_BODRSTLVL_T rstlvl,
+										   CHIP_PMU_BODRINTVAL_T intlvl)
+{
+	LPC_PMU->BODCTRL = ((uint32_t) rstlvl) | (((uint32_t) intlvl) << 2);
+}
+
+/**
+ * @brief	Enable brown-out detection reset
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PMU_EnableBODReset(void)
+{
+	LPC_PMU->BODCTRL |= (1 << 4);
+}
+
+/**
+ * @brief	Disable brown-out detection reset
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PMU_DisableBODReset(void)
+{
+	LPC_PMU->BODCTRL &= ~(1 << 4);
+}
+
+/**
+ * @brief	Enable brown-out detection interrupt
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PMU_EnableBODInt(void)
+{
+	LPC_PMU->BODCTRL |= (1 << 5);
+}
+
+/**
+ * @brief	Disable brown-out detection interrupt
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PMU_DisableBODInt(void)
+{
+	LPC_PMU->BODCTRL &= ~(1 << 5);
+}
+
+/**
+ * Deep power down reset sources
+ */
+#define PMU_DPDWU_RESET     (1 << 0)	/*!< Deep powerdown wakeup by reset pin */
+#define PMU_DPDWU_RTC       (1 << 1)	/*!< Deep powerdown wakeup by RTC */
+#define PMU_DPDWU_BODRESET  (1 << 2)	/*!< Deep powerdown wakeup by brown out reset*/
+#define PMU_DPDWU_BODINTR   (1 << 3)	/*!< Deep powerdown wakeup by brown out interrupt */
+
+/**
+ * @brief	Return wakeup sources from deep power down mode
+ * @return	Deep power down mode wakeup sources
+ * @note	Mask the return value with a PMU_DPDWU_* value to determine
+ * the wakeup source from deep power down.
+ */
+__STATIC_INLINE uint32_t Chip_PMU_GetDPDWUSource(void)
+{
+	return LPC_PMU->DPDWAKESRC;
+}
+
+/**
+ * @brief	Clear a deep power down mode wakeup source
+ * @param	mask	: Or'ed PMU_DPDWU_* values to clear
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_PMU_ClearDPDWUSource(uint32_t mask)
+{
+	LPC_PMU->DPDWAKESRC = mask;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __PMU_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/power_lib_5410x.h ./chip/inc/power_lib_5410x.h
--- a_tnusFF/chip/inc/power_lib_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/power_lib_5410x.h	2016-10-22 23:17:43.564840278 -0300
@@ -0,0 +1,281 @@
+/*
+ * @brief LPC5410x Power library functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __POWER_LIB_5410X_H_
+#define __POWER_LIB_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup POWER_LIBRARY_5410X CHIP: LPC5410X Power LIBRARY functions
+ * The power library provides functions to control system power usage and
+ * place the device into low power modes.<br>
+ *
+ * <b>Clock shutdown in sleep and power down modes</b><br>
+ * When using the Chip_POWER_EnterPowerMode() function, system clocks are
+ * shutdown based on the selected sleep or power down mode and the device
+ * version being used. The following list details which clocks are shut down
+ * in which modes for which device versions. You can keep a clock enabled
+ * for a sleep or power down mode by enabling it in the 'peripheral_ctrl'
+ * field in the Chip_POWER_EnterPowerMode() function.<br>
+ *
+ * Mode: Sleep<br>
+ * No clocks are disabled for any chip version.<br>
+ *
+ * Mode: Deep sleep<br>
+ * SYSCON_PDRUNCFG_PD_IRC_OSC<br>
+ * SYSCON_PDRUNCFG_PD_IRC<br>
+ * SYSCON_PDRUNCFG_PD_FLASH (v17.1 and later only)<br>
+ * SYSCON_PDRUNCFG_PD_BOD_INTR<br>
+ * SYSCON_PDRUNCFG_PD_ADC0<br>
+ * SYSCON_PDRUNCFG_PD_ROM<br>
+ * SYSCON_PDRUNCFG_PD_VDDA_ENA<br>
+ * SYSCON_PDRUNCFG_PD_SYS_PLL<br>
+ * SYSCON_PDRUNCFG_PD_VREFP<br>
+ *
+ * Mode: Power down<br>
+ * SYSCON_PDRUNCFG_PD_IRC_OSC<br>
+ * SYSCON_PDRUNCFG_PD_IRC<br>
+ * SYSCON_PDRUNCFG_PD_FLASH (v17.1 and later only)<br>
+ * SYSCON_PDRUNCFG_PD_BOD_RST<br>
+ * SYSCON_PDRUNCFG_PD_BOD_INTR<br>
+ * SYSCON_PDRUNCFG_PD_ADC0<br>
+ * SYSCON_PDRUNCFG_PD_SRAM0B<br>
+ * SYSCON_PDRUNCFG_PD_SRAM1<br>
+ * SYSCON_PDRUNCFG_PD_SRAM2<br>
+ * SYSCON_PDRUNCFG_PD_ROM<br>
+ * SYSCON_PDRUNCFG_PD_VDDA_ENA<br>
+ * SYSCON_PDRUNCFG_PD_WDT_OSC<br>
+ * SYSCON_PDRUNCFG_PD_SYS_PLL<br>
+ * SYSCON_PDRUNCFG_PD_VREFP<br>
+ * SYSCON_PDRUNCFG_PD_32K_OSC<br>
+ *
+ * Mode: Deep power down<br>
+ * All clocks are disabled for all chip versions.<br>
+ *
+ * If you are using a peripheral was a wakeup source for a power down mode,
+ * it needs to be kept active with the call to Chip_POWER_EnterPowerMode(). For
+ * example, if you are using the RTC to wake the system up from power down mode,
+ * the 32KHz RTC oscillator needs to remain active, so the power down call would
+ * look like this:<br>
+ * Chip_POWER_EnterPowerMode(POWER_POWER_DOWN, SYSCON_PDRUNCFG_PD_32K_OSC);<br>
+ * If your application uses internal RAM beyond the first 8K, you will also need
+ * to prevent power down of the IRAM like this:<br>
+ * Chip_POWER_EnterPowerMode(POWER_POWER_DOWN, (SYSCON_PDRUNCFG_PD_32K_OSC | SYSCON_PDRUNCFG_PD_SRAM0A));<br>
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+// Saved in case they need to be re-installed publicly later
+/* Power domains */
+typedef enum  {
+	POWER_VD1 = 0x0,
+	POWER_VD2 = 0x1,
+	POWER_VD3 = 0x2,
+	POWER_VD8 = 0x3
+} POWER_DOMAIN_T;
+
+/* Power coarse voltage levels */
+typedef enum {
+	POWER_V0650 = 0x0,
+	POWER_V0700 = 0x1,
+	POWER_V0750 = 0x2,
+	POWER_V0800 = 0x3,
+	POWER_V0850 = 0x4,
+	POWER_V0900 = 0x5,
+	POWER_V0950 = 0x6,
+	POWER_V1000 = 0x7,
+	POWER_V1050 = 0x8,
+	POWER_V1100 = 0x9,
+	POWER_V1150 = 0xA,
+	POWER_V1200 = 0xB,
+	POWER_V1250 = 0xC,
+	POWER_V1300 = 0xD,
+	POWER_V1350 = 0xE,
+	POWER_V1400 = 0xF
+}  POWER_VOLTAGELEVEL_T;
+
+/* Power fine voltage levels */
+typedef enum {
+	POWER_FINE_V_NONE = 0x0,
+	POWER_FINE_V_M025 = 0x1,
+	POWER_FINE_V_P025 = 0x3
+} POWER_FINEVOLTAGELEVEL_T;
+
+/* Low power voltage selection */
+typedef enum {
+	POWER_LP_V0700 = 0x0,
+	POWER_LP_V1200 = 0x1
+}  POWER_LPVOLTAGELEVEL_T;
+
+/* Low power fine voltage selection */
+typedef enum {
+	POWER_FINE_LP_V_M050  = 0x0,
+	POWER_FINE_LP_V_NONE  = 0x1,
+	POWER_FINE_LP_V_P050  = 0x2,
+	POWER_FINE_LP_V_P100  = 0x3
+} POWER_LPFINEVOLTAGELEVEL_T;
+
+/* 'mode' input values to set_voltage ROM function */
+typedef enum {
+	POWER_LOW_POWER_MODE = 0,
+	POWER_BALANCED_MODE,
+	POWER_HIGH_PERFORMANCE
+} PERF_MODE_T;
+
+/* 'mode' input values to power_mode_configure ROM function */
+typedef enum {
+	POWER_SLEEP = 0,
+	POWER_DEEP_SLEEP,
+	POWER_POWER_DOWN,
+	POWER_DEEP_POWER_DOWN
+} POWER_MODE_T;
+
+/**
+ * @brief	Sets up the System PLL given the PLL input frequency and feedback multiplier
+ * @param	multiply_by	: PLL multiplier, minimum of 1, maximum of 16
+ * @param	input_freq	: Input frequency into the PLL
+ * @return	LPC_OK on success, or an error code (see error.h)
+ */
+uint32_t Chip_POWER_SetPLL(uint32_t multiply_by, uint32_t input_freq);
+
+/**
+ * @brief	Turn flash power on / off
+ * @param	new_power_mode	: 0 = power off, != 0 = power on
+ * @return	nothing
+ */
+void Chip_POWER_SetFLASHPower(uint32_t new_power_mode);
+
+/**
+ * @brief	Set optimal system voltage based on passed system frequency
+ * @param	mode			: Power mode
+ * @param	desired_freq	: System (CPU) frequency
+ * @return	LPC_OK on success, or an error code (see error.h)
+ * @note	This function will adjust the system voltages to the lowest
+ * levels that will support the passed mode and CPU frequency.
+ */
+uint32_t Chip_POWER_SetVoltage(PERF_MODE_T mode, uint32_t desired_freq);
+
+/**
+ * @brief	Set voltage levels on individual voltage domains
+ * @param	domain	: Power domain
+ * @param	level	: Coarse voltage level
+ * @param	flevel	: Fine voltage level
+ * @return	Nothing
+ */
+uint32_t Chip_POWER_SetVDLevel(POWER_DOMAIN_T domain, POWER_VOLTAGELEVEL_T level, POWER_FINEVOLTAGELEVEL_T flevel);
+
+/**
+ * @brief	Set low-power voltage levels for LP mode
+ * @return	Nothing
+ */
+void Chip_POWER_SetLPVDLevel(void);
+
+/**
+ * @brief	Enters the selected power state
+ * @param	mode			: Power mode
+ * @param	peripheral_ctrl	: Peripherals that will remain powered up in the power state
+ * @return	Nothing
+ * @note	The 'peripheral_ctrl' field is a bitmask of bits from the
+ * PDRUNCFG register (SYSCON_PDRUNCFG_PD_*) that describe which
+ * peripherals can wake up the chip from the power state. These
+ * peripherals are not powered down during the power state.<br>
+ */
+void Chip_POWER_EnterPowerMode(POWER_MODE_T mode, uint32_t peripheral_ctrl);
+
+/**
+ * @brief	Enters the selected power state (Relocated)
+ * @param	mode			: Power mode
+ * @param	peripheral_ctrl	: Peripherals that will remain powered up in the power state
+ * @param	relMem			: Address of the memory where relocated power function is [see Chip_POWER_RelocAPI()]
+ * @return	Nothing
+ * @note	This API is to be used when the powerdown mode [ @a mode is #POWER_POWER_DOWN ] is to be entered from flash.
+ * Since powerdown mode turns off the flash memory the powerdown API, if executed from flash, can be relocated to RAM
+ * using Chip_POWER_RelocAPI(), and powerdown mode can be entered using this API. @a relMem should be the pointer to the
+ * memory used when calling Chip_POWER_RelocAPI(). For all power modes other than
+ * #POWER_POWER_DOWN this API works exactly same as Chip_POWER_EnterPowerMode() API and @a relMem can be 0.<br>
+ */
+void Chip_POWER_EnterPowerModeReloc(POWER_MODE_T mode, uint32_t peripheral_ctrl, uint32_t relMem);
+
+/**
+ * @brief	Relocate the PowerDown code to given memory
+ *
+ * When executing from flash, entering PowerDown mode is not possible as the PowerDown mode turns
+ * off the flash. This function will relocate the powerdown code to memory allocated in RAM and this
+ * relocated function can be invoked using Chip_POWER_EnterPowerModeReloc() hence entering powerdown
+ * mode from RAM and let the flash power be turned off.
+ *
+ * @param	relMem	: Memory where the function to be relocated [Needs to be word aligned]
+ * @param	size	: Size of the memory in Bytes
+ * @return	Nothing
+ */
+void Chip_POWER_RelocAPI(uint32_t *relMem, uint32_t size);
+
+/* ROM versions */
+#define LPC5410X_ROMVER_0   (0x1100)
+#define LPC5410X_ROMVER_1   (0x1101)
+#define LPC5410X_ROMVER_2   (0x1102)
+
+/**
+ * @brief	Fast powerdown for IRAM based applications
+ * @param	peripheral_ctrl	: Peripherals that will remain powered up in the power down state
+ * @return	Nothing
+ * @note	The 'peripheral_ctrl' field is a bitmask of bits from the
+ * PDRUNCFG register (SYSCON_PDRUNCFG_PD_*) that describe which
+ * peripherals can wake up the chip from the power state. These
+ * peripherals are not powered down during the power state.<br>
+ * This function should only be used when not executing code in FLASH.
+ * It will power down FLASH and leave it powered down on exit, so all
+ * code should be placed in IRAM prior to calling. It provides a quicker
+ * wakeup response than the default powerdown function
+ * (Chip_POWER_EnterPowerMode(POWER_POWER_DOWN, ...)).
+ */
+void Chip_POWER_EnterPowerModeIramOnly(uint32_t peripheral_ctrl);
+
+/**
+ * @brief	Return ROM version
+ * @return	ROM version
+ * @note	Will return one of the following version numbers:<br>
+ * (0x1100) for v17.0 ROMs.<br>
+ * (0x1101) for v17.1 ROMs.<br>
+ * (0x1102) for v17.2 ROMs.<br>
+ */
+uint32_t Chip_POWER_GetROMVersion(void);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __POWER_LIB_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/ring_buffer.h ./chip/inc/ring_buffer.h
--- a_tnusFF/chip/inc/ring_buffer.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/ring_buffer.h	2016-10-22 23:17:43.564840278 -0300
@@ -0,0 +1,194 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RING_BUFFER_H_
+#define __RING_BUFFER_H_
+
+#include "lpc_types.h"
+#include "cmsis.h"
+
+/** @defgroup Ring_Buffer CHIP: Simple ring buffer implementation
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief Ring buffer structure
+ */
+typedef struct {
+	void *data;
+	int count;
+	int itemSz;
+	uint32_t head;
+	uint32_t tail;
+	void *(*copy)(void *dst, const void *src, uint32_t len);
+} RINGBUFF_T;
+
+/**
+ * @def		RB_VHEAD(rb)
+ * volatile typecasted head index
+ */
+#define RB_VHEAD(rb)              (*(volatile uint32_t *) &(rb)->head)
+
+/**
+ * @def		RB_VTAIL(rb)
+ * volatile typecasted tail index
+ */
+#define RB_VTAIL(rb)              (*(volatile uint32_t *) &(rb)->tail)
+
+/**
+ * @brief	Initialize ring buffer
+ * @param	RingBuff	: Pointer to ring buffer to initialize
+ * @param	buffer		: Pointer to buffer to associate with RingBuff
+ * @param	itemSize	: Size of each buffer item size
+ * @param	count		: Size of ring buffer
+ * @param	cpyFunc		: Call-back function that copies data (if NULL library @a memcpy will be used)
+ * @note	Memory pointed by @a buffer must have correct alignment of
+ *          @a itemSize, and @a count must be a power of 2 and must at
+ *          least be 2 or greater. @a len of the @a cpyFunc is in bytes.
+ * @return	Nothing
+ */
+int RingBuffer_Init(RINGBUFF_T *RingBuff,
+					void *buffer,
+					int itemSize,
+					int count,
+					void *(*cpyFunc)(void *dst, const void *src, uint32_t len));
+
+/**
+ * @brief	Resets the ring buffer to empty
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Nothing
+ */
+__STATIC_INLINE void RingBuffer_Flush(RINGBUFF_T *RingBuff)
+{
+	RingBuff->head = RingBuff->tail = 0;
+}
+
+/**
+ * @brief	Return size the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Size of the ring buffer in bytes
+ */
+__STATIC_INLINE int RingBuffer_GetSize(RINGBUFF_T *RingBuff)
+{
+	return RingBuff->count;
+}
+
+/**
+ * @brief	Return number of items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Number of items in the ring buffer
+ */
+__STATIC_INLINE int RingBuffer_GetCount(RINGBUFF_T *RingBuff)
+{
+	return RB_VHEAD(RingBuff) - RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief	Return number of free items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	Number of free items in the ring buffer
+ */
+__STATIC_INLINE int RingBuffer_GetFree(RINGBUFF_T *RingBuff)
+{
+	return RingBuff->count - RingBuffer_GetCount(RingBuff);
+}
+
+/**
+ * @brief	Return number of items in the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	1 if the ring buffer is full, otherwise 0
+ */
+__STATIC_INLINE int RingBuffer_IsFull(RINGBUFF_T *RingBuff)
+{
+	return RingBuffer_GetCount(RingBuff) >= RingBuff->count;
+}
+
+/**
+ * @brief	Return empty status of ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @return	1 if the ring buffer is empty, otherwise 0
+ */
+__STATIC_INLINE int RingBuffer_IsEmpty(RINGBUFF_T *RingBuff)
+{
+	return RB_VHEAD(RingBuff) == RB_VTAIL(RingBuff);
+}
+
+/**
+ * @brief	Insert a single item into ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: pointer to item
+ * @return	1 when successfully inserted,
+ *			0 on error (Buffer not initialized using
+ *			RingBuffer_Init() or attempted to insert
+ *			when buffer is full)
+ */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data);
+
+/**
+ * @brief	Insert an array of items into ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to first element of the item array
+ * @param	num			: Number of items in the array
+ * @return	number of items successfully inserted,
+ *			0 on error (Buffer not initialized using
+ *			RingBuffer_Init() or attempted to insert
+ *			when buffer is full)
+ */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num);
+
+/**
+ * @brief	Pop an item from the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to memory where popped item be stored
+ * @return	1 when item popped successfuly onto @a data,
+ *          0 When error (Buffer not initialized using
+ *          RingBuffer_Init() or attempted to pop item when
+ *          the buffer is empty)
+ */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data);
+
+/**
+ * @brief	Pop an array of items from the ring buffer
+ * @param	RingBuff	: Pointer to ring buffer
+ * @param	data		: Pointer to memory where popped items be stored
+ * @param	num			: Max number of items array @a data can hold
+ * @return	Number of items popped onto @a data,
+ *          0 on error (Buffer not initialized using RingBuffer_Init()
+ *          or attempted to pop when the buffer is empty)
+ */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num);
+
+/**
+ * @}
+ */
+
+#endif /* __RING_BUFFER_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/ritimer_5410x.h ./chip/inc/ritimer_5410x.h
--- a_tnusFF/chip/inc/ritimer_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/ritimer_5410x.h	2016-10-22 23:17:43.564840278 -0300
@@ -0,0 +1,249 @@
+/*
+ * @brief LPC5410x RITimer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RITIMER_5410X_H_
+#define __RITIMER_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RITIMER_5410X CHIP: LPC5410X Repetitive Interrupt Timer driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief Repetitive Interrupt Timer register block structure
+ */
+typedef struct {				/*!< RITIMER Structure */
+	__IO uint32_t  COMPVAL;		/*!< Compare register */
+	__IO uint32_t  MASK;		/*!< Mask register */
+	__IO uint32_t  CTRL;		/*!< Control register */
+	__IO uint32_t  COUNTER;		/*!< 32-bit counter */
+	__IO uint32_t  COMPVAL_H;	/*!< Compare register, upper 16-bits */
+	__IO uint32_t  MASK_H;		/*!< Compare register, upper 16-bits */
+	__I  uint32_t  reserved;
+	__IO uint32_t  COUNTER_H;	/*!< Counter register, upper 16-bits */
+} LPC_RITIMER_T;
+
+/*
+ * @brief RITIMER register support bitfields and mask
+ */
+
+/*
+ * RIT control register
+ */
+/**	Set by H/W when the counter value equals the masked compare value */
+#define RIT_CTRL_INT    ((uint32_t) (1))
+/** Set timer enable clear to 0 when the counter value equals the masked compare value  */
+#define RIT_CTRL_ENCLR  ((uint32_t) _BIT(1))
+/** Set timer enable on debug */
+#define RIT_CTRL_ENBR   ((uint32_t) _BIT(2))
+/** Set timer enable */
+#define RIT_CTRL_TEN    ((uint32_t) _BIT(3))
+
+/**
+ * @brief	Initialize the RIT
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Shutdown the RIT
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Enable Timer
+ * @param	pRITimer		: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_Enable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_TEN;
+}
+
+/**
+ * @brief	Disable Timer
+ * @param	pRITimer		: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_Disable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL &= ~RIT_CTRL_TEN;
+}
+
+/**
+ * @brief	Enable timer debug
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_DebugEnable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief	Disable timer debug
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_DebugDisable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL &= ~RIT_CTRL_ENBR;
+}
+
+/**
+ * @brief	Enable clear on compare match
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_CompClearEnable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_ENCLR;
+}
+
+/**
+ * @brief	Disable clear on compare match
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_CompClearDisable(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL &= ~RIT_CTRL_ENCLR;
+}
+
+/**
+ * @brief	Check whether interrupt flag is set or not
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	Current interrupt status, either ET or UNSET
+ */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer);
+
+/**
+ * @brief	Set a tick value for the interrupt to time out
+ * @param	pRITimer	: RITimer peripheral selected
+ * @param	val			: value (in ticks) of the interrupt to be set
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_SetCOMPVAL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+	pRITimer->COMPVAL = val;
+	pRITimer->COMPVAL_H = 0;
+}
+
+/**
+ * @brief	Set a tick value for the interrupt to time out (48-bits)
+ * @param	pRITimer	: RITimer peripheral selected
+ * @param	val			: value (in ticks) of the interrupt to be set, 48-bits max
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_SetCOMPVAL64(LPC_RITIMER_T *pRITimer, uint64_t val)
+{
+	pRITimer->COMPVAL = (uint32_t) (val & 0xFFFFFFFF);
+	pRITimer->COMPVAL_H = (uint32_t) ((val >> 32) & 0xFFFF);
+}
+
+/**
+ * @brief	Enables or clears the RIT or interrupt
+ * @param	pRITimer	: RITimer peripheral selected
+ * @param	val			: RIT to be set, one or more RIT_CTRL_* values
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_EnableCTRL(LPC_RITIMER_T *pRITimer, uint32_t val)
+{
+	pRITimer->CTRL |= val;
+}
+
+/**
+ * @brief	Clears the RIT interrupt
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RIT_ClearInt(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL |= RIT_CTRL_INT;
+}
+
+/**
+ * @brief	Returns the current RIT Counter value
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	the current timer counter value
+ */
+__STATIC_INLINE uint32_t Chip_RIT_GetCounter(LPC_RITIMER_T *pRITimer)
+{
+	return pRITimer->COUNTER;
+}
+
+/**
+ * @brief	Returns the current RIT Counter value (48-bit)
+ * @param	pRITimer	: RITimer peripheral selected
+ * @return	the current timer counter value
+ */
+__STATIC_INLINE uint64_t Chip_RIT_GetCounter64(LPC_RITIMER_T *pRITimer)
+{
+	uint64_t retVal;
+
+	retVal = (uint64_t) pRITimer->COUNTER;
+	retVal = retVal | (((uint64_t) pRITimer->COUNTER_H) << 32);
+
+	return retVal;
+}
+
+/**
+ * @brief	Set timer interval value
+ * @param	pRITimer		: RITimer peripheral selected
+ * @param	time_interval	: timer interval value (ms)
+ * @return	None
+ */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval);
+
+/**
+ * @brief	Set timer interval value (48-bit)
+ * @param	pRITimer		: RITimer peripheral selected
+ * @param	time_interval	: timer interval value (ms)
+ * @return	None
+ */
+void Chip_RIT_SetTimerInterval64(LPC_RITIMER_T *pRITimer, uint64_t time_interval);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RITIMER_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/romapi_5410x.h ./chip/inc/romapi_5410x.h
--- a_tnusFF/chip/inc/romapi_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/romapi_5410x.h	2016-10-22 23:23:38.052849771 -0300
@@ -0,0 +1,90 @@
+/*
+ * @brief LPC5410X ROM API declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __ROMAPI_5410X_H_
+#define __ROMAPI_5410X_H_
+
+#include <stdint.h>
+#include "iap.h"
+#include "error.h"
+#include "cmsis.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup ROMAPI_5410X CHIP: LPC5410X ROM API declarations and functions
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief High level ROM API structure
+ */
+typedef struct {
+	const uint32_t reserved_usb;				/*!< Reserved */
+	const uint32_t reserved_clib;				/*!< Reserved */
+	const uint32_t reserved_can;				/*!< Reserved */
+	const uint32_t reserved_pwrd;				/*!< Reserved */
+	const uint32_t reserved_div;				/*!< Reserved */
+	const uint32_t reserved_i2cd;				/*!< Reserved */
+	const uint32_t reserved_dmad;				/*!< Reserved */
+	const uint32_t reserved_spid;				/*!< Reserved */
+	const uint32_t reserved_adcd;				/*!< Reserved */
+	const uint32_t reserved_uartd;				/*!< Reserved */
+	const uint32_t reserved_vfifo;				/*!< Reserved */
+	const uint32_t reserved_usart;				/*!< Reserved */
+} LPC_ROM_API_T;
+
+/* Pointer to ROM API function address */
+#define LPC_ROM_API_BASE_LOC    0x03000200UL
+#define LPC_ROM_API     (*(LPC_ROM_API_T * *) LPC_ROM_API_BASE_LOC)
+
+/* Pointer to ROM IAP entry functions */
+#define IAP_ENTRY_LOCATION        0x03000205
+
+/**
+ * @brief LPC5410x IAP_ENTRY API function type
+ */
+static INLINE void iap_entry(unsigned int cmd_param[5], unsigned int status_result[4])
+{
+	((IAP_ENTRY_T) IAP_ENTRY_LOCATION)(cmd_param, status_result);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __ROMAPI_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/rtc_5410x.h ./chip/inc/rtc_5410x.h
--- a_tnusFF/chip/inc/rtc_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/rtc_5410x.h	2016-10-22 23:17:43.568840278 -0300
@@ -0,0 +1,310 @@
+/*
+ * @brief LPC5410X RTC chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RTC_5410X_H_
+#define __RTC_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RTC_5410X CHIP: LPC5410X Real Time clock
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X Real Time clock register block structure
+ */
+typedef struct {			/*!< RTC */
+	__IO uint32_t CTRL;		/*!< RTC control register */
+	__IO uint32_t MATCH;	/*!< PRTC match (alarm) register */
+	__IO uint32_t COUNT;	/*!< RTC counter register */
+	__IO uint32_t WAKE;		/*!< RTC high-resolution/wake-up timer control register */
+} LPC_RTC_T;
+
+/* CTRL register defniitions */
+#define RTC_CTRL_SWRESET        (1 << 0)	/*!< Apply reset to RTC */
+#define RTC_CTRL_OFD            (1 << 1)	/*!< Oscillator fail detect status (failed bit) */
+#define RTC_CTRL_ALARM1HZ       (1 << 2)	/*!< RTC 1 Hz timer alarm flag status (match) bit */
+#define RTC_CTRL_WAKE1KHZ       (1 << 3)	/*!< RTC 1 kHz timer wake-up flag status (timeout) bit */
+#define RTC_CTRL_ALARMDPD_EN    (1 << 4)	/*!< RTC 1 Hz timer alarm for Deep power-down enable bit */
+#define RTC_CTRL_WAKEDPD_EN     (1 << 5)	/*!< RTC 1 kHz timer wake-up for Deep power-down enable bit */
+#define RTC_CTRL_RTC1KHZ_EN     (1 << 6)	/*!< RTC 1 kHz clock enable bit */
+#define RTC_CTRL_RTC_EN         (1 << 7)	/*!< RTC enable bit */
+#define RTC_CTRL_MASK           ((uint32_t) 0xF1)	/*!< RTC Control register Mask for reserved and status bits */
+
+/**
+ * @brief	Initialize the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RTC_Init(LPC_RTC_T *pRTC)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_RTC);
+	Chip_SYSCON_PeriphReset(RESET_RTC);
+}
+
+/**
+ * @brief	De-initialize the RTC peripheral
+ * @param	pRTC	: RTC peripheral selected
+ * @return	None
+ */
+__STATIC_INLINE void Chip_RTC_DeInit(LPC_RTC_T *pRTC)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_RTC);
+}
+
+/**
+ * @brief	Enable RTC options
+ * @param	pRTC	: The base address of RTC block
+ * @param	flags	: And OR'ed value of RTC_CTRL_* definitions to enable
+ * @return	Nothing
+ * @note	You can enable multiple RTC options at once using this function
+ *			by OR'ing them together. It is recommended to only use the
+ *			RTC_CTRL_ALARMDPD_EN, RTC_CTRL_WAKEDPD_EN, RTC_CTRL_RTC1KHZ_EN, and
+ *			RTC_CTRL_RTC_EN flags with this function.
+ */
+__STATIC_INLINE void Chip_RTC_EnableOptions(LPC_RTC_T *pRTC, uint32_t flags)
+{
+	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) | flags;
+}
+
+/**
+ * @brief	Disable RTC options
+ * @param	pRTC	: The base address of RTC block
+ * @param	flags	: And OR'ed value of RTC_CTRL_* definitions to disable
+ * @return	Nothing
+ * @note	You can enable multiple RTC options at once using this function
+ *			by OR'ing them together. It is recommended to only use the
+ *			RTC_CTRL_ALARMDPD_EN, RTC_CTRL_WAKEDPD_EN, RTC_CTRL_RTC1KHZ_EN, and
+ *			RTC_CTRL_RTC_EN flags with this function.
+ */
+__STATIC_INLINE void Chip_RTC_DisableOptions(LPC_RTC_T *pRTC, uint32_t flags)
+{
+	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) & ~flags;
+}
+
+/**
+ * @brief	Reset RTC
+ * @param	pRTC	: The base address of RTC block
+ * @return	Nothing
+ * @note	The RTC state will be returned to it's default.
+ */
+__STATIC_INLINE void Chip_RTC_Reset(LPC_RTC_T *pRTC)
+{
+	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_SWRESET);
+	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_SWRESET);
+}
+
+/**
+ * @brief	Enables the RTC
+ * @param	pRTC	: The base address of RTC block
+ * @return	Nothing
+ * @note	You can also use Chip_RTC_EnableOptions() with the
+ *			RTC_CTRL_RTC_EN flag to enable the RTC.
+ */
+__STATIC_INLINE void Chip_RTC_Enable(LPC_RTC_T *pRTC)
+{
+	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_RTC_EN);
+}
+
+/**
+ * @brief	Disables the RTC
+ * @param	pRTC	: The base address of RTC block
+ * @return	Nothing
+ * @note	You can also use Chip_RTC_DisableOptions() with the
+ *			RTC_CTRL_RTC_EN flag to enable the RTC.
+ */
+__STATIC_INLINE void Chip_RTC_Disable(LPC_RTC_T *pRTC)
+{
+	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_RTC_EN);
+}
+
+/**
+ * @brief	Enables the RTC 1KHz high resolution timer
+ * @param	pRTC	: The base address of RTC block
+ * @return	Nothing
+ * @note	You can also use Chip_RTC_EnableOptions() with the
+ *			RTC_CTRL_RTC1KHZ_EN flag to enable the high resolution
+ *			timer.
+ */
+__STATIC_INLINE void Chip_RTC_Enable1KHZ(LPC_RTC_T *pRTC)
+{
+	Chip_RTC_EnableOptions(pRTC, RTC_CTRL_RTC1KHZ_EN);
+}
+
+/**
+ * @brief	Disables the RTC 1KHz high resolution timer
+ * @param	pRTC	: The base address of RTC block
+ * @return	Nothing
+ * @note	You can also use Chip_RTC_DisableOptions() with the
+ *			RTC_CTRL_RTC1KHZ_EN flag to disable the high resolution
+ *			timer.
+ */
+__STATIC_INLINE void Chip_RTC_Disable1KHZ(LPC_RTC_T *pRTC)
+{
+	Chip_RTC_DisableOptions(pRTC, RTC_CTRL_RTC1KHZ_EN);
+}
+
+/**
+ * @brief	Enables selected RTC wakeup events
+ * @param	pRTC	: The base address of RTC block
+ * @param	ints	: Wakeup events to enable
+ * @return	Nothing
+ * @note	Select either one or both (OR'ed) RTC_CTRL_ALARMDPD_EN
+ *			and RTC_CTRL_WAKEDPD_EN values to enabled. You can also
+ *			use Chip_RTC_EnableOptions() with the flags to enable
+ *			the events.
+ */
+__STATIC_INLINE void Chip_RTC_EnableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
+{
+	Chip_RTC_EnableOptions(pRTC, ints);
+}
+
+/**
+ * @brief	Disables selected RTC wakeup events
+ * @param	pRTC	: The base address of RTC block
+ * @param	ints	: Wakeup events to disable
+ * @return	Nothing
+ * @note	Select either one or both (OR'ed) RTC_CTRL_ALARMDPD_EN
+ *			and RTC_CTRL_WAKEDPD_EN values to disabled. You can also
+ *			use Chip_RTC_DisableOptions() with the flags to disable
+ *			the events.
+ */
+__STATIC_INLINE void Chip_RTC_DisableWakeup(LPC_RTC_T *pRTC, uint32_t ints)
+{
+	Chip_RTC_DisableOptions(pRTC, ints);
+}
+
+/**
+ * @brief	Clears latched RTC statuses
+ * @param	pRTC	: The base address of RTC block
+ * @param	stsMask	: OR'ed status bits to clear
+ * @return	Nothing
+ * @note	Use and OR'ed stsMask value of RTC_CTRL_OFD, RTC_CTRL_ALARM1HZ,
+ *			and RTC_CTRL_WAKE1KHZ to clear specific RTC states.
+ */
+__STATIC_INLINE void Chip_RTC_ClearStatus(LPC_RTC_T *pRTC, uint32_t stsMask)
+{
+	pRTC->CTRL = (pRTC->CTRL & RTC_CTRL_MASK) | stsMask;
+}
+
+/**
+ * @brief	Return RTC control/status register
+ * @param	pRTC	: The base address of RTC block
+ * @return	The current RTC control/status register
+ * @note	Mask the return value with a RTC_CTRL_* definitions to determine
+ *			which bits are set. For example, mask the return value with
+ *			RTC_CTRL_ALARM1HZ to determine if the alarm interrupt is pending.
+ */
+__STATIC_INLINE uint32_t Chip_RTC_GetStatus(LPC_RTC_T *pRTC)
+{
+	return pRTC->CTRL;
+}
+
+/**
+ * @brief	Set RTC match value for alarm status/interrupt
+ * @param	pRTC	: The base address of RTC block
+ * @param	count	: Alarm event time
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_RTC_SetAlarm(LPC_RTC_T *pRTC, uint32_t count)
+{
+	pRTC->MATCH = count;
+}
+
+/**
+ * @brief	Return the RTC match value used for alarm status/interrupt
+ * @param	pRTC	: The base address of RTC block
+ * @return	Alarm event time
+ */
+__STATIC_INLINE uint32_t Chip_RTC_GetAlarm(LPC_RTC_T *pRTC)
+{
+	return pRTC->MATCH;
+}
+
+/**
+ * @brief	Set RTC match count for 1 second timer count
+ * @param	pRTC	: The base address of RTC block
+ * @param	count	: Initial count to set
+ * @return	Nothing
+ * @note	Only write to this register when the RTC_CTRL_RTC_EN bit in
+ *			the CTRL Register is 0. The counter increments one second
+ *			after the RTC_CTRL_RTC_EN bit is set.
+ */
+__STATIC_INLINE void Chip_RTC_SetCount(LPC_RTC_T *pRTC, uint32_t count)
+{
+	pRTC->COUNT = count;
+}
+
+/**
+ * @brief	Get current RTC 1 second timer count
+ * @param	pRTC	: The base address of RTC block
+ * @return	current RTC 1 second timer count
+ */
+__STATIC_INLINE uint32_t Chip_RTC_GetCount(LPC_RTC_T *pRTC)
+{
+	return pRTC->COUNT;
+}
+
+/**
+ * @brief	Set RTC wake count countdown value (in mS ticks)
+ * @param	pRTC	: The base address of RTC block
+ * @param	count	: wakeup time in milliSeconds
+ * @return	Nothing
+ * @note	A write pre-loads a start count value into the wake-up
+ *			timer and initializes a count-down sequence.
+ */
+__STATIC_INLINE void Chip_RTC_SetWake(LPC_RTC_T *pRTC, uint16_t count)
+{
+	pRTC->WAKE = count;
+}
+
+/**
+ * @brief	Get RTC wake count countdown value
+ * @param	pRTC	: The base address of RTC block
+ * @return	current RTC wake count countdown value (in mS)
+ */
+__STATIC_INLINE uint16_t Chip_RTC_GetWake(LPC_RTC_T *pRTC)
+{
+	return pRTC->WAKE;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RTC_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/rtc_ut.h ./chip/inc/rtc_ut.h
--- a_tnusFF/chip/inc/rtc_ut.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/rtc_ut.h	2016-10-22 23:17:43.568840278 -0300
@@ -0,0 +1,84 @@
+/*
+ * @brief RTC tick to (a more) Universal Time
+ * Adds conversion functions to use an RTC that only provides a
+ * seconds capability to provide "struct tm" support.
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __RTC_UT_H_
+#define __RTC_UT_H_
+
+#include "chip.h"
+#include <stdlib.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup RTC_UT CHIP: RTC tick to (a more) Universal Time conversion functions
+ * @ingroup CHIP_Common
+ * This driver converts between a RTC 1-second tick value and
+ * a Universal time format in a structure of type 'struct tm'.
+ * @{
+ */
+
+/* Starting year and starting day of week for the driver */
+#define TM_YEAR_BASE    (1900)
+#define TM_DAYOFWEEK    (1)
+
+/**
+ * @brief	Converts a RTC tick time to Universal time
+ * @param	rtcTick	: Current RTC time value
+ * @param	pTime	: Pointer to time structure to fill
+ * @return	Nothing
+ * @note	When setting time, the 'tm_wday', 'tm_yday', and 'tm_isdst'
+ * fields are not used.
+ */
+void ConvertRtcTime(uint32_t rtcTick, struct tm *pTime);
+
+/**
+ * @brief	Converts a Universal time to RTC tick time
+ * @param	pTime	: Pointer to time structure to use
+ * @param	rtcTick	: Pointer to RTC time value to fill
+ * @return	Nothing
+ * @note	When converting time, the 'tm_isdst' field is not
+ * populated by the conversion function.
+ */
+void ConvertTimeRtc(struct tm *pTime, uint32_t *rtcTick);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __RTC_UT_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/sct_5410x.h ./chip/inc/sct_5410x.h
--- a_tnusFF/chip/inc/sct_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/sct_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,543 @@
+/*
+ * @brief LPC5410X State Configurable Timer (SCT) Chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_5410X_H_
+#define __SCT_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_5410X CHIP: LPC5410X State Configurable Timer driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/*                         match/cap registers,     events,           states,         inputs,         outputs
+ *
+ * @brief SCT Module configuration
+ */
+#define CONFIG_SCT_nEV   (13)			/*!< Number of events */
+#define CONFIG_SCT_nRG   (13)			/*!< Number of match/compare registers */
+#define CONFIG_SCT_nOU   (8)			/*!< Number of outputs */
+#define CONFIG_SCT_nIN   (8)			/*!< Number of outputs */
+
+/**
+ * @brief State Configurable Timer register block structure
+ */
+typedef struct {
+	__IO  uint32_t CONFIG;				/*!< configuration Register (offset (0x000) */
+	union {
+		__IO uint32_t CTRL_U;			/*!< control Register */
+		struct {
+			__IO uint16_t CTRL_L;		/*!< low control register */
+			__IO uint16_t CTRL_H;		/*!< high control register */
+		};
+
+	};
+
+	union {
+		__IO uint32_t LIMIT_U;			/*!< limit Register */
+		struct {
+			__IO uint16_t LIMIT_L;		/*!< limit register for counter L */
+			__IO uint16_t LIMIT_H;		/*!< limit register for counter H */
+		};
+
+	};
+
+	union {
+		__IO uint32_t HALT_U;			/*!< halt Register */
+		struct {
+			__IO uint16_t HALT_L;		/*!< halt register for counter L */
+			__IO uint16_t HALT_H;		/*!< halt register for counter H */
+		};
+
+	};
+
+	union {
+		__IO uint32_t STOP_U;			/*!< stop Register */
+		struct {
+			__IO uint16_t STOP_L;		/*!< stop register for counter L */
+			__IO uint16_t STOP_H;		/*!< stop register for counter H */
+		};
+
+	};
+
+	union {
+		__IO uint32_t START_U;			/*!< start Register */
+		struct {
+			__IO uint16_t START_L;		/*!< start register for counter L */
+			__IO uint16_t START_H;		/*!< start register for counter H */
+		};
+
+	};
+
+	uint32_t RESERVED1[10];				/*!< 0x018 - 0x03C reserved */
+
+	union {
+		__IO uint32_t COUNT_U;			/*!< counter register (offset 0x040)*/
+		struct {
+			__IO uint16_t COUNT_L;		/*!< counter register for counter L */
+			__IO uint16_t COUNT_H;		/*!< counter register for counter H */
+		};
+
+	};
+
+	union {
+		__IO uint32_t STATE_U;			/*!< State register */
+		struct {
+			__IO uint16_t STATE_L;		/*!< state register for counter L */
+			__IO uint16_t STATE_H;		/*!< state register for counter H */
+		};
+
+	};
+
+	__I  uint32_t INPUT;				/*!< input register */
+	union {
+		__IO uint32_t REGMODE_U;		/*!< RegMode register */
+		struct {
+			__IO uint16_t REGMODE_L;	/*!< match - capture registers mode register L */
+			__IO uint16_t REGMODE_H;	/*!< match - capture registers mode register H */
+		};
+
+	};
+
+	__IO uint32_t OUTPUT;				/*!< output register */
+	__IO uint32_t OUTPUTDIRCTRL;		/*!< output counter direction Control Register */
+	__IO uint32_t RES;					/*!< conflict resolution register */
+	__IO uint32_t DMAREQ0;				/*!< DMA0 Request Register */
+	__IO uint32_t DMAREQ1;				/*!< DMA1 Request Register */
+	uint32_t RESERVED2[35];
+	__IO uint32_t EVEN;		/*!< event enable register */
+	__IO uint32_t EVFLAG;		/*!< event flag register */
+	__IO uint32_t CONEN;	/*!< conflict enable register */
+	__IO uint32_t CONFLAG;		/*!< conflict flag register */
+
+	union {
+
+		__IO union {	/*!< ... Match / Capture value */
+			uint32_t U;		/*!<       SCTMATCH[i].U  Unified 32-bit register */
+
+			struct {
+				uint16_t L;		/*!<       SCTMATCH[i].L  Access to L value */
+				uint16_t H;		/*!<       SCTMATCH[i].H  Access to H value */
+			};
+
+		} MATCH[CONFIG_SCT_nRG];
+
+		__I union {
+			uint32_t U;		/*!<       SCTCAP[i].U  Unified 32-bit register */
+
+			struct {
+				uint16_t L;		/*!<       SCTCAP[i].L  Access to L value */
+				uint16_t H;		/*!<       SCTCAP[i].H  Access to H value */
+			};
+
+		} CAP[CONFIG_SCT_nRG];
+
+	};
+
+	uint32_t RESERVED3[48 + (16 - CONFIG_SCT_nRG)];
+
+	union {
+
+		__IO union {	/* 0x200-... Match Reload / Capture Control value */
+			uint32_t U;		/*       SCTMATCHREL[i].U  Unified 32-bit register */
+
+			struct {
+				uint16_t L;		/*       SCTMATCHREL[i].L  Access to L value */
+				uint16_t H;		/*       SCTMATCHREL[i].H  Access to H value */
+			};
+
+		} MATCHREL[CONFIG_SCT_nRG];
+
+		__IO union {
+			uint32_t U;		/*       SCTCAPCTRL[i].U  Unified 32-bit register */
+
+			struct {
+				uint16_t L;		/*       SCTCAPCTRL[i].L  Access to H value */
+				uint16_t H;		/*       SCTCAPCTRL[i].H  Access to H value */
+			};
+
+		} CAPCTRL[CONFIG_SCT_nRG];
+
+	};
+
+	uint32_t RESERVED6[48 + (16 - CONFIG_SCT_nRG)];
+
+	__IO struct {		/* 0x300-0x3FC  SCTEVENT[i].STATE / SCTEVENT[i].CTRL*/
+		uint32_t STATE;		/* Event State Register */
+		uint32_t CTRL;		/* Event Control Register */
+	} EVENT[CONFIG_SCT_nEV];
+
+	uint32_t RESERVED9[128 - 2 * CONFIG_SCT_nEV];		/*!< ...-0x4FC reserved */
+
+	__IO struct {		/*!< 0x500-0x57C  SCTOUT[i].SET / SCTOUT[i].CLR */
+		uint32_t SET;		/*!< Output n Set Register */
+		uint32_t CLR;		/*!< Output n Clear Register */
+	} OUT[CONFIG_SCT_nOU];
+
+	uint32_t RESERVED10[191 - 2 * CONFIG_SCT_nOU];		/*!< ...-0x7F8 reserved */
+	__I uint32_t MODULECONTENT;		/*!< 0x7FC Module Content */
+} LPC_SCT_T;
+
+/**
+ * @brief Macro defines for SCT configuration register
+ */
+#define SCT_CONFIG_16BIT_COUNTER        0x00000000	/*!< Operate as 2 16-bit counters */
+#define SCT_CONFIG_32BIT_COUNTER        0x00000001	/*!< Operate as 1 32-bit counter */
+
+#define SCT_CONFIG_CLKMODE_BUSCLK       (0x0 << 1)	/*!< Bus clock */
+#define SCT_CONFIG_CLKMODE_SCTCLK       (0x1 << 1)	/*!< SCT clock */
+#define SCT_CONFIG_CLKMODE_INCLK        (0x2 << 1)	/*!< Input clock selected in CLKSEL field */
+#define SCT_CONFIG_CLKMODE_INEDGECLK    (0x3 << 1)	/*!< Input clock edge selected in CLKSEL field */
+
+#define SCT_CONFIG_CLKMODE_SYSCLK               (0x0 << 1)	/*!< System clock */
+#define SCT_CONFIG_CLKMODE_PRESCALED_SYSCLK     (0x1 << 1)	/*!< Prescaled system clock */
+#define SCT_CONFIG_CLKMODE_SCT_INPUT            (0x2 << 1)	/*!< Input clock/edge selected in CKSEL field */
+#define SCT_CONFIG_CLKMODE_PRESCALED_SCT_INPUT  (0x3 << 1)	/*!< Prescaled input clock/edge selected in CKSEL field */
+
+#define SCT_CONFIG_CKSEL_RISING_IN_0    (0x0UL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_0   (0x1UL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_1    (0x2UL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_1   (0x3UL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_2    (0x4UL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_2   (0x5UL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_3    (0x6UL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_3   (0x7UL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_4    (0x8UL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_4   (0x9UL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_5    (0xAUL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_5   (0xBUL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_6    (0xCUL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_6   (0xDUL << 3)
+#define SCT_CONFIG_CKSEL_RISING_IN_7    (0xEUL << 3)
+#define SCT_CONFIG_CKSEL_FALLING_IN_7   (0xFUL << 3)
+#define SCT_CONFIG_NORELOADL_U          (0x1 << 7)	/*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_NORELOADH            (0x1 << 8)	/*!< Operate as 1 32-bit counter */
+#define SCT_CONFIG_AUTOLIMIT_U          (0x1UL << 17)
+#define SCT_CONFIG_AUTOLIMIT_L          (0x1UL << 17)
+#define SCT_CONFIG_AUTOLIMIT_H          (0x1UL << 18)
+
+/**
+ * @brief Macro defines for SCT control register
+ */
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for low or unified counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+
+#define SCT_CTRL_STOP_L                 (1 << 1)				/*!< Stop low counter */
+#define SCT_CTRL_HALT_L                 (1 << 2)				/*!< Halt low counter */
+#define SCT_CTRL_CLRCTR_L               (1 << 3)				/*!< Clear low or unified counter */
+#define SCT_CTRL_BIDIR_L(x)             (((x) & 0x01) << 4)		/*!< Bidirectional bit */
+#define SCT_CTRL_PRE_L(x)               (((x) & 0xFF) << 5)		/*!< Prescale clock for low or unified counter */
+
+#define COUNTUP_TO_LIMIT_THEN_CLEAR_TO_ZERO     0			/*!< Direction for high counter */
+#define COUNTUP_TO LIMIT_THEN_COUNTDOWN_TO_ZERO 1
+#define SCT_CTRL_STOP_H                 (1 << 17)				/*!< Stop high counter */
+#define SCT_CTRL_HALT_H                 (1 << 18)				/*!< Halt high counter */
+#define SCT_CTRL_CLRCTR_H               (1 << 19)				/*!< Clear high counter */
+#define SCT_CTRL_BIDIR_H(x)             (((x) & 0x01) << 20)
+#define SCT_CTRL_PRE_H(x)               (((x) & 0xFF) << 21)	/*!< Prescale clock for high counter */
+
+#define SCT_EV_CTRL_MATCHSEL(reg)               (reg << 0)
+#define SCT_EV_CTRL_HEVENT_L                    (0UL << 4)
+#define SCT_EV_CTRL_HEVENT_H                    (1UL << 4)
+#define SCT_EV_CTRL_OUTSEL_INPUT                (0UL << 5)
+#define SCT_EV_CTRL_OUTSEL_OUTPUT               (0UL << 5)
+#define SCT_EV_CTRL_IOSEL(signal)               (signal << 6)
+
+#define SCT_EV_CTRL_IOCOND_LOW                  (0UL << 10)
+#define SCT_EV_CTRL_IOCOND_RISE                 (0x1UL << 10)
+#define SCT_EV_CTRL_IOCOND_FALL                 (0x2UL << 10)
+#define SCT_EV_CTRL_IOCOND_HIGH                 (0x3UL << 10)
+#define SCT_EV_CTRL_COMBMODE_OR                 (0x0UL << 12)
+#define SCT_EV_CTRL_COMBMODE_MATCH              (0x1UL << 12)
+#define SCT_EV_CTRL_COMBMODE_IO                 (0x2UL << 12)
+#define SCT_EV_CTRL_COMBMODE_AND                (0x3UL << 12)
+#define SCT_EV_CTRL_STATELD                     (0x1UL << 14)
+#define SCT_EV_CTRL_STATEV(x)                   (x << 15)
+#define SCT_EV_CTRL_MATCHMEM                    (0x1UL << 20)
+#define SCT_EV_CTRL_DIRECTION_INDEPENDENT       (0x0UL << 21)
+#define SCT_EV_CTRL_DIRECTION_UP                (0x1UL << 21)
+#define SCT_EV_CTRL_DIRECTION_DOWN              (0x2UL << 21)
+
+/**
+ * @brief Macro defines for SCT Conflict resolution register
+ */
+#define SCT_RES_NOCHANGE                (0)
+#define SCT_RES_SET_OUTPUT              (1)
+#define SCT_RES_CLEAR_OUTPUT            (2)
+#define SCT_RES_TOGGLE_OUTPUT           (3)
+
+/**
+ * SCT Match register values enum
+ */
+typedef enum CHIP_SCT_MATCH_REG {
+	SCT_MATCH_0 = 0,	/*!< SCT Match register 0 */
+	SCT_MATCH_1,
+	SCT_MATCH_2,
+	SCT_MATCH_3,
+	SCT_MATCH_4,
+	SCT_MATCH_5,
+	SCT_MATCH_6,
+	SCT_MATCH_7,
+	SCT_MATCH_8,
+	SCT_MATCH_9,
+	SCT_MATCH_10,
+	SCT_MATCH_11,
+	SCT_MATCH_12,
+	SCT_MATCH_13,
+	SCT_MATCH_14,
+	SCT_MATCH_15
+} CHIP_SCT_MATCH_REG_T;
+
+/**
+ * SCT Event values enum
+ */
+typedef enum CHIP_SCT_EVENT {
+	SCT_EVT_0 = (1 << 0),		/*!< Event 0 */
+	SCT_EVT_1 = (1 << 1),		/*!< Event 1 */
+	SCT_EVT_2 = (1 << 2),		/*!< Event 2 */
+	SCT_EVT_3 = (1 << 3),		/*!< Event 3 */
+	SCT_EVT_4 = (1 << 4),		/*!< Event 4 */
+	SCT_EVT_5 = (1 << 5),		/*!< Event 5 */
+	SCT_EVT_6 = (1 << 6),		/*!< Event 6 */
+	SCT_EVT_7 = (1 << 7),		/*!< Event 7 */
+	SCT_EVT_8 = (1 << 8),		/*!< Event 8 */
+	SCT_EVT_9 = (1 << 9),		/*!< Event 9 */
+	SCT_EVT_10 = (1 << 10),		/*!< Event 10 */
+	SCT_EVT_11 = (1 << 11),		/*!< Event 11 */
+	SCT_EVT_12 = (1 << 12),		/*!< Event 12 */
+	SCT_EVT_13 = (1 << 13),		/*!< Event 13 */
+	SCT_EVT_14 = (1 << 14),		/*!< Event 14 */
+	SCT_EVT_15 = (1 << 15)		/*!< Event 15 */
+} CHIP_SCT_EVENT_T;
+
+/**
+ * @brief	Set event control register
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	event_number
+ * @param	value	: The 32-bit event control setting
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_EventControl(LPC_SCT_T *pSCT, uint32_t event_number,
+										   uint32_t value) {
+	pSCT->EVENT[event_number].CTRL = value;
+}
+
+/**
+ * @brief	Set event state mask register
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	event_number
+ * @param	event_state_mask      : The 32-bit event state mask setting
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_EventStateMask(LPC_SCT_T *pSCT, uint32_t event_number,
+											 uint32_t event_state_mask) {
+	pSCT->EVENT[event_number].STATE = event_state_mask;
+}
+
+/**
+ * @brief	Set configuration register
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	cfg      : The 32-bit configuration setting
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_Config(LPC_SCT_T *pSCT, uint32_t cfg) {
+	pSCT->CONFIG = cfg;
+}
+
+/**
+ * @brief	Configures the Limit register
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: The 32-bit Limit register value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_Limit(LPC_SCT_T *pSCT, uint32_t value) {
+	pSCT->LIMIT_L = value;
+}
+
+/**
+ * @brief	Set or Clear the Control register
+ * @param	pSCT			: Pointer to SCT register block
+ * @param	value			: SCT Control register value
+ * @param	ena             : ENABLE - To set the fields specified by value
+ *                          : DISABLE - To clear the field specified by value
+ * @return	Nothing
+ * Set or clear the control register bits as specified by the \a value
+ * parameter. If \a ena is set to ENABLE, the mentioned register fields
+ * will be set. If \a ena is set to DISABLE, the mentioned register
+ * fields will be cleared
+ */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena);
+
+/**
+ * @brief	Set the conflict resolution
+ * @param	pSCT			: Pointer to SCT register block
+ * @param	outnum			: Output number
+ * @param	value           : Output value
+ *                          - SCT_RES_NOCHANGE		:No change
+ *					        - SCT_RES_SET_OUTPUT	:Set output
+ *					        - SCT_RES_CLEAR_OUTPUT	:Clear output
+ *					        - SCT_RES_TOGGLE_OUTPUT :Toggle output
+ *                          : SCT_RES_NOCHANGE
+ *                          : DISABLE - To clear the field specified by value
+ * @return	Nothing
+ * Set conflict resolution for the output \a outnum
+ */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value);
+
+/**
+ * @brief	Set unified count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 32-bit count value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetCount(LPC_SCT_T *pSCT, uint32_t count) {
+	pSCT->COUNT_U = count;
+}
+
+/**
+ * @brief	Set lower count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 16-bit count value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetCountL(LPC_SCT_T *pSCT, uint16_t count) {
+	pSCT->COUNT_L = count;
+}
+
+/**
+ * @brief	Set higher count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	count	: The 16-bit count value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetCountH(LPC_SCT_T *pSCT, uint16_t count) {
+	pSCT->COUNT_H = count;
+}
+
+/**
+ * @brief	Set unified match count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	n		: Match register value
+ * @param	value	: The 32-bit match count value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetMatchCount(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
+	pSCT->MATCH[n].U = value;
+}
+
+/**
+ * @brief	Set unified match reload count value in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	n		: Match register value
+ * @param	value	: The 32-bit match count reload value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetMatchReload(LPC_SCT_T *pSCT, CHIP_SCT_MATCH_REG_T n, uint32_t value) {
+	pSCT->MATCHREL[n].U = value;
+}
+
+/**
+ * @brief	Enable the interrupt for the specified event in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_EnableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
+	pSCT->EVEN |= evt;
+}
+
+/**
+ * @brief	Disable the interrupt for the specified event in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_DisableEventInt(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
+	pSCT->EVEN &= ~(evt);
+}
+
+/**
+ * @brief	Clear the specified event flag in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	evt		: Event value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_ClearEventFlag(LPC_SCT_T *pSCT, CHIP_SCT_EVENT_T evt) {
+	pSCT->EVFLAG |= evt;
+}
+
+/**
+ * @brief	Set control register in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: Value (ORed value of SCT_CTRL_* bits)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_SetControl(LPC_SCT_T *pSCT, uint32_t value) {
+	pSCT->CTRL_U |= value;
+}
+
+/**
+ * @brief	Clear control register in State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	value	: Value (ORed value of SCT_CTRL_* bits)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SCT_ClearControl(LPC_SCT_T *pSCT, uint32_t value) {
+	pSCT->CTRL_U &= ~(value);
+}
+
+/**
+ * @brief	Initializes the State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SCT_Init(LPC_SCT_T *pSCT);
+
+/**
+ * @brief	Deinitializes the State Configurable Timer
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/sct_pwm_5410x.h ./chip/inc/sct_pwm_5410x.h
--- a_tnusFF/chip/inc/sct_pwm_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/sct_pwm_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,178 @@
+/*
+ * @brief LPC5410x State Configurable Timer (SCT/PWM) Chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SCT_PWM_5410X_H_
+#define __SCT_PWM_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SCT_PWM_5410X CHIP: LPC5410X State Configurable Timer PWM driver
+ *
+ * For more information on how to use the driver please visit the FAQ page at
+ * <a href="http://www.lpcware.com/content/faq/how-use-sct-standard-pwm-using-lpcopen">
+ * www.lpcware.com</a>
+ *
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief	Get number of ticks per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	Number ot ticks that will be counted per cycle
+ * @note	Return value of this function will be vaild only
+ *          after calling Chip_SCTPWM_SetRate()
+ */
+__STATIC_INLINE uint32_t Chip_SCTPWM_GetTicksPerCycle(LPC_SCT_T *pSCT)
+{
+	return pSCT->MATCHREL[0].U;
+}
+
+/**
+ * @brief	Converts a percentage to ticks
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	percent	: Percentage to convert (0 - 100)
+ * @return	Number ot ticks corresponding to given percentage
+ * @note	Do not use this function when using very low
+ *          pwm rate (like 100Hz or less), on a chip that has
+ *          very high frequency as the calculation might
+ *          cause integer overflow
+ */
+__STATIC_INLINE uint32_t Chip_SCTPWM_PercentageToTicks(LPC_SCT_T *pSCT, uint8_t percent)
+{
+	return (Chip_SCTPWM_GetTicksPerCycle(pSCT) * percent) / 100;
+}
+
+/**
+ * @brief	Get number of ticks on per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	index	: Index of the PWM 1 to N (see notes)
+ * @return	Number ot ticks for which the output will be ON per cycle
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+__STATIC_INLINE uint32_t Chip_SCTPWM_GetDutyCycle(LPC_SCT_T *pSCT, uint8_t index)
+{
+	return pSCT->MATCHREL[index].U;
+}
+
+/**
+ * @brief	Get number of ticks on per PWM cycle
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	index	: Index of the PWM 1 to N (see notes)
+ * @param	ticks	: Number of ticks the output should say ON
+ * @return	None
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum. The new duty cycle will be effective only
+ *          after completion of current PWM cycle.
+ */
+__STATIC_INLINE void Chip_SCTPWM_SetDutyCycle(LPC_SCT_T *pSCT, uint8_t index, uint32_t ticks)
+{
+	Chip_SCT_SetMatchReload(pSCT, (CHIP_SCT_MATCH_REG_T) index, ticks);
+}
+
+/**
+ * @brief	Initialize the SCT/PWM clock and reset
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ */
+__STATIC_INLINE void Chip_SCTPWM_Init(LPC_SCT_T *pSCT)
+{
+	Chip_SCT_Init(pSCT);
+}
+
+/**
+ * @brief	Start the SCT PWM
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ * @note	This function must be called after all the
+ *          configuration is completed. Do not call Chip_SCTPWM_SetRate()
+ *          or Chip_SCTPWM_SetOutPin() after the SCT/PWM is started. Use
+ *          Chip_SCTPWM_Stop() to stop the SCT/PWM before reconfiguring,
+ *          Chip_SCTPWM_SetDutyCycle() can be called when the SCT/PWM is
+ *          running to change the DutyCycle.
+ */
+__STATIC_INLINE void Chip_SCTPWM_Start(LPC_SCT_T *pSCT)
+{
+	Chip_SCT_ClearControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+}
+
+/**
+ * @brief	Stop the SCT PWM
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @return	None
+ */
+__STATIC_INLINE void Chip_SCTPWM_Stop(LPC_SCT_T *pSCT)
+{
+	/* Stop SCT */
+	Chip_SCT_SetControl(pSCT, SCT_CTRL_HALT_L | SCT_CTRL_HALT_H);
+
+	/* Clear the counter */
+	Chip_SCT_SetControl(pSCT, SCT_CTRL_CLRCTR_L | SCT_CTRL_CLRCTR_H);
+}
+
+/**
+ * @brief	Sets the frequency of the generated PWM wave
+ * @param	pSCT	: The base of SCT peripheral on the chip
+ * @param	freq	: Frequency in Hz
+ * @return	None
+ */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq);
+
+/**
+ * @brief	Setup the OUTPUT pin and associate it with an index
+ * @param	pSCT	: The base of the SCT peripheral on the chip
+ * @param	index	: Index of PWM 1 to N (see notes)
+ * @param	pin		: COUT pin to be associated with the index
+ * @return	None
+ * @note	@a index will be 1 to N where N is the "Number of
+ *          match registers available in the SCT - 1" or
+ *          "Number of OUTPUT pins available in the SCT" whichever
+ *          is minimum.
+ */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+
+#endif
+
+#endif /* __SCT_PWM_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/spi_common_5410x.h ./chip/inc/spi_common_5410x.h
--- a_tnusFF/chip/inc/spi_common_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/spi_common_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,701 @@
+/*
+ * @brief LPC5410X SPI common functions and definitions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPI_COMMON_5410X_H_
+#define __SPI_COMMON_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SPI_COMMON_5410X CHIP: LPC5410X SPI driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief SPI register block structure
+ */
+typedef struct {					/*!< SPI Structure */
+	__IO uint32_t  CFG;				/*!< SPI Configuration register */
+	__IO uint32_t  DLY;				/*!< SPI Delay register */
+	__IO uint32_t  STAT;			/*!< SPI Status register */
+	__IO uint32_t  INTENSET;		/*!< SPI Interrupt Enable Set register */
+	__O uint32_t  INTENCLR;		/*!< SPI Interrupt Enable Clear register */
+	__I  uint32_t  RXDAT;			/*!< SPI Receive Data register */
+	__IO uint32_t  TXDATCTL;		/*!< SPI Transmit Data with Control register */
+	__O  uint32_t  TXDAT;			/*!< SPI Transmit Data register */
+	__IO uint32_t  TXCTRL;			/*!< SPI Transmit Control register */
+	__IO uint32_t  DIV;				/*!< SPI clock Divider register */
+	__I  uint32_t  INTSTAT;			/*!< SPI Interrupt Status register */
+} LPC_SPI_T;
+
+/**
+ * Macro defines for SPI Configuration register
+ */
+#define SPI_CFG_BITMASK         (0xFBD)						/** SPI register bit mask */
+#define SPI_CFG_SPI_EN          (1 << 0)					/** SPI Slave Mode Select */
+#define SPI_CFG_SLAVE_EN        (0 << 0)					/** SPI Master Mode Select */
+#define SPI_CFG_MASTER_EN       (1 << 2)					/** SPI MSB First mode enable */
+#define SPI_CFG_MSB_FIRST_EN    (0 << 3)					/** SPI LSB First mode enable */
+#define SPI_CFG_LSB_FIRST_EN    (1 << 3)					/** SPI Clock Phase Select */
+#define SPI_CFG_CPHA_FIRST      (0 << 4)					/** Capture data on the first edge, Change data on the following edge */
+#define SPI_CFG_CPHA_SECOND     (1 << 4)					/** SPI Clock Polarity Select */
+#define SPI_CFG_CPOL_LO         (0 << 5)					/** The rest state of the clock (between frames) is low. */
+#define SPI_CFG_CPOL_HI         (1 << 5)					/** The rest state of the clock (between frames) is high. */
+#define SPI_CFG_LBM_EN          (1 << 7)					/** SPI control 1 loopback mode enable */
+#define SPI_CFG_SPOL_LO         (0 << 8)					/** SPI SSEL0 Polarity Select */
+#define SPI_CFG_SPOL_HI         (1 << 8)					/** SSEL0 is active High */
+#define SPI_CFG_SPOLNUM_HI(n)   (1 << ((n) + 8))			/** SSELN is active High, selects 0 - 3 */
+
+/**
+ * Macro defines for SPI Delay register
+ */
+#define  SPI_DLY_BITMASK            (0xFFFF)				/** SPI DLY Register Mask */
+#define  SPI_DLY_PRE_DELAY(n)       (((n) & 0x0F) << 0)		/** Time in SPI clocks between SSEL assertion and the beginning of a data frame */
+#define  SPI_DLY_POST_DELAY(n)      (((n) & 0x0F) << 4)		/** Time in SPI clocks between the end of a data frame and SSEL deassertion. */
+#define  SPI_DLY_FRAME_DELAY(n)     (((n) & 0x0F) << 8)		/** Minimum time in SPI clocks between adjacent data frames. */
+#define  SPI_DLY_TRANSFER_DELAY(n)  (((n) & 0x0F) << 12)	/** Minimum time in SPI clocks that the SSEL is deasserted between transfers. */
+
+/**
+ * Macro defines for SPI Status register
+ */
+#define SPI_STAT_BITMASK            (0x1FF)					/** SPI STAT Register BitMask */
+#define SPI_STAT_RXRDY              (1 << 0)				/** Receiver Ready Flag */
+#define SPI_STAT_TXRDY              (1 << 1)				/** Transmitter Ready Flag */
+#define SPI_STAT_RXOV               (1 << 2)				/** Receiver Overrun interrupt flag */
+#define SPI_STAT_TXUR               (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
+#define SPI_STAT_SSA                (1 << 4)				/** Slave Select Assert */
+#define SPI_STAT_SSD                (1 << 5)				/** Slave Select Deassert */
+#define SPI_STAT_STALLED            (1 << 6)				/** Stalled status flag */
+#define SPI_STAT_EOT                (1 << 7)				/** End Transfer flag */
+#define SPI_STAT_MSTIDLE            (1 << 8)				/** Idle status flag */
+
+/**
+ * Macro defines for SPI Interrupt Enable read and Set register
+ */
+#define SPI_INTENSET_BITMASK        (0x3F)					/** SPI INTENSET Register BitMask */
+#define SPI_INTENSET_RXDYEN         (1 << 0)				/** Enable Interrupt when receiver data is available */
+#define SPI_INTENSET_TXDYEN         (1 << 1)				/** Enable Interrupt when the transmitter holding register is available. */
+#define SPI_INTENSET_RXOVEN         (1 << 2)				/**  Enable Interrupt when a receiver overrun occurs */
+#define SPI_INTENSET_TXUREN         (1 << 3)				/**  Enable Interrupt when a transmitter underrun occurs (In Slave Mode Only)*/
+#define SPI_INTENSET_SSAEN          (1 << 4)				/**  Enable Interrupt when the Slave Select is asserted.*/
+#define SPI_INTENSET_SSDEN          (1 << 5)				/**  Enable Interrupt when the Slave Select is deasserted..*/
+
+/**
+ * Macro defines for SPI Interrupt Enable Clear register
+ */
+#define SPI_INTENCLR_BITMASK        (0x3F)					/** SPI INTENCLR Register BitMask */
+#define SPI_INTENCLR_RXDYEN         (1 << 0)				/** Disable Interrupt when receiver data is available */
+#define SPI_INTENCLR_TXDYEN         (1 << 1)				/** Disable Interrupt when the transmitter holding register is available. */
+#define SPI_INTENCLR_RXOVEN         (1 << 2)				/** Disable Interrupt when a receiver overrun occurs */
+#define SPI_INTENCLR_TXUREN         (1 << 3)				/** Disable Interrupt when a transmitter underrun occurs (In Slave Mode Only) */
+#define SPI_INTENCLR_SSAEN          (1 << 4)				/** Disable Interrupt when the Slave Select is asserted. */
+#define SPI_INTENCLR_SSDEN          (1 << 5)				/** Disable Interrupt when the Slave Select is deasserted.. */
+
+/**
+ * Macro defines for SPI Receiver Data register
+ */
+#define SPI_RXDAT_BITMASK           (0x1FFFFF)				/** SPI RXDAT Register BitMask */
+#define SPI_RXDAT_DATA(n)           ((n) & 0xFFFF)			/** Receiver Data  */
+#define SPI_RXDAT_RXSSELN_ACTIVE    (0 << 16)				/** The state of SSEL pin is active */
+#define SPI_RXDAT_RXSSELN_INACTIVE  ((1 << 16)				/** The state of SSEL pin is inactive */
+#define SPI_RXDAT_RXSSELNUM_INACTIVE(n) (1 << ((n) + 16))	/** The state of SSELN pin is inactive */
+#define SPI_RXDAT_SOT               (1 << 20)				/** Start of Transfer flag  */
+
+/**
+ * Macro defines for SPI Transmitter Data and Control register
+ */
+#define SPI_TXDATCTL_BITMASK        (0xF7FFFFF)				/** SPI TXDATCTL Register BitMask */
+#define SPI_TXDATCTL_DATA(n)        ((n) & 0xFFFF)			/** SPI Transmit Data */
+#define SPI_TXDATCTL_CTRLMASK       (0xF7F0000)				/** SPI TXDATCTL Register BitMask for control bits only */
+#define SPI_TXDATCTL_ASSERT_SSEL    (0 << 16)				/** Assert SSEL0 pin */
+#define SPI_TXDATCTL_DEASSERT_SSEL  (1 << 16)				/** Deassert SSEL0 pin */
+#define SPI_TXDATCTL_DEASSERTNUM_SSEL(n)    (1 << ((n) + 16))	/** Deassert SSELN pin */
+#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
+#define SPI_TXDATCTL_EOT            (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
+#define SPI_TXDATCTL_EOF            (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
+#define SPI_TXDATCTL_RXIGNORE       (1 << 22)				/** Receive Ignore Flag */
+#define SPI_TXDATCTL_FLEN(n)        (((n) & 0x0F) << 24)	/** Frame length - 1 */
+
+/**
+ * Macro defines for SPI Transmitter Data Register
+ */
+#define SPI_TXDAT_DATA(n)           ((n) & 0xFFFF)			/** SPI Transmit Data */
+
+/**
+ * Macro defines for SPI Transmitter Control register
+ */
+#define SPI_TXCTL_BITMASK           (0xF7F0000)				/** SPI TXDATCTL Register BitMask */
+#define SPI_TXCTL_ASSERT_SSEL       (0 << 16)				/** Assert SSEL0 pin */
+#define SPI_TXCTL_DEASSERT_SSEL     (1 << 16)				/** Deassert SSEL0 pin */
+#define SPI_TXCTL_DEASSERTNUM_SSEL(n)   (1 << ((n) + 16))	/** Deassert SSELN pin */
+#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
+#define SPI_TXCTL_EOT               (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
+#define SPI_TXCTL_EOF               (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
+#define SPI_TXCTL_RXIGNORE          (1 << 22)				/** Receive Ignore Flag */
+#define SPI_TXCTL_FLEN(n)           ((((n) - 1) & 0x0F) << 24)	/** Frame length, 0 - 16 */
+#define SPI_TXCTL_FLENMASK          (0xF << 24)				/** Frame length mask */
+
+/**
+ * Macro defines for SPI Divider register
+ */
+#define SPI_DIV_VAL(n)          ((n) & 0xFFFF)				/** Rate divider value mask (In Master Mode only)*/
+
+/**
+ * Macro defines for SPI Interrupt Status register
+ */
+#define SPI_INTSTAT_BITMASK         (0x3F)					/** SPI INTSTAT Register Bitmask */
+#define SPI_INTSTAT_RXRDY           (1 << 0)				/** Receiver Ready Flag */
+#define SPI_INTSTAT_TXRDY           (1 << 1)				/** Transmitter Ready Flag */
+#define SPI_INTSTAT_RXOV            (1 << 2)				/** Receiver Overrun interrupt flag */
+#define SPI_INTSTAT_TXUR            (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
+#define SPI_INTSTAT_SSA             (1 << 4)				/** Slave Select Assert */
+#define SPI_INTSTAT_SSD             (1 << 5)				/** Slave Select Deassert */
+
+/** @brief SPI Clock Mode*/
+typedef enum {
+	ROM_SPI_CLOCK_CPHA0_CPOL0 = 0,						/**< CPHA = 0, CPOL = 0 */
+	ROM_SPI_CLOCK_MODE0 = ROM_SPI_CLOCK_CPHA0_CPOL0,	/**< Alias for CPHA = 0, CPOL = 0 */
+	ROM_SPI_CLOCK_CPHA1_CPOL0 = 1,						/**< CPHA = 0, CPOL = 1 */
+	ROM_SPI_CLOCK_MODE1 = ROM_SPI_CLOCK_CPHA1_CPOL0,	/**< Alias for CPHA = 0, CPOL = 1 */
+	ROM_SPI_CLOCK_CPHA0_CPOL1 = 2,						/**< CPHA = 1, CPOL = 0 */
+	ROM_SPI_CLOCK_MODE2 = ROM_SPI_CLOCK_CPHA0_CPOL1,	/**< Alias for CPHA = 1, CPOL = 0 */
+	ROM_SPI_CLOCK_CPHA1_CPOL1 = 3,						/**< CPHA = 1, CPOL = 1 */
+	ROM_SPI_CLOCK_MODE3 = ROM_SPI_CLOCK_CPHA1_CPOL1,	/**< Alias for CPHA = 1, CPOL = 1 */
+} ROM_SPI_CLOCK_MODE_T;
+
+/**
+ * Macro defines for SPI Configuration register
+ */
+#define SPI_CFG_BITMASK         (0xFBD)						/** SPI register bit mask */
+#define SPI_CFG_SPI_EN          (1 << 0)					/** SPI Slave Mode Select */
+#define SPI_CFG_SLAVE_EN        (0 << 0)					/** SPI Master Mode Select */
+#define SPI_CFG_MASTER_EN       (1 << 2)					/** SPI MSB First mode enable */
+#define SPI_CFG_MSB_FIRST_EN    (0 << 3)					/** SPI LSB First mode enable */
+#define SPI_CFG_LSB_FIRST_EN    (1 << 3)					/** SPI Clock Phase Select */
+#define SPI_CFG_CPHA_FIRST      (0 << 4)					/** Capture data on the first edge, Change data on the following edge */
+#define SPI_CFG_CPHA_SECOND     (1 << 4)					/** SPI Clock Polarity Select */
+#define SPI_CFG_CPOL_LO         (0 << 5)					/** The rest state of the clock (between frames) is low. */
+#define SPI_CFG_CPOL_HI         (1 << 5)					/** The rest state of the clock (between frames) is high. */
+#define SPI_CFG_LBM_EN          (1 << 7)					/** SPI control 1 loopback mode enable */
+#define SPI_CFG_SPOL_LO         (0 << 8)					/** SPI SSEL0 Polarity Select */
+#define SPI_CFG_SPOL_HI         (1 << 8)					/** SSEL0 is active High */
+#define SPI_CFG_SPOLNUM_HI(n)   (1 << ((n) + 8))			/** SSELN is active High, selects 0 - 3 */
+
+/**
+ * Macro defines for SPI Delay register
+ */
+#define  SPI_DLY_BITMASK            (0xFFFF)				/** SPI DLY Register Mask */
+#define  SPI_DLY_PRE_DELAY(n)       (((n) & 0x0F) << 0)		/** Time in SPI clocks between SSEL assertion and the beginning of a data frame */
+#define  SPI_DLY_POST_DELAY(n)      (((n) & 0x0F) << 4)		/** Time in SPI clocks between the end of a data frame and SSEL deassertion. */
+#define  SPI_DLY_FRAME_DELAY(n)     (((n) & 0x0F) << 8)		/** Minimum time in SPI clocks between adjacent data frames. */
+#define  SPI_DLY_TRANSFER_DELAY(n)  (((n) & 0x0F) << 12)	/** Minimum time in SPI clocks that the SSEL is deasserted between transfers. */
+
+/**
+ * Macro defines for SPI Status register
+ */
+#define SPI_STAT_BITMASK            (0x1FF)					/** SPI STAT Register BitMask */
+#define SPI_STAT_RXRDY              (1 << 0)				/** Receiver Ready Flag */
+#define SPI_STAT_TXRDY              (1 << 1)				/** Transmitter Ready Flag */
+#define SPI_STAT_RXOV               (1 << 2)				/** Receiver Overrun interrupt flag */
+#define SPI_STAT_TXUR               (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
+#define SPI_STAT_SSA                (1 << 4)				/** Slave Select Assert */
+#define SPI_STAT_SSD                (1 << 5)				/** Slave Select Deassert */
+#define SPI_STAT_STALLED            (1 << 6)				/** Stalled status flag */
+#define SPI_STAT_EOT                (1 << 7)				/** End Transfer flag */
+#define SPI_STAT_MSTIDLE            (1 << 8)				/** Idle status flag */
+
+/**
+ * Macro defines for SPI Interrupt Enable read and Set register
+ */
+#define SPI_INTENSET_BITMASK        (0x3F)					/** SPI INTENSET Register BitMask */
+#define SPI_INTENSET_RXDYEN         (1 << 0)				/** Enable Interrupt when receiver data is available */
+#define SPI_INTENSET_TXDYEN         (1 << 1)				/** Enable Interrupt when the transmitter holding register is available. */
+#define SPI_INTENSET_RXOVEN         (1 << 2)				/**  Enable Interrupt when a receiver overrun occurs */
+#define SPI_INTENSET_TXUREN         (1 << 3)				/**  Enable Interrupt when a transmitter underrun occurs (In Slave Mode Only)*/
+#define SPI_INTENSET_SSAEN          (1 << 4)				/**  Enable Interrupt when the Slave Select is asserted.*/
+#define SPI_INTENSET_SSDEN          (1 << 5)				/**  Enable Interrupt when the Slave Select is deasserted..*/
+
+/**
+ * Macro defines for SPI Interrupt Enable Clear register
+ */
+#define SPI_INTENCLR_BITMASK        (0x3F)					/** SPI INTENCLR Register BitMask */
+#define SPI_INTENCLR_RXDYEN         (1 << 0)				/** Disable Interrupt when receiver data is available */
+#define SPI_INTENCLR_TXDYEN         (1 << 1)				/** Disable Interrupt when the transmitter holding register is available. */
+#define SPI_INTENCLR_RXOVEN         (1 << 2)				/** Disable Interrupt when a receiver overrun occurs */
+#define SPI_INTENCLR_TXUREN         (1 << 3)				/** Disable Interrupt when a transmitter underrun occurs (In Slave Mode Only) */
+#define SPI_INTENCLR_SSAEN          (1 << 4)				/** Disable Interrupt when the Slave Select is asserted. */
+#define SPI_INTENCLR_SSDEN          (1 << 5)				/** Disable Interrupt when the Slave Select is deasserted.. */
+
+/**
+ * Macro defines for SPI Receiver Data register
+ */
+#define SPI_RXDAT_BITMASK           (0x1FFFFF)				/** SPI RXDAT Register BitMask */
+#define SPI_RXDAT_DATA(n)           ((n) & 0xFFFF)			/** Receiver Data  */
+#define SPI_RXDAT_RXSSELN_ACTIVE    (0 << 16)				/** The state of SSEL pin is active */
+#define SPI_RXDAT_RXSSELN_INACTIVE  ((1 << 16)				/** The state of SSEL pin is inactive */
+#define SPI_RXDAT_RXSSELNUM_INACTIVE(n) (1 << ((n) + 16))	/** The state of SSELN pin is inactive */
+#define SPI_RXDAT_SOT               (1 << 20)				/** Start of Transfer flag  */
+
+/**
+ * Macro defines for SPI Transmitter Data and Control register
+ */
+#define SPI_TXDATCTL_BITMASK        (0xF7FFFFF)				/** SPI TXDATCTL Register BitMask */
+#define SPI_TXDATCTL_DATA(n)        ((n) & 0xFFFF)			/** SPI Transmit Data */
+#define SPI_TXDATCTL_CTRLMASK       (0xF7F0000)				/** SPI TXDATCTL Register BitMask for control bits only */
+#define SPI_TXDATCTL_ASSERT_SSEL    (0 << 16)				/** Assert SSEL0 pin */
+#define SPI_TXDATCTL_DEASSERT_SSEL  (1 << 16)				/** Deassert SSEL0 pin */
+#define SPI_TXDATCTL_DEASSERTNUM_SSEL(n)    (1 << ((n) + 16))	/** Deassert SSELN pin */
+#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
+#define SPI_TXDATCTL_EOT            (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
+#define SPI_TXDATCTL_EOF            (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
+#define SPI_TXDATCTL_RXIGNORE       (1 << 22)				/** Receive Ignore Flag */
+#define SPI_TXDATCTL_FLEN(n)        (((n) & 0x0F) << 24)	/** Frame length - 1 */
+
+/**
+ * Macro defines for SPI Transmitter Data Register
+ */
+#define SPI_TXDAT_DATA(n)           ((n) & 0xFFFF)			/** SPI Transmit Data */
+
+/**
+ * Macro defines for SPI Transmitter Control register
+ */
+#define SPI_TXCTL_BITMASK           (0xF7F0000)				/** SPI TXDATCTL Register BitMask */
+#define SPI_TXCTL_ASSERT_SSEL       (0 << 16)				/** Assert SSEL0 pin */
+#define SPI_TXCTL_DEASSERT_SSEL     (1 << 16)				/** Deassert SSEL0 pin */
+#define SPI_TXCTL_DEASSERTNUM_SSEL(n)   (1 << ((n) + 16))	/** Deassert SSELN pin */
+#define SPI_TXDATCTL_DEASSERT_ALL   (0xF << 16)				/** Deassert all SSEL pins */
+#define SPI_TXCTL_EOT               (1 << 20)				/** End of Transfer flag (TRANSFER_DELAY is applied after sending the current frame) */
+#define SPI_TXCTL_EOF               (1 << 21)				/** End of Frame flag (FRAME_DELAY is applied after sending the current part) */
+#define SPI_TXCTL_RXIGNORE          (1 << 22)				/** Receive Ignore Flag */
+#define SPI_TXCTL_FLEN(n)           ((((n) - 1) & 0x0F) << 24)	/** Frame length, 0 - 16 */
+#define SPI_TXCTL_FLENMASK          (0xF << 24)				/** Frame length mask */
+
+/**
+ * Macro defines for SPI Divider register
+ */
+#define SPI_DIV_VAL(n)          ((n) & 0xFFFF)				/** Rate divider value mask (In Master Mode only)*/
+
+/**
+ * Macro defines for SPI Interrupt Status register
+ */
+#define SPI_INTSTAT_BITMASK         (0x3F)					/** SPI INTSTAT Register Bitmask */
+#define SPI_INTSTAT_RXRDY           (1 << 0)				/** Receiver Ready Flag */
+#define SPI_INTSTAT_TXRDY           (1 << 1)				/** Transmitter Ready Flag */
+#define SPI_INTSTAT_RXOV            (1 << 2)				/** Receiver Overrun interrupt flag */
+#define SPI_INTSTAT_TXUR            (1 << 3)				/** Transmitter Underrun interrupt flag (In Slave Mode only) */
+#define SPI_INTSTAT_SSA             (1 << 4)				/** Slave Select Assert */
+#define SPI_INTSTAT_SSD             (1 << 5)				/** Slave Select Deassert */
+
+/**
+ * @brief	Set SPI CFG register values
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	bits	: CFG register bits to set, amd OR'ed value of SPI_CFG_* definitions
+ * @return	Nothing
+ * @note	This function safely sets only the selected bits in the SPI CFG register.
+ * It can be used to enable multiple bits at once.
+ */
+__STATIC_INLINE void Chip_SPI_SetCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
+{
+	/* Mask off bits that are write as 0, read as undefined */
+	pSPI->CFG = (pSPI->CFG | bits) & SPI_CFG_BITMASK;
+}
+
+/**
+ * @brief	Clear SPI CFG register values
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	bits	: CFG register bits to clear, amd OR'ed value of SPI_CFG_* definitions
+ * @return	Nothing
+ * @note	This function safely clears only the selected bits in the SPI CFG register.
+ * It can be used to disable multiple bits at once.
+ */
+__STATIC_INLINE void Chip_SPI_ClearCFGRegBits(LPC_SPI_T *pSPI, uint32_t bits)
+{
+	/* Mask off bits that are write as 0, read as undefined */
+	pSPI->CFG = pSPI->CFG & (SPI_CFG_BITMASK & ~bits);
+}
+
+/**
+ * @brief	Enable SPI peripheral
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_Enable(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPI_EN);
+}
+
+/**
+ * @brief	Disable SPI peripheral
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_Disable(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPI_EN);
+}
+
+/**
+ * @brief   Initialize the SPI
+ * @param	pSPI	: The base SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_Init(LPC_SPI_T *pSPI)
+{
+	if (pSPI == LPC_SPI1) {
+		Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_SPI1);
+		Chip_SYSCON_PeriphReset(RESET_SPI1);
+	}
+	else {
+		Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_SPI0);
+		Chip_SYSCON_PeriphReset(RESET_SPI0);
+	}
+}
+
+/**
+ * @brief	Disable SPI operation
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note	The SPI controller is disabled.
+ */
+__STATIC_INLINE void Chip_SPI_DeInit(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_Disable(pSPI);
+	if (pSPI == LPC_SPI1) {
+		Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_SPI1);
+	}
+	else {
+		Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_SPI0);
+	}
+}
+
+/**
+ * @brief	Enable SPI master mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note SPI slave mode will be disabled with this call. All SPI SSEL
+ * lines will also be deasserted.
+ */
+__STATIC_INLINE void Chip_SPI_EnableMasterMode(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_MASTER_EN);
+
+	/* Deassert all chip selects, only in master mode */
+	pSPI->TXCTRL = SPI_TXDATCTL_DEASSERT_ALL;
+}
+
+/**
+ * @brief	Enable SPI slave mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note SPI master mode will be disabled with this call.
+ */
+__STATIC_INLINE void Chip_SPI_EnableSlaveMode(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_MASTER_EN);
+}
+
+/**
+ * @brief	Enable LSB First transfers
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_EnableLSBFirst(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
+}
+
+/**
+ * @brief	Enable MSB First transfers
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_EnableMSBFirst(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LSB_FIRST_EN);
+}
+
+/** @brief SPI Clock Mode*/
+typedef enum IP_SPI_CLOCK_MODE {
+	SPI_CLOCK_CPHA0_CPOL0 = SPI_CFG_CPOL_LO | SPI_CFG_CPHA_FIRST,		/**< CPHA = 0, CPOL = 0 */
+	SPI_CLOCK_MODE0 = SPI_CLOCK_CPHA0_CPOL0,							/**< Alias for CPHA = 0, CPOL = 0 */
+	SPI_CLOCK_CPHA1_CPOL0 = SPI_CFG_CPOL_LO | SPI_CFG_CPHA_SECOND,		/**< CPHA = 0, CPOL = 1 */
+	SPI_CLOCK_MODE1 = SPI_CLOCK_CPHA1_CPOL0,							/**< Alias for CPHA = 0, CPOL = 1 */
+	SPI_CLOCK_CPHA0_CPOL1 = SPI_CFG_CPOL_HI | SPI_CFG_CPHA_FIRST,		/**< CPHA = 1, CPOL = 0 */
+	SPI_CLOCK_MODE2 = SPI_CLOCK_CPHA0_CPOL1,							/**< Alias for CPHA = 1, CPOL = 0 */
+	SPI_CLOCK_CPHA1_CPOL1 = SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND,		/**< CPHA = 1, CPOL = 1 */
+	SPI_CLOCK_MODE3 = SPI_CLOCK_CPHA1_CPOL1,							/**< Alias for CPHA = 1, CPOL = 1 */
+} SPI_CLOCK_MODE_T;
+
+/**
+ * @brief	Set SPI mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	mode	: SPI mode to set the SPI interface to
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_SetSPIMode(LPC_SPI_T *pSPI, SPI_CLOCK_MODE_T mode)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, (SPI_CFG_CPOL_HI | SPI_CFG_CPHA_SECOND));
+	Chip_SPI_SetCFGRegBits(pSPI, (uint32_t) mode);
+}
+
+/**
+ * @brief	Set polarity on the SPI chip select high
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	csNum	: Chip select number, 0 - 3
+ * @return	Nothing
+ * @note	SPI chip select polarity is active high.
+ */
+__STATIC_INLINE void Chip_SPI_SetCSPolHigh(LPC_SPI_T *pSPI, uint8_t csNum)
+{
+	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
+}
+
+/**
+ * @brief	Set polarity on the SPI chip select low
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	csNum	: Chip select number, 0 - 3
+ * @return	Nothing
+ * @note	SPI chip select polarity is active low.
+ */
+__STATIC_INLINE void Chip_SPI_SetCSPolLow(LPC_SPI_T *pSPI, uint8_t csNum)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_SPOLNUM_HI(csNum));
+}
+
+/** SPI configuration structure used for setting up master/slave mode, LSB or
+ * MSB first, and SPI mode in a single function call. */
+typedef struct {
+	uint32_t master             : 8;	/* Set to non-0 value to use master mode, 0 for slave */
+	uint32_t lsbFirst           : 8;	/* Set to non-0 value to send LSB first, 0 for MSB first */
+	SPI_CLOCK_MODE_T mode       : 8;	/* Mode selection */
+	uint32_t reserved           : 8;	/* Reserved, for alignment only */
+} SPI_CFGSETUP_T;
+
+/**
+ * @brief	Setup SPI configuration
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	pCFG	: Pointer to SPI configuration structure
+ * @return	Nothing
+ */
+void Chip_SPI_ConfigureSPI(LPC_SPI_T *pSPI, SPI_CFGSETUP_T *pCFG);
+
+/**
+ * @brief	Get the current status of SPI controller
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	SPI Status (Or-ed bit value of SPI_STAT_*)
+ * @note	Mask the return value with a value of type SPI_STAT_* to determine
+ * if that status is active.
+ */
+__STATIC_INLINE uint32_t Chip_SPI_GetStatus(LPC_SPI_T *pSPI)
+{
+	return pSPI->STAT;
+}
+
+/**
+ * @brief	Clear SPI status
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	Flag	: Clear Flag (Or-ed bit value of SPI_STAT_*)
+ * @return	Nothing
+ * @note	Only SPI_STAT_RXOV, SPI_STAT_TXUR, SPI_STAT_SSA, and
+ * SPI_STAT_SSD statuses can be cleared.
+ */
+__STATIC_INLINE void Chip_SPI_ClearStatus(LPC_SPI_T *pSPI, uint32_t Flag)
+{
+	pSPI->STAT = Flag;
+}
+
+/**
+ * @brief	Enable a SPI interrupt
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	intMask	: Or'ed value of SPI_INTENSET_* values to enable
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_EnableInts(LPC_SPI_T *pSPI, uint32_t intMask)
+{
+	pSPI->INTENSET = intMask;
+}
+
+/**
+ * @brief	Disable a SPI interrupt
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	intMask	: Or'ed value of SPI_INTENCLR_* values to disable
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_DisableInts(LPC_SPI_T *pSPI, uint32_t intMask)
+{
+	pSPI->INTENCLR = intMask;
+}
+
+/**
+ * @brief	Return enabled SPI interrupts
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	An Or'ed value of SPI_INTENSET_* values
+ * @note	Mask the return value with a SPI_INTENSET_* value to determine
+ * if the interrupt is enabled.
+ */
+__STATIC_INLINE uint32_t Chip_SPI_GetEnabledInts(LPC_SPI_T *pSPI)
+{
+	return pSPI->INTENSET;
+}
+
+/**
+ * @brief	Return pending SPI interrupts
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	An Or'ed value of SPI_INTSTAT_* values
+ * @note	Mask the return value with a SPI_INTSTAT_* value to determine
+ * if the interrupt is pending.
+ */
+__STATIC_INLINE uint32_t Chip_SPI_GetPendingInts(LPC_SPI_T *pSPI)
+{
+	return pSPI->INTSTAT;
+}
+
+/**
+ * @brief	Flush FIFOs
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_FlushFifos(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_Disable(pSPI);
+	Chip_SPI_Enable(pSPI);
+}
+
+/**
+ * @brief	Read raw data from receive FIFO with status bits
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Current value in receive data FIFO plus status bits
+ */
+__STATIC_INLINE uint32_t Chip_SPI_ReadRawRXFifo(LPC_SPI_T *pSPI)
+{
+	return pSPI->RXDAT;
+}
+
+/**
+ * @brief	Read data from receive FIFO masking off status bits
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Current value in receive data FIFO
+ * @note	The return value is masked with 0xFFFF to not exceed 16-bits. All
+ * other status bits are thrown away. This register should only be read if it
+ * has data in it. This function is useful for systems that don't need SPI
+ * select (SSEL) monitoring.
+ */
+__STATIC_INLINE uint32_t Chip_SPI_ReadRXData(LPC_SPI_T *pSPI)
+{
+	return pSPI->RXDAT & 0xFFFF;
+}
+
+/**
+ * @brief	Write data to transmit FIFO
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	data	: Data to write
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_WriteTXData(LPC_SPI_T *pSPI, uint16_t data)
+{
+	pSPI->TXDAT = (uint32_t) data;
+}
+
+/**
+ * @brief	Set SPI TXCTRL register control options
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	bits	: TXCTRL register bits to set, amd OR'ed value of SPI_TXDATCTL_* definitions
+ * @return	Nothing
+ * @note	This function safely sets only the selected bits in the SPI TXCTRL register.
+ * It can be used to enable multiple bits at once.
+ */
+__STATIC_INLINE void Chip_SPI_SetTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
+{
+	pSPI->TXCTRL = (pSPI->TXCTRL | bits) & SPI_TXDATCTL_CTRLMASK;
+}
+
+/**
+ * @brief	Clear SPI TXCTRL register control options
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	bits	: TXCTRL register bits to clear, amd OR'ed value of SPI_TXDATCTL_* definitions
+ * @return	Nothing
+ * @note	This function safely clears only the selected bits in the SPI TXCTRL register.
+ * It can be used to disable multiple bits at once.
+ */
+__STATIC_INLINE void Chip_SPI_ClearTXCTRLRegBits(LPC_SPI_T *pSPI, uint32_t bits)
+{
+	pSPI->TXCTRL = pSPI->TXCTRL & (SPI_TXDATCTL_CTRLMASK & ~bits);
+}
+
+/**
+ * @brief	Set TX control options (safe)
+ * @param	pSPI		: The base of SPI peripheral on the chip
+ * @param	ctrlBits	: Or'ed control bits to set
+ * @return	Nothing
+ * @note	Selectable control states include SPI_TXCTL_DEASSERTNUM_SSEL(0/1/2/3),
+ * SPI_TXCTL_EOT, SPI_TXCTL_EOF, SPI_TXCTL_RXIGNORE, and SPI_TXCTL_FLEN(bits).
+ */
+__STATIC_INLINE void Chip_SPI_SetTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
+{
+	Chip_SPI_SetTXCTRLRegBits(pSPI, ctrlBits);
+}
+
+/**
+ * @brief	Clear TX control options (safe)
+ * @param	pSPI		: The base of SPI peripheral on the chip
+ * @param	ctrlBits	: Or'ed control bits to clear
+ * @return	Nothing
+ * @note	Selectable control states include SPI_TXCTL_DEASSERTNUM_SSEL(0/1/2/3),
+ * SPI_TXCTL_EOT, SPI_TXCTL_EOF, SPI_TXCTL_RXIGNORE, and SPI_TXCTL_FLEN(bits).
+ */
+__STATIC_INLINE void Chip_SPI_ClearTXCtl(LPC_SPI_T *pSPI, uint32_t ctrlBits)
+{
+	Chip_SPI_ClearTXCTRLRegBits(pSPI, ctrlBits);
+}
+
+/**
+ * @brief	Set TX data transfer size in bits
+ * @param	pSPI		: The base of SPI peripheral on the chip
+ * @param	ctrlBits	: Number of bits to transmit and receive, must be 1 to 16
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPI_SetXferSize(LPC_SPI_T *pSPI, uint32_t ctrlBits)
+{
+	Chip_SPI_ClearTXCTRLRegBits(pSPI, SPI_TXCTL_FLENMASK);
+	Chip_SPI_SetTXCTRLRegBits(pSPI, SPI_TXCTL_FLEN(ctrlBits));
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPI_COMMON_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/spim_5410x.h ./chip/inc/spim_5410x.h
--- a_tnusFF/chip/inc/spim_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/spim_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,250 @@
+/*
+ * @brief LPC5410X SPI master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPIM_5410X_H_
+#define __SPIM_5410X_H_
+
+#include "spi_common_5410x.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SPI_MASTER_5410X CHIP: LPC5410X SPI master driver
+ * @ingroup SPI_COMMON_5410X
+ * @{
+ */
+
+/**
+ * @brief	Get SPI master bit rate
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	The actual SPI clock bit rate
+ */
+uint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI);
+
+/**
+ * @brief	Set SPI master bit rate
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	rate	: Desired clock bit rate for the SPI interface
+ * @return	The actual SPI clock bit rate
+ * @note	This function will set the SPI clock divider to get closest
+ * to the desired rate as possible.
+ */
+uint32_t Chip_SPIM_SetClockRate(LPC_SPI_T *pSPI, uint32_t rate);
+
+/**
+ * @brief SPI Delay Configure Struct
+ */
+typedef struct {
+	uint8_t PreDelay;					/** Pre-delay value in SPI clocks, 0 - 15 */
+	uint8_t PostDelay;					/** Post-delay value in SPI clocks, 0 - 15 */
+	uint8_t FrameDelay;					/** Delay value between frames of a transfer in SPI clocks, 0 - 15 */
+	uint8_t TransferDelay;				/** Delay value between transfers in SPI clocks, 1 - 16 */
+} SPIM_DELAY_CONFIG_T;
+
+/**
+ * @brief	Config SPI Delay parameters
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	pConfig	: SPI Delay Configure Struct
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPIM_DelayConfig(LPC_SPI_T *pSPI, SPIM_DELAY_CONFIG_T *pConfig)
+{
+	pSPI->DLY = (SPI_DLY_PRE_DELAY(pConfig->PreDelay) |
+				 SPI_DLY_POST_DELAY(pConfig->PostDelay) |
+				 SPI_DLY_FRAME_DELAY(pConfig->FrameDelay) |
+				 SPI_DLY_TRANSFER_DELAY(pConfig->TransferDelay - 1));
+}
+
+/**
+ * @brief	Forces an end of transfer for the current master transfer
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note	Use this function to perform an immediate end of trasnfer for the
+ * current master operation. If the master is currently transferring data started
+ * with the Chip_SPIM_Xfer function, this terminates the transfer after the
+ * current byte completes and completes the transfer.
+ */
+__STATIC_INLINE void Chip_SPIM_ForceEndOfTransfer(LPC_SPI_T *pSPI)
+{
+	pSPI->STAT = SPI_STAT_EOT;
+}
+
+/**
+ * @brief	Assert a SPI select
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	sselNum	: SPI select to assert, 0 - 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPIM_AssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum)
+{
+	pSPI->TXCTRL = pSPI->TXCTRL & (SPI_TXDATCTL_CTRLMASK & ~SPI_TXDATCTL_DEASSERTNUM_SSEL(sselNum));
+}
+
+/**
+ * @brief	Deassert a SPI select
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	sselNum	: SPI select to deassert, 0 - 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPIM_DeAssertSSEL(LPC_SPI_T *pSPI, uint8_t sselNum)
+{
+	pSPI->TXCTRL = (pSPI->TXCTRL | SPI_TXDATCTL_DEASSERTNUM_SSEL(sselNum)) & SPI_TXDATCTL_CTRLMASK;
+}
+
+/**
+ * @brief	Enable loopback mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ * @note	Serial input is taken from the serial output (MOSI or MISO) rather
+ * than the serial input pin.
+ */
+__STATIC_INLINE void Chip_SPIM_EnableLoopBack(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_SetCFGRegBits(pSPI, SPI_CFG_LBM_EN);
+}
+
+/**
+ * @brief	Disable loopback mode
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SPIM_DisableLoopBack(LPC_SPI_T *pSPI)
+{
+	Chip_SPI_ClearCFGRegBits(pSPI, SPI_CFG_LBM_EN);
+}
+
+/**
+ * @brief	Event handler ID passed during a call-back event
+ */
+typedef enum {
+	SPIM_EVT_SSELASSERT,			/**< Event identifier for Slave Assert */
+	SPIM_EVT_SSELDEASSERT,			/**< Event identifier for Slave deassert */
+	SPIM_EVT_TXDONE,				/**< Event identifier for TX complete */
+	SPIM_EVT_RXDONE,				/**< Event identifier for RX complete */
+} SPIM_EVENT_T;
+
+/** @brief SPI Master XFER states */
+#define SPIM_XFER_STATE_IDLE         0	/**< SPI XFER is IDLE */
+#define SPIM_XFER_STATE_BUSY         1	/**< SPI XFER is busy transfering data */
+#define SPIM_XFER_STATE_DONE         2	/**< SPI XFER is complete */
+
+/** @brief	SPI master xfer options */
+#define SPIM_XFER_OPTION_EOT         (1 << 4)			/**< SPI SLAVE Select will be deasserted when xfer is done */
+#define SPIM_XFER_OPTION_EOF         (1 << 5)			/**< Insert a frame delay */
+#define SPIM_XFER_OPTION_SIZE(x)     ((((x) - 1) & 0xF) << 8)	/**< Number of bits in transfer data */
+
+/** Slave transfer data context */
+typedef struct SPIM_XFER {
+	int (*cbFunc)(SPIM_EVENT_T event, struct SPIM_XFER *xfer);	/**< Callback function for event handling; NULL when no call-back required
+																   @a event will be one of #SPIS_EVENT_T and @a xfer is pointer to xfer structure */
+
+	void *txBuff;					/**< TX buffer pointer; Must be a uint16_t pointer when transfer
+									    size is 16 bits and uint8_t pointer when transfer size is 8 bits (can be NULL only when *txCount is 0) */
+	void *rxBuff;					/**< RX buffer pointer; Must be uint16_t pointer when transfer size is 16 bits or
+									    must be uint8_t pointer when transfer is 8-bits (can be NULL only when *txCount is 0) */
+	int32_t txCount;				/**< Pointer to an int32_t memory (never initialize to NULL) that has the Size of the txBuff in items (not bytes), not modified by driver */
+	int32_t rxCount;				/**< Number of items (not bytes) to send in rxBuff buffer (Never initialize to NULL), not modified by driver */
+	int32_t txDoneCount;			/**< Total items (not bytes) transmitted (initialize to 0), modified by driver [In case of underflow txDoneCount will be greater than *txCount] */
+	int32_t rxDoneCount;			/**< Total items (not bytes) received (initialize to 0), modified by driver [In case of over flow rxDoneCount will be greater than *rxCount] */
+	uint8_t sselNum;				/**< Slave number assigned to this transfer, 0 - 3, modified by driver */
+	uint8_t state;					/**< Initialize to #SPIS_XFER_STATE_IDLE; driver sets to #SPIS_XFER_STATE_BUSY or #SPIS_XFER_STATE_DONE */
+	uint16_t options;				/**< SPI Transfer options (or'd values of #SPIM_XFER_OPTION_EOT, #SPIM_XFER_OPTION_EOF, #SPIM_XFER_OPTION_SIZE) */
+} SPIM_XFER_T;
+
+/**
+ * @brief	SPI master transfer state change handler
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
+ * @return	Nothing
+ * @note	See @ref SPIM_XFER_T for more information on this function. When using
+ * this function, the SPI master interrupts should be enabled and setup in the SPI
+ * interrupt handler to call this function when they fire. This function is meant
+ * to be called from the interrupt handler.
+ */
+void Chip_SPIM_XferHandler(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
+
+/**
+ * @brief	Start non-blocking SPI master transfer
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
+ * @return	Nothing
+ * @note	This function starts a non-blocking SPI master transfer with the
+ * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
+ * started, the interrupt handler must call Chip_SPIM_XferHandler to keep the
+ * transfer going and fed with data. This function should only be called when
+ * the master is idle.<br>
+ *
+ * This function must be called with the options and sselNum fields correctly
+ * setup. Initial data buffers and the callback pointer must also be setup. No
+ * sanity checks are performed on the passed data.<br>
+ *
+ * Example call:<br>
+ * SPIM_XFER_T mxfer;
+ * mxfer.pCB = (&)masterCallbacks;
+ * mxfer.sselNum = 2; // Use chip select 2
+ * mxfer.options = SPI_TXCTL_FLEN(8); // 8 data bits, supports 1 - 16 bits
+ * mxfer.options |= SPI_TXCTL_EOT | SPI_TXCTL_EOF; // Apply frame and transfer delays to master transfer
+ * mxfer.options |= SPI_TXCTL_RXIGNORE; // Ignore RX data, will toss receive data regardless of pRXData8 or pRXData16 buffer
+ * mxfer.pTXData8 = SendBuffer;
+ * mxfer.txCount = 16; // Number of bytes to send before SPIMasterXferSend callback is called
+ * mxfer.pRXData8 = RecvBuffer; // Will not receive data if pRXData8/pRXData16 is NULL or SPI_TXCTL_RXIGNORE option is set
+ * mxfer.rxCount = 16; // Number of bytes to receive before SPIMasterXferRecv callback is called
+ * Chip_SPIM_Xfer(LPC_SPI0, &mxfer); // Start transfer
+ *
+ * Note that the transfer, once started, needs to be constantly fed by the callbacks.
+ * The txCount and rxCount field only indicate the buffer size before the callbacks are called.
+ * To terminate the transfer, the SPIMasterXferSend callback must set the terminate field.
+ */
+void Chip_SPIM_Xfer(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
+
+/**
+ * @brief	Perform blocking SPI master transfer
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIM_XFER_T structure see notes below
+ * @return	Nothing
+ * @note	This function starts a blocking SPI master transfer with the
+ * parameters setup in the passed @ref SPIM_XFER_T structure. Once the transfer is
+ * started, the callbacks in Chip_SPIM_XferHandler may be called to keep the
+ * transfer going and fed with data. SPI interrupts must be disabled prior to
+ * calling this function. It is not recommended to use this function.<br>
+ */
+void Chip_SPIM_XferBlocking(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPIM_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/spis_5410x.h ./chip/inc/spis_5410x.h
--- a_tnusFF/chip/inc/spis_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/spis_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,133 @@
+/*
+ * @brief LPC5410X SPI slave driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SPIS_5410X_H_
+#define __SPIS_5410X_H_
+
+#include "spi_common_5410x.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SPI_SLAVE_5410X CHIP: LPC5410X SPI slave driver
+ * @ingroup SPI_COMMON_5410X
+ * @{
+ */
+
+/**
+ * @brief	Event handler ID passed during a call-back event
+ */
+typedef enum {
+	SPIS_EVT_SSELASSERT,			/**< Event identifier for Slave Assert */
+	SPIS_EVT_SSELDEASSERT,			/**< Event identifier for Slave deassert */
+	SPIS_EVT_TXDONE,				/**< Event identifier for TX complete */
+	SPIS_EVT_RXDONE,				/**< Event identifier for RX complete */
+} SPIS_EVENT_T;
+
+/** @brief SPI XFER states */
+#define SPIS_XFER_STATE_IDLE         0	/**< SPI XFER is IDLE */
+#define SPIS_XFER_STATE_BUSY         1	/**< SPI XFER is busy transfering data */
+#define SPIS_XFER_STATE_DONE         2	/**< SPI XFER is complete */
+
+/** Slave transfer data context */
+typedef struct SPIS_XFER {
+	int (*cbFunc)(SPIS_EVENT_T event, struct SPIS_XFER *xfer);	/**< Callback function for event handling; NULL when no call-back required
+																   @a event will be one of #SPIS_EVENT_T and @a xfer is pointer to xfer structure [Return value ignored] */
+
+	void *txBuff;					/**< TX buffer pointer; Must be a uint16_t pointer when transfer
+									    size is 16 bits and uint8_t pointer when transfer size is 8 bits */
+	void *rxBuff;					/**< RX buffer pointer; Must be uint16_t pointer when transfer size is 16 bits or
+									    must be uint8_t pointer when transfer is 8-bits */
+	int32_t txCount;				/**< Pointer to an int32_t memory (never initialize to NULL) that has the Size of the txBuff in items (not bytes), not modified by driver */
+	int32_t rxCount;				/**< Number of items (not bytes) to send in rxBuff buffer (Never initialize to NULL), not modified by driver */
+	int32_t txDoneCount;			/**< Total items (not bytes) transmitted (initialize to 0), modified by driver [In case of underflow txDoneCount will be greater than *txCount] */
+	int32_t rxDoneCount;			/**< Total items (not bytes) received (initialize to 0), modified by driver [In case of over flow rxDoneCount will be greater than *rxCount] */
+	uint8_t sselNum;				/**< Slave number assigned to this transfer, 0 - 3, modified by driver */
+	uint8_t state;					/**< Initialize to #SPIS_XFER_STATE_IDLE; driver sets to #SPIS_XFER_STATE_BUSY or #SPIS_XFER_STATE_DONE */
+	uint16_t reserved0;				/**< Reserved field */
+} SPIS_XFER_T;
+
+/**
+ * @brief	SPI slave transfer state change handler
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
+ * @return	returns 0 on success, or SPI_STAT_RXOV and/or SPI_STAT_TXUR on an error
+ * @note	See @ref SPIS_XFER_T for more information on this function. When using
+ * this function, the SPI slave interrupts should be enabled and setup in the SPI
+ * interrupt handler to call this function when they fire. This function is meant
+ * to be called from the interrupt handler. The @ref SPIS_XFER_T data does not need
+ * to be setup prior to the call and should be setup by the callbacks instead.<br>
+ *
+ * The callbacks are handled in the interrupt handler. If you are getting overflow
+ * or underflow errors, you might need to lower the speed of the master clock or
+ * extend the master's select assetion time.<br>
+ */
+uint32_t Chip_SPIS_XferHandler(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
+
+/**
+ * @brief	Pre-buffers slave transmit data
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIS_XFER_T structure see notes below
+ * @return	Nothing
+ * @note Pre-buffering allows the slave to prime the transmit FIFO with data prior to
+ * the master starting a transfer. If data is not pre-buffered, the initial slave
+ * transmit data will always be 0x0 with a slave transmit underflow status.
+ * Pre-buffering is best used when only a single slave select is used by an
+ * application.
+ */
+__STATIC_INLINE void Chip_SPIS_PreBuffSlave(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
+{
+	Chip_SPIS_XferHandler(pSPI, xfer);
+}
+
+/**
+ * @brief	SPI slave transfer blocking function
+ * @param	pSPI	: The base of SPI peripheral on the chip
+ * @param	xfer	: Pointer to a SPIS_XFER_T structure
+ * @return	returns 0 on success, or SPI_STAT_RXOV and/or SPI_STAT_TXUR on an error
+ * @note	This function performs a blocking transfer on the SPI slave interface.
+ * It is not recommended to use this function. Once this function is called, it
+ * will block forever until a slave transfer consisting of a slave SSEL assertion,
+ * and de-assertion occur. The callbacks are still used for slave data buffer
+ * management. SPI interrupts must be disabled prior to calling this function.
+ */
+uint32_t Chip_SPIS_XferBlocking(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SPIS_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/stopwatch.h ./chip/inc/stopwatch.h
--- a_tnusFF/chip/inc/stopwatch.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/stopwatch.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,137 @@
+/*
+ * @brief Common stopwatch support
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __STOPWATCH_H_
+#define __STOPWATCH_H_
+
+#include "cmsis.h"
+
+/** @defgroup Stop_Watch CHIP: Stopwatch primitives.
+ * @ingroup CHIP_Common
+ * @{
+ */
+
+/**
+ * @brief	Initialize stopwatch
+ * @return	Nothing
+ */
+void StopWatch_Init(void);
+
+/**
+ * @brief	Start a stopwatch
+ * @return	Current cycle count
+ */
+uint32_t StopWatch_Start(void);
+
+/**
+ * @brief      Returns number of ticks elapsed since stopwatch was started
+ * @param      startTime	: Time returned by StopWatch_Start().
+ * @return     Number of ticks elapsed since stopwatch was started
+ */
+__STATIC_INLINE uint32_t StopWatch_Elapsed(uint32_t startTime)
+{
+	return StopWatch_Start() - startTime;
+}
+
+/**
+ * @brief	Returns number of ticks per second of the stopwatch timer
+ * @return	Number of ticks per second of the stopwatch timer
+ */
+uint32_t StopWatch_TicksPerSecond(void);
+
+/**
+ * @brief	Converts from stopwatch ticks to mS.
+ * @param	ticks	: Duration in ticks to convert to mS.
+ * @return	Number of mS in given number of ticks
+ */
+uint32_t StopWatch_TicksToMs(uint32_t ticks);
+
+/**
+ * @brief	Converts from stopwatch ticks to uS.
+ * @param	ticks	: Duration in ticks to convert to uS.
+ * @return	Number of uS in given number of ticks
+ */
+uint32_t StopWatch_TicksToUs(uint32_t ticks);
+
+/**
+ * @brief	Converts from mS to stopwatch ticks.
+ * @param	mS	: Duration in mS to convert to ticks.
+ * @return	Number of ticks in given number of mS
+ */
+uint32_t StopWatch_MsToTicks(uint32_t mS);
+
+/**
+ * @brief	Converts from uS to stopwatch ticks.
+ * @param	uS	: Duration in uS to convert to ticks.
+ * @return	Number of ticks in given number of uS
+ */
+uint32_t StopWatch_UsToTicks(uint32_t uS);
+
+/**
+ * @brief	Delays the given number of ticks using stopwatch primitives
+ * @param	ticks	: Number of ticks to delay
+ * @return	Nothing
+ */
+__STATIC_INLINE void StopWatch_DelayTicks(uint32_t ticks)
+{
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief	Delays the given number of mS using stopwatch primitives
+ * @param	mS	: Number of mS to delay
+ * @return	Nothing
+ */
+__STATIC_INLINE void StopWatch_DelayMs(uint32_t mS)
+{
+	uint32_t ticks = StopWatch_MsToTicks(mS);
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @brief	Delays the given number of uS using stopwatch primitives
+ * @param	uS	: Number of uS to delay
+ * @return	Nothing
+ */
+__STATIC_INLINE void StopWatch_DelayUs(uint32_t uS)
+{
+	uint32_t ticks = StopWatch_UsToTicks(uS);
+	uint32_t startTime = StopWatch_Start();
+	while (StopWatch_Elapsed(startTime) < ticks) {}
+}
+
+/**
+ * @}
+ */
+
+#endif /* __STOPWATCH_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/syscon_5410x.h ./chip/inc/syscon_5410x.h
--- a_tnusFF/chip/inc/syscon_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/syscon_5410x.h	2016-10-22 23:17:43.572840278 -0300
@@ -0,0 +1,575 @@
+/*
+ * @brief LPC5410X System & Control driver inclusion file
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __SYSCON_5410X_H_
+#define __SYSCON_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup SYSCON_5410X CHIP: LPC5410X System and Control Driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief LPC5410X Main system configuration register block structure
+ */
+typedef struct {
+	__IO uint32_t SYSMEMREMAP;			/*!< System Remap register */
+	__I  uint32_t RESERVED0[4];
+	__IO uint32_t SYSTCKCAL;			/*!< System Tick Calibration register */
+	__I  uint32_t RESERVED1[1];
+	__IO uint32_t NMISRC;				/*!< NMI Source select register */
+	__IO uint32_t ASYNCAPBCTRL;			/*!< Asynch APB chiplet control register */
+	__I  uint32_t RESERVED2[7];
+	__IO uint32_t SYSRSTSTAT;			/*!< System Reset Stat register */
+	__IO uint32_t PRESETCTRL[2];		/*!< Peripheral Reset Ctrl register */
+	__IO uint32_t PRESETCTRLSET[2];		/*!< Peripheral Reset Ctrl Set register */
+	__IO uint32_t PRESETCTRLCLR[2];		/*!< Peripheral Reset Ctrl Clr register */
+	__IO uint32_t PIOPORCAP[2];			/*!< PIO Power-On Reset Capture register */
+	__I  uint32_t RESERVED3[1];
+	__IO uint32_t PIORESCAP[2];			/*!< PIO Pad Reset Capture register */
+	__I  uint32_t RESERVED4[4];
+	__IO uint32_t MAINCLKSELA;			/*!< Main Clk sel Source Sel A register */
+	__IO uint32_t MAINCLKSELB;			/*!< Main Clk sel Source Sel B register */
+	__I  uint32_t RESERVED5;
+	__IO uint32_t ADCCLKSEL;			/*!< ADC Async Clk Sel register */
+	__I  uint32_t RESERVED6;
+	__IO uint32_t CLKOUTSELA;			/*!< Clk Out Sel Source A register */
+	__IO uint32_t CLKOUTSELB;			/*!< Clk Out Sel Source B register */
+	__I  uint32_t RESERVED7;
+	__IO uint32_t SYSPLLCLKSEL;			/*!< System PLL Clk Selregister */
+	__I  uint32_t RESERVED8[7];
+	__IO uint32_t AHBCLKCTRL[2];		/*!< AHB Peripheral Clk Enable register */
+	__IO uint32_t AHBCLKCTRLSET[2];		/*!< AHB Peripheral Clk Enable Set register */
+	__IO uint32_t AHBCLKCTRLCLR[2];		/*!< AHB Peripheral Clk Enable Clr register */
+	__I  uint32_t RESERVED9[2];
+	__IO uint32_t SYSTICKCLKDIV;		/*!< Systick Clock divider register */
+	__I  uint32_t RESERVED10[7];
+	__IO uint32_t AHBCLKDIV;			/*!< Main Clk Divider register */
+	__IO uint32_t RESERVED11;
+	__IO uint32_t ADCCLKDIV;			/*!< ADC Async Clk Divider register */
+	__IO uint32_t CLKOUTDIV;			/*!< Clk Out Divider register */
+	__I  uint32_t RESERVED12[4];
+	__IO uint32_t FREQMECTRL;			/*!< Frequency Measure Control register */
+	__IO uint32_t FLASHCFG;				/*!< Flash Config register */
+	__I  uint32_t RESERVED13[8];
+	__IO uint32_t FIFOCTRL;				/*!< VFIFO control register */
+	__I  uint32_t RESERVED14[14];
+	__I  uint32_t RESERVED15[1];
+	__I  uint32_t RESERVED16[2];
+	__IO uint32_t RTCOSCCTRL;			/*!< RTC Oscillator Control register */
+	__I  uint32_t RESERVED17[7];
+	__IO uint32_t SYSPLLCTRL;			/*!< System PLL control register */
+	__IO uint32_t SYSPLLSTAT;			/*!< PLL status register */
+	__IO uint32_t SYSPLLNDEC;			/*!< PLL N decoder register */
+	__IO uint32_t SYSPLLPDEC;			/*!< PLL P decoder register */
+	__IO uint32_t SYSPLLSSCTRL[2];	/*!< Spread Spectrum control registers */
+	__I  uint32_t RESERVED18[18];
+	__IO uint32_t PDRUNCFG;				/*!< Power Down Run Config register */
+	__IO uint32_t PDRUNCFGSET;			/*!< Power Down Run Config Set register */
+	__IO uint32_t PDRUNCFGCLR;			/*!< Power Down Run Config Clr register */
+	__I  uint32_t RESERVED19[9];
+	__IO uint32_t STARTERP[2];			/*!< Start Signal Enable Register */
+	__IO uint32_t STARTERSET[2];		/*!< Start Signal Enable Set Register */
+	__IO uint32_t STARTERCLR[2];		/*!< Start Signal Enable Clr Register */
+	__I  uint32_t RESERVED20[42];
+	__I  uint32_t RESERVED20A[4];
+	__I  uint32_t RESERVED21[57];
+	__IO uint32_t JTAG_IDCODE;
+	__IO uint32_t DEVICE_ID0;			/*!< Boot ROM and die revision register */
+	__IO uint32_t DEVICE_ID1;			/*!< Boot ROM and die revision register */
+} LPC_SYSCON_T;
+
+/**
+ * @brief LPC5410X Asynchronous system configuration register block structure
+ */
+typedef struct {
+	__IO uint32_t AYSNCPRESETCTRL;		/*!< peripheral reset register */
+	__IO uint32_t ASYNCPRESETCTRLSET;	/*!< peripheral reset Set register */
+	__IO uint32_t ASYNCPRESETCTRLCLR;	/*!< peripheral reset Clr register */
+	__I  uint32_t RESERVED0;
+	__IO uint32_t ASYNCAPBCLKCTRL;		/*!< clk enable register */
+	__IO uint32_t ASYNCAPBCLKCTRLSET;	/*!< clk enable Set register */
+	__IO uint32_t ASYNCAPBCLKCTRLCLR;	/*!< clk enable Clr register */
+	__I  uint32_t RESERVED1;
+	__IO uint32_t ASYNCAPBCLKSELA;		/*!< clk source mux A register */
+	__IO uint32_t ASYNCAPBCLKSELB;		/*!< clk source mux B register */
+	__IO uint32_t ASYNCCLKDIV;			/*!< clk div register */
+	__I  uint32_t RESERVED2;
+	__IO uint32_t FRGCTRL;				/*!< Fraction Rate Generator Ctrl register */
+} LPC_ASYNC_SYSCON_T;
+
+/**
+ * System memory remap modes used to remap interrupt vectors
+ */
+typedef enum CHIP_SYSCON_BOOT_MODE_REMAP {
+	REMAP_BOOT_LOADER_MODE,	/*!< Interrupt vectors are re-mapped to Boot ROM */
+	REMAP_USER_RAM_MODE,	/*!< Interrupt vectors are re-mapped to user Static RAM */
+	REMAP_USER_FLASH_MODE	/*!< Interrupt vectors are not re-mapped and reside in Flash */
+} CHIP_SYSCON_BOOT_MODE_REMAP_T;
+
+/** @brief V4 CHIP PART ID */
+#define V4_UID              (0x08C1FECE)
+
+/**
+ * @brief	Re-map interrupt vectors
+ * @param	remap	: system memory map value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_Map(CHIP_SYSCON_BOOT_MODE_REMAP_T remap)
+{
+	LPC_SYSCON->SYSMEMREMAP = (uint32_t) remap;
+}
+
+/**
+ * @brief	Get system remap setting
+ * @return	System remap setting
+ */
+__STATIC_INLINE CHIP_SYSCON_BOOT_MODE_REMAP_T Chip_SYSCON_GetMemoryMap(void)
+{
+	return (CHIP_SYSCON_BOOT_MODE_REMAP_T) LPC_SYSCON->SYSMEMREMAP;
+}
+
+/**
+ * @brief	Set System tick timer calibration value
+ * @param	sysCalVal	: System tick timer calibration value
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_SetSYSTCKCAL(uint32_t sysCalVal)
+{
+	LPC_SYSCON->SYSTCKCAL = sysCalVal;
+}
+
+/**
+ * Non-Maskable Interrupt Enable/Disable value
+ */
+#define SYSCON_NMISRC_M0_ENABLE   ((uint32_t) 1 << 30)	/*!< Enable the Non-Maskable Interrupt M0 (NMI) source */
+#define SYSCON_NMISRC_M4_ENABLE   ((uint32_t) 1 << 31)	/*!< Enable the Non-Maskable Interrupt M4 (NMI) source */
+
+/**
+ * @brief	Set source for non-maskable interrupt (NMI)
+ * @param	intsrc	: IRQ number to assign to the NMI
+ * @return	Nothing
+ * @note	The NMI source will be disabled upon exiting this function. Use the
+ * Chip_SYSCON_EnableNMISource() function to enable the NMI source.
+ */
+void Chip_SYSCON_SetNMISource(uint32_t intsrc);
+
+/**
+ * @brief	Enable interrupt used for NMI source
+ * @return	Nothing
+ */
+void Chip_SYSCON_EnableNMISource(void);
+
+/**
+ * @brief	Disable interrupt used for NMI source
+ * @return	Nothing
+ */
+void Chip_SYSCON_DisableNMISource(void);
+
+/**
+ * @brief	Enable or disable asynchronous APB bridge and subsystem
+ * @param	enable	: true to enable, false to disable
+ * @return	Nothing
+ * @note	This bridge must be enabled to access peripherals on the
+ * associated bridge.
+ */
+void Chip_SYSCON_Enable_ASYNC_Syscon(bool enable);
+
+/**
+ * @brief	Set UART Fractional divider value
+ * @param	fmul	: Fractional multiplier value
+ * @param	fdiv	: Fractional divider value (Must always be 0xFF)
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_SetUSARTFRGCtrl(uint8_t fmul, uint8_t fdiv)
+{
+	LPC_ASYNC_SYSCON->FRGCTRL = ((uint32_t) fmul << 8) | fdiv;
+}
+
+/**
+ * System reset status values
+ */
+#define SYSCON_RST_POR    (1 << 0)	/*!< POR reset status */
+#define SYSCON_RST_EXTRST (1 << 1)	/*!< External reset status */
+#define SYSCON_RST_WDT    (1 << 2)	/*!< Watchdog reset status */
+#define SYSCON_RST_BOD    (1 << 3)	/*!< Brown-out detect reset status */
+#define SYSCON_RST_SYSRST (1 << 4)	/*!< software system reset status */
+
+/**
+ * @brief	Get system reset status
+ * @return	An Or'ed value of SYSCON_RST_*
+ * @note	This function returns the detected reset source(s).
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetSystemRSTStatus(void)
+{
+	return LPC_SYSCON->SYSRSTSTAT;
+}
+
+/**
+ * @brief	Clear system reset status
+ * @param	reset	: An Or'ed value of SYSCON_RST_* status to clear
+ * @return	Nothing
+ * @note	This function clears the specified reset source(s).
+ */
+__STATIC_INLINE void Chip_SYSCON_ClearSystemRSTStatus(uint32_t reset)
+{
+	LPC_SYSCON->SYSRSTSTAT = reset;
+}
+
+/**
+ * Peripheral reset identifiers
+ */
+typedef enum {
+	/* Peripheral reset enables for PRESETCTRL0 */
+	RESET_FLASH = 7,				/*!< Flash controller */
+	RESET_FMC,						/*!< Flash accelerator */
+	RESET_INMUX = 11,				/*!< Input mux */
+	RESET_IOCON = 13,				/*!< IOCON */
+	RESET_GPIO0,					/*!< GPIO Port 0 */
+	RESET_GPIO1,					/*!< GPIO Port 1 */
+	RESET_PINT = 18,				/*!< Pin interrupt */
+	RESET_GINT,						/*!< Grouped interrupt (GINT) */
+	RESET_DMA,						/*!< DMA */
+	RESET_CRC,						/*!< CRC */
+	RESET_WWDT,						/*!< Watchdog timer */
+	RESET_RTC,						/*!< RTC */
+	RESET_MAILBOX = 26,				/*!< Mailbox */
+	RESET_ADC0,						/*!< ADC0 */
+
+	/* Peripheral reset enables for PRESETCTRL1 */
+	RESET_MRT = 32 + 0,				/*!< multi-rate timer */
+	RESET_RIT,						/*!< Repetitive interrupt timer */
+	RESET_SCT0,						/*!< SCT0 */
+	RESET_FIFO = 32 + 9,			/*!< System FIFO */
+	RESET_UTICK,					/*!< Micro-tick Timer */
+	RESET_TIMER2 = 32 + 22,			/*!< TIMER2 */
+	RESET_TIMER3 = 32 + 26,			/*!< TIMER3 */
+	RESET_TIMER4,					/*!< TIMER4 */
+
+	/* Async peripheral reset enables for ASYNCPRESETCTRL */
+	RESET_USART0 = 128 + 1,			/*!< UART0 */
+	RESET_USART1,					/*!< UART1 */
+	RESET_USART2,					/*!< UART2 */
+	RESET_USART3,					/*!< UART3 */
+	RESET_I2C0,						/*!< I2C0 */
+	RESET_I2C1,						/*!< I2C1 */
+	RESET_I2C2,						/*!< I2C2 */
+	RESET_SPI0 = 128 + 9,			/*!< SPI0 */
+	RESET_SPI1,						/*!< SPI1 */
+	RESET_TIMER0 = 128 + 13,		/*!< TIMER0 */
+	RESET_TIMER1,					/*!< TIMER1 */
+	RESET_FRG0						/*!< FRG */
+} CHIP_SYSCON_PERIPH_RESET_T;
+
+/**
+ * @brief	Resets a peripheral
+ * @param	periph	:	Peripheral to reset
+ * @return	Nothing
+ * Will assert and de-assert reset for a peripheral.
+ */
+void Chip_SYSCON_PeriphReset(CHIP_SYSCON_PERIPH_RESET_T periph);
+
+/**
+ * @brief	Read POR captured PIO status
+ * @param	port	: 0 for port 0 pins, 1 for port 1 pins, 2 for port 2 pins, etc.
+ * @return	captured Power-On-Reset (POR) PIO status
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetPORPIOStatus(uint8_t port)
+{
+	return LPC_SYSCON->PIOPORCAP[port];
+}
+
+/**
+ * @brief	Read reset captured PIO status
+ * @param	port	: 0 for port 0 pins, 1 for port 1 pins, 2 for port 2 pins, etc.
+ * @return	captured reset PIO status
+ * @note	Used when reset other than a Power-On-Reset (POR) occurs.
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetResetPIOStatus(uint8_t port)
+{
+	return LPC_SYSCON->PIORESCAP[port];
+}
+
+/**
+ * @brief	Starts a frequency measurement cycle
+ * @return	Nothing
+ * @note	This function is meant to be used with the Chip_INMUX_SetFreqMeasRefClock()
+ * and Chip_INMUX_SetFreqMeasTargClock() functions.
+ */
+__STATIC_INLINE void Chip_SYSCON_StartFreqMeas(void)
+{
+	LPC_SYSCON->FREQMECTRL = 0;
+	LPC_SYSCON->FREQMECTRL = (1UL << 31);
+}
+
+/**
+ * @brief	Indicates when a frequency measurement cycle is complete
+ * @return	true if a measurement cycle is active, otherwise false
+ */
+__STATIC_INLINE bool Chip_SYSCON_IsFreqMeasComplete(void)
+{
+	return (bool) ((LPC_SYSCON->FREQMECTRL & (1UL << 31)) == 0);
+}
+
+/**
+ * @brief	Returns the raw capture value for a frequency measurement cycle
+ * @return	raw cpature value (this is not a frequency)
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetRawFreqMeasCapval(void)
+{
+	return LPC_SYSCON->FREQMECTRL & 0x3FFF;
+}
+
+/**
+ * @brief	Returns the computed value for a frequency measurement cycle
+ * @param	refClockRate	: Reference clock rate used during the frequency measurement cycle
+ * @return	Computed cpature value
+ */
+uint32_t Chip_SYSCON_GetCompFreqMeas(uint32_t refClockRate);
+
+/**
+ * @brief FLASH Access time definitions
+ */
+typedef enum {
+	SYSCON_FLASH_1CYCLE = 0,	/*!< Flash accesses use 1 CPU clock */
+	FLASHTIM_20MHZ_CPU = SYSCON_FLASH_1CYCLE,
+	SYSCON_FLASH_2CYCLE,		/*!< Flash accesses use 2 CPU clocks */
+	SYSCON_FLASH_3CYCLE,		/*!< Flash accesses use 3 CPU clocks */
+	SYSCON_FLASH_4CYCLE,		/*!< Flash accesses use 4 CPU clocks */
+	SYSCON_FLASH_5CYCLE,		/*!< Flash accesses use 5 CPU clocks */
+	SYSCON_FLASH_6CYCLE,		/*!< Flash accesses use 6 CPU clocks */
+	SYSCON_FLASH_7CYCLE,		/*!< Flash accesses use 7 CPU clocks */
+	SYSCON_FLASH_8CYCLE			/*!< Flash accesses use 8 CPU clocks */
+} SYSCON_FLASHTIM_T;
+
+/**
+ * @brief	Set FLASH memory access time in clocks
+ * @param	clks	: Clock cycles for FLASH access
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_SetFLASHAccess(SYSCON_FLASHTIM_T clks)
+{
+	uint32_t tmp;
+
+	tmp = LPC_SYSCON->FLASHCFG & ~(0xF << 12);
+
+	/* Don't alter lower bits */
+	LPC_SYSCON->FLASHCFG = tmp | ((uint32_t) clks << 12);
+}
+
+/**
+ * @brief System FIFO bit definitions
+ */
+#define SYSCON_FIFO_U0TXFIFOEN      (1 << 0)	/*!< USART0 transmitter FIFO enable bit */
+#define SYSCON_FIFO_U1TXFIFOEN      (1 << 1)	/*!< USART1 transmitter FIFO enable bit */
+#define SYSCON_FIFO_U2TXFIFOEN      (1 << 2)	/*!< USART2 transmitter FIFO enable bit */
+#define SYSCON_FIFO_U3TXFIFOEN      (1 << 3)	/*!< USART3 transmitter FIFO enable bit */
+#define SYSCON_FIFO_SPI0TXFIFOEN    (1 << 4)	/*!< SPI0 transmitter FIFO enable bit */
+#define SYSCON_FIFO_SPI1TXFIFOEN    (1 << 5)	/*!< SPI1 transmitter FIFO enable bit */
+#define SYSCON_FIFO_U0RXFIFOEN      (1 << 8)	/*!< USART0 receiver FIFO enable bit */
+#define SYSCON_FIFO_U1RXFIFOEN      (1 << 9)	/*!< USART1 receiver FIFO enable bit */
+#define SYSCON_FIFO_U2RXFIFOEN      (1 << 10)	/*!< USART2 receiver FIFO enable bit */
+#define SYSCON_FIFO_U3RXFIFOEN      (1 << 11)	/*!< USART3 receiver FIFO enable bit */
+#define SYSCON_FIFO_SPI0RXFIFOEN    (1 << 12)	/*!< SPI0 receiver FIFO enable bit */
+#define SYSCON_FIFO_SPI1RXFIFOEN    (1 << 13)	/*!< SPI1 receiver FIFO enable bit */
+
+/**
+ * @brief	Enable System FIFO(s) for a peripheral
+ * @param	enMask	: Or'ed bits or type SYSCON_FIFO_* for enabling system FIFOs
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_EnableSysFIFO(uint32_t enMask)
+{
+	LPC_SYSCON->FIFOCTRL |= enMask;
+}
+
+/**
+ * @brief	Disable System FIFO(s) for a peripheral
+ * @param	disMask	: Or'ed bits or type SYSCON_FIFO_* for disabling system FIFOs
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_DisableSysFIFO(uint32_t disMask)
+{
+	LPC_SYSCON->FIFOCTRL &= ~disMask;
+}
+
+/**
+ * Power control definition bits (0 = powered, 1 = powered down)
+ */
+#define SYSCON_PDRUNCFG_LP_VD1           (1 << 2)
+#define SYSCON_PDRUNCFG_PD_IRC_OSC       (1 << 3)		/*!< IRC oscillator output */
+#define SYSCON_PDRUNCFG_PD_IRC           (1 << 4)		/*!< IRC oscillator */
+#define SYSCON_PDRUNCFG_PD_FLASH         (1 << 5)		/*!< Flash memory */
+#define SYSCON_PDRUNCFG_PD_BOD_RST       (1 << 7)		/*!< Brown-out Detect reset */
+#define SYSCON_PDRUNCFG_PD_BOD_INTR      (1 << 8)		/*!< Brown-out Detect interrupt */
+#define SYSCON_PDRUNCFG_PD_VD2_ANA       (1 << 9)		/*!< Analog power */
+#define SYSCON_PDRUNCFG_PD_ADC0          (1 << 10)		/*!< ADC0 */
+#define SYSCON_PDRUNCFG_PD_SRAM0A        (1 << 13)		/*!< First 8 kB of SRAM0 */
+#define SYSCON_PDRUNCFG_PD_SRAM0B        (1 << 14)		/*!< Remaining portion of SRAM0 */
+#define SYSCON_PDRUNCFG_PD_SRAM1         (1 << 15)		/*!< SRAM1 */
+#define SYSCON_PDRUNCFG_PD_SRAM2         (1 << 16)		/*!< SRAM2 */
+#define SYSCON_PDRUNCFG_PD_ROM           (1 << 17)		/*!< ROM */
+#define SYSCON_PDRUNCFG_PD_VDDA_ENA      (1 << 19)		/*!< Vdda to the ADC, must be enabled for the ADC to work */
+#define SYSCON_PDRUNCFG_PD_WDT_OSC       (1 << 20)		/*!< Watchdog oscillator */
+#define SYSCON_PDRUNCFG_PD_SYS_PLL       (1 << 22)		/*!< PLL0 */
+#define SYSCON_PDRUNCFG_PD_VREFP         (1 << 23)		/*!< Vrefp to the ADC, must be enabled for the ADC to work */
+#define SYSCON_PDRUNCFG_PD_32K_OSC       (1 << 24)		/*!< 32 kHz RTC oscillator */
+#define SYSCON_PDRUNCFG_LP_VD2           (1 << 27)
+#define SYSCON_PDRUNCFG_LP_VD3           (1 << 28)
+#define SYSCON_PDRUNCFG_LP_VD8           (1UL << 29)
+
+/**
+ * @brief	Power up one or more blocks or peripherals
+ * @return	OR'ed values of SYSCON_PDRUNCFG_* values
+ * @note	A high state indicates the peripheral is powered down.
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetPowerStates(void)
+{
+	return LPC_SYSCON->PDRUNCFG;
+}
+
+/**
+ * @brief	Power down one or more blocks or peripherals
+ * @param	powerdownmask	: OR'ed values of SYSCON_PDRUNCFG_* values
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_PowerDown(uint32_t powerdownmask)
+{
+	/* Disable peripheral states by setting high */
+	LPC_SYSCON->PDRUNCFGSET = powerdownmask;
+}
+
+/**
+ * @brief	Power up one or more blocks or peripherals
+ * @param	powerupmask	: OR'ed values of SYSCON_PDRUNCFG_* values
+ * @return	Nothing
+ */
+void Chip_SYSCON_PowerUp(uint32_t powerupmask);
+
+/**
+ * Start enable enumerations - for enabling and disabling peripheral wakeup
+ */
+typedef enum {
+	SYSCON_STARTER_WWDT = 0,
+	SYSCON_STARTER_BOD,
+	SYSCON_STARTER_DMA = 3,
+	SYSCON_STARTER_GINT0,
+	SYSCON_STARTER_PINT0,
+	SYSCON_STARTER_PINT1,
+	SYSCON_STARTER_PINT2,
+	SYSCON_STARTER_PINT3,
+	SYSCON_STARTER_UTICK,
+	SYSCON_STARTER_MRT,
+	SYSCON_STARTER_TIMER0,
+	SYSCON_STARTER_TIMER1,
+	SYSCON_STARTER_TIMER2,
+	SYSCON_STARTER_TIMER3,
+	SYSCON_STARTER_TIMER4,
+	SYSCON_STARTER_SCT0,
+	SYSCON_STARTER_USART0,
+	SYSCON_STARTER_USART1,
+	SYSCON_STARTER_USART2,
+	SYSCON_STARTER_USART3,
+	SYSCON_STARTER_I2C0,
+	SYSCON_STARTER_I2C1,
+	SYSCON_STARTER_I2C2,
+	SYSCON_STARTER_SPI0,
+	SYSCON_STARTER_SPI1,
+	SYSCON_STARTER_ADC0_SEQA,
+	SYSCON_STARTER_ADC0_SEQB,
+	SYSCON_STARTER_ADC0_THCMP,
+	SYSCON_STARTER_RTC,
+	SYSCON_STARTER_MAILBOX = 31,
+	/* For M4 only */
+	SYSCON_STARTER_GINT1 = 32 + 0,
+	SYSCON_STARTER_PINT4,
+	SYSCON_STARTER_PINT5,
+	SYSCON_STARTER_PINT6,
+	SYSCON_STARTER_PINT7,
+	SYSCON_STARTER_RIT = 32 + 8,
+} CHIP_SYSCON_WAKEUP_T;
+
+/**
+ * @brief	Enables a pin's (PINT) wakeup logic
+ * @param	periphId	: Peripheral identifier
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_EnableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
+{
+	uint32_t pid = (uint32_t) periphId;
+
+	if (pid < 32) {
+		LPC_SYSCON->STARTERSET[0] = (1 << pid);
+	}
+	else {
+		LPC_SYSCON->STARTERSET[1] = (1 << (pid - 32));
+	}
+}
+
+/**
+ * @brief	Disables peripheral's wakeup logic
+ * @param	periphId	: Peripheral identifier
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_SYSCON_DisableWakeup(CHIP_SYSCON_WAKEUP_T periphId)
+{
+	uint32_t pid = (uint32_t) periphId;
+
+	if (pid < 32) {
+		LPC_SYSCON->STARTERCLR[0] = (1 << pid);
+	}
+	else {
+		LPC_SYSCON->STARTERCLR[1] = (1 << (pid - 32));
+	}
+}
+
+/**
+ * @brief	Return the device ID
+ * @return	Device ID
+ */
+__STATIC_INLINE uint32_t Chip_SYSCON_GetDeviceID(void)
+{
+	return LPC_SYSCON->DEVICE_ID0;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __SYSCON_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/timer_5410x.h ./chip/inc/timer_5410x.h
--- a_tnusFF/chip/inc/timer_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/timer_5410x.h	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,456 @@
+/*
+ * @brief LPC5410X 32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __TIMER_5410X_H_
+#define __TIMER_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup TIMER_5410X CHIP: LPC5410X 32-bit Timer driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief 32-bit Standard timer register block structure
+ */
+typedef struct {					/*!< TIMERn Structure       */
+	__IO uint32_t IR;				/*!< Interrupt Register. The IR can be written to clear interrupts. The IR can be read to identify which of eight possible interrupt sources are pending. */
+	__IO uint32_t TCR;				/*!< Timer Control Register. The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR. */
+	__IO uint32_t TC;				/*!< Timer Counter. The 32 bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR. */
+	__IO uint32_t PR;				/*!< Prescale Register. The Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC. */
+	__IO uint32_t PC;				/*!< Prescale Counter. The 32 bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface. */
+	__IO uint32_t MCR;				/*!< Match Control Register. The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs. */
+	__IO uint32_t MR[4];			/*!< Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC. */
+	__IO uint32_t CCR;				/*!< Capture Control Register. The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place. */
+	__IO uint32_t CR[4];			/*!< Capture Register. CR is loaded with the value of TC when there is an event on the CAPn.0 input. */
+	__IO uint32_t EMR;				/*!< External Match Register. The EMR controls the external match pins MATn.0-3 (MAT0.0-3 and MAT1.0-3 respectively). */
+	__I  uint32_t RESERVED0[12];
+	__IO uint32_t CTCR;				/*!< Count Control Register. The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting. */
+	__IO uint32_t PWMC;
+} LPC_TIMER_T;
+
+/** Macro to clear interrupt pending */
+#define TIMER_IR_CLR(n)         _BIT(n)
+
+/** Macro for getting a timer match interrupt bit */
+#define TIMER_MATCH_INT(n)      (_BIT((n) & 0x0F))
+/** Macro for getting a capture event interrupt bit */
+#define TIMER_CAP_INT(n)        (_BIT((((n) & 0x0F) + 4)))
+
+/** Timer/counter enable bit */
+#define TIMER_ENABLE            ((uint32_t) (1 << 0))
+/** Timer/counter reset bit */
+#define TIMER_RESET             ((uint32_t) (1 << 1))
+/** Timer Control register Mask */
+#define TIMER_CTRL_MASK         ((uint32_t) 0x03)
+
+/** Bit location for interrupt on MRx match, n = 0 to 3 */
+#define TIMER_INT_ON_MATCH(n)   (_BIT(((n) * 3)))
+/** Bit location for reset on MRx match, n = 0 to 3 */
+#define TIMER_RESET_ON_MATCH(n) (_BIT((((n) * 3) + 1)))
+/** Bit location for stop on MRx match, n = 0 to 3 */
+#define TIMER_STOP_ON_MATCH(n)  (_BIT((((n) * 3) + 2)))
+/** Match Control register Mask */
+#define TIMER_MCR_MASK          ((uint32_t) 0x0FFF)
+
+/** Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
+#define TIMER_CAP_RISING(n)     (_BIT(((n) * 3)))
+/** Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
+#define TIMER_CAP_FALLING(n)    (_BIT((((n) * 3) + 1)))
+/** Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
+#define TIMER_INT_ON_CAP(n)     (_BIT((((n) * 3) + 2)))
+/** Capture Control register Mask */
+#define TIMER_CCR_MASK          ((uint32_t) 0x0FFF)
+/** External Match register Mask */
+#define TIMER_EMR_MASK          ((uint32_t) 0x0FFF)
+/** Counter Control register Mask */
+#define TIMER_CTCR_MASK          ((uint32_t) 0x0F)
+
+/**
+ * @brief	Initialize a timer
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Shutdown a timer
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Determine if a match interrupt is pending
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match interrupt number to check
+ * @return	false if the interrupt is not pending, otherwise true
+ * @note	Determine if the match interrupt for the passed timer and match
+ * counter is pending.
+ */
+__STATIC_INLINE bool Chip_TIMER_MatchPending(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	return (bool) ((pTMR->IR & TIMER_MATCH_INT(matchnum)) != 0);
+}
+
+/**
+ * @brief	Determine if a capture interrupt is pending
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture interrupt number to check
+ * @return	false if the interrupt is not pending, otherwise true
+ * @note	Determine if the capture interrupt for the passed capture pin is
+ * pending.
+ */
+__STATIC_INLINE bool Chip_TIMER_CapturePending(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	return (bool) ((pTMR->IR & TIMER_CAP_INT(capnum)) != 0);
+}
+
+/**
+ * @brief	Clears a (pending) match interrupt
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match interrupt number to clear
+ * @return	Nothing
+ * @note	Clears a pending timer match interrupt.
+ */
+__STATIC_INLINE void Chip_TIMER_ClearMatch(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->IR = TIMER_IR_CLR(matchnum);
+}
+
+/**
+ * @brief	Clears a (pending) capture interrupt
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture interrupt number to clear
+ * @return	Nothing
+ * @note	Clears a pending timer capture interrupt.
+ */
+__STATIC_INLINE void Chip_TIMER_ClearCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->IR = (0x10 << capnum);
+}
+
+/**
+ * @brief	Enables the timer (starts count)
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ * @note	Enables the timer to start counting.
+ */
+__STATIC_INLINE void Chip_TIMER_Enable(LPC_TIMER_T *pTMR)
+{
+	pTMR->TCR = (pTMR->TCR & TIMER_CTRL_MASK) | TIMER_ENABLE;
+}
+
+/**
+ * @brief	Disables the timer (stops count)
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ * @note	Disables the timer to stop counting.
+ */
+__STATIC_INLINE void Chip_TIMER_Disable(LPC_TIMER_T *pTMR)
+{
+	pTMR->TCR = (pTMR->TCR & TIMER_CTRL_MASK) & ~TIMER_ENABLE;
+}
+
+/**
+ * @brief	Returns the current timer count
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Current timer terminal count value
+ * @note	Returns the current timer terminal count.
+ */
+__STATIC_INLINE uint32_t Chip_TIMER_ReadCount(LPC_TIMER_T *pTMR)
+{
+	return pTMR->TC;
+}
+
+/**
+ * @brief	Returns the current prescale count
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Current timer prescale count value
+ * @note	Returns the current prescale count.
+ */
+__STATIC_INLINE uint32_t Chip_TIMER_ReadPrescale(LPC_TIMER_T *pTMR)
+{
+	return pTMR->PC;
+}
+
+/**
+ * @brief	Sets the prescaler value
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	prescale	: Prescale value to set the prescale register to
+ * @return	Nothing
+ * @note	Sets the prescale count value.
+ */
+__STATIC_INLINE void Chip_TIMER_PrescaleSet(LPC_TIMER_T *pTMR, uint32_t prescale)
+{
+	pTMR->PR = prescale;
+}
+
+/**
+ * @brief	Sets a timer match value
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer to set match count for
+ * @param	matchval	: Match value for the selected match count
+ * @return	Nothing
+ * @note	Sets one of the timer match values.
+ */
+__STATIC_INLINE void Chip_TIMER_SetMatch(LPC_TIMER_T *pTMR, int8_t matchnum, uint32_t matchval)
+{
+	pTMR->MR[matchnum] = matchval;
+}
+
+/**
+ * @brief	Reads a capture register
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture register to read
+ * @return	The selected capture register value
+ * @note	Returns the selected capture register value.
+ */
+__STATIC_INLINE uint32_t Chip_TIMER_ReadCapture(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	return pTMR->CR[capnum];
+}
+
+/**
+ * @brief	Resets the timer terminal and prescale counts to 0
+ * @param	pTMR	: Pointer to timer IP register address
+ * @return	Nothing
+ */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR);
+
+/**
+ * @brief	Enables a match interrupt that fires when the terminal count
+ *			matches the match counter value.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_MatchEnableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Disables a match interrupt for a match counter.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_MatchDisableInt(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_INT_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	For the specific match counter, enables reset of the terminal count register when a match occurs
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_ResetOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	For the specific match counter, disables reset of the terminal count register when a match occurs
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_ResetOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_RESET_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Enable a match timer to stop the terminal count when a
+ *			match count equals the terminal count.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_StopOnMatchEnable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) | TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Disable stop on match for a match timer. Disables a match timer
+ *			to stop the terminal count when a match count equals the terminal count.
+ * @param	pTMR		: Pointer to timer IP register address
+ * @param	matchnum	: Match timer, 0 to 3
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_StopOnMatchDisable(LPC_TIMER_T *pTMR, int8_t matchnum)
+{
+	pTMR->MCR = (pTMR->MCR & TIMER_MCR_MASK) & ~TIMER_STOP_ON_MATCH(matchnum);
+}
+
+/**
+ * @brief	Enables capture on on rising edge of selected CAP signal for the
+ *			selected capture register, enables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a rising edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureRisingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief	Disables capture on on rising edge of selected CAP signal. For the
+ *			selected capture register, disables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a rising edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureRisingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_CAP_RISING(capnum);
+}
+
+/**
+ * @brief	Enables capture on on falling edge of selected CAP signal. For the
+ *			selected capture register, enables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a falling edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureFallingEdgeEnable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief	Disables capture on on falling edge of selected CAP signal. For the
+ *			selected capture register, disables the selected CAPn.capnum signal to load
+ *			the capture register with the terminal coount on a falling edge.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureFallingEdgeDisable(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_CAP_FALLING(capnum);
+}
+
+/**
+ * @brief	Enables interrupt on capture of selected CAP signal. For the
+ *			selected capture register, an interrupt will be generated when the enabled
+ *			rising or falling edge on CAPn.capnum is detected.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureEnableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) | TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief	Disables interrupt on capture of selected CAP signal
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capnum	: Capture signal/register to use
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_TIMER_CaptureDisableInt(LPC_TIMER_T *pTMR, int8_t capnum)
+{
+	pTMR->CCR = (pTMR->CCR & TIMER_CCR_MASK) & ~TIMER_INT_ON_CAP(capnum);
+}
+
+/**
+ * @brief Standard timer initial match pin state and change state
+ */
+typedef enum IP_TIMER_PIN_MATCH_STATE {
+	TIMER_EXTMATCH_DO_NOTHING = 0,	/*!< Timer match state does nothing on match pin */
+	TIMER_EXTMATCH_CLEAR      = 1,	/*!< Timer match state sets match pin low */
+	TIMER_EXTMATCH_SET        = 2,	/*!< Timer match state sets match pin high */
+	TIMER_EXTMATCH_TOGGLE     = 3		/*!< Timer match state toggles match pin */
+} TIMER_PIN_MATCH_STATE_T;
+
+/**
+ * @brief	Sets external match control (MATn.matchnum) pin control. For the pin
+ *          selected with matchnum, sets the function of the pin that occurs on
+ *          a terminal count match for the match count.
+ * @param	pTMR			: Pointer to timer IP register address
+ * @param	initial_state	: Initial state of the pin, high(1) or low(0)
+ * @param	matchState		: Selects the match state for the pin
+ * @param	matchnum		: MATn.matchnum signal to use
+ * @return	Nothing
+ * @note	For the pin selected with matchnum, sets the function of the pin that occurs on
+ * a terminal count match for the match count.
+ */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+								   TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum);
+
+/**
+ * @brief Standard timer clock and edge for count source
+ */
+typedef enum IP_TIMER_CAP_SRC_STATE {
+	TIMER_CAPSRC_RISING_PCLK  = 0,	/*!< Timer ticks on PCLK rising edge */
+	TIMER_CAPSRC_RISING_CAPN  = 1,	/*!< Timer ticks on CAPn.x rising edge */
+	TIMER_CAPSRC_FALLING_CAPN = 2,	/*!< Timer ticks on CAPn.x falling edge */
+	TIMER_CAPSRC_BOTH_CAPN    = 3		/*!< Timer ticks on CAPn.x both edges */
+} TIMER_CAP_SRC_STATE_T;
+
+/**
+ * @brief	Sets timer count source and edge with the selected passed from CapSrc.
+ *          If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ * @param	pTMR	: Pointer to timer IP register address
+ * @param	capSrc	: timer clock source and edge
+ * @param	capnum	: CAPn.capnum pin to use (0 - 2)
+ * @return	Nothing
+ * @note	If CapSrc selected a CAPn pin, select the specific CAPn pin with the capnum value.
+ */
+__STATIC_INLINE void Chip_TIMER_TIMER_SetCountClockSrc(LPC_TIMER_T *pTMR,
+													   TIMER_CAP_SRC_STATE_T capSrc,
+													   int8_t capnum)
+{
+	pTMR->CTCR = (pTMR->CTCR & ~TIMER_CTCR_MASK) | ((uint32_t) capSrc | ((uint32_t) capnum) << 2);
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __TIMER_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/uart_5410x.h ./chip/inc/uart_5410x.h
--- a_tnusFF/chip/inc/uart_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/uart_5410x.h	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,539 @@
+/*
+ * @brief LPC5410X UART driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __UART_5410X_H_
+#define __UART_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "ring_buffer.h"
+
+/** @defgroup UART_5410X CHIP: LPC5410X UART Driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/* UART Status Register bits */
+#define UART_RXRDY           (1 << 0)	/* Receive data ready */
+#define UART_RXIDLE          (1 << 1)	/* Receiver Idle */
+#define UART_TXRDY           (1 << 2)	/* Transmitter ready */
+#define UART_TXIDLE          (1 << 3)	/* Transmitter Idle */
+#define UART_RXDERR          (0xF100)	/* overrun err, frame err, parity err, RxNoise err */
+#define UART_TXDERR          (0x0200)	/* underrun err */
+#define UART_START           (0x1000)
+
+/* UART Interrupt register bits */
+#define UART_INT_RXRDY          (1 << 0)
+#define UART_INT_TXRDY          (1 << 2)
+#define UART_INT_TXIDLE         (1 << 3)
+#define UART_INT_CTS            (1 << 5)
+#define UART_INT_TXDIS          (1 << 6)
+#define UART_INT_OVR            (1 << 8)
+#define UART_INT_BREAK          (1 << 11)
+#define UART_INT_START          (1 << 12)
+#define UART_INT_FRMERR         (1 << 13)
+#define UART_INT_PARERR         (1 << 14)
+#define UART_INT_RXNOISE        (1 << 15)
+#define UART_INT_ABAUDERR       (1 << 16)
+
+/* Configuration register bits */
+#define UARTEN      1
+
+#define UART_CTL_TXDIS          (1UL << 6)
+#define UART_CTL_TXBRKEN        (1UL << 1)
+#define UART_CTL_AUTOBAUD       (1UL << 16)
+#define UART_CFG_RES            (2UL | (1UL << 10) | (1UL << 13) | (1UL << 17) | (0xFFUL << 24))
+#define UART_CFG_ENABLE          1
+#define UART_PAR_MASK           (3 << 4)
+#define UART_DATA_MASK          (3 << 2)
+#define UART_CTL_RES            (1UL | (7UL << 3) | (1UL << 7) | (0x3FUL << 10) | (0x7FFFUL << 17))
+#define UART_IDLE_MASK          (1 << 3)
+#define UART_STAT_CTS           (1 << 4)
+#define UART_STAT_BREAK         (1 << 10)
+#define UART_STAT_RXIDLE        (1 << 1)
+
+/*******************
+ * EXPORTED MACROS  *
+ ********************/
+#define     ECHO_EN             1
+#define     ECHO_DIS            0
+
+/*********************
+ * EXPORTED TYPEDEFS  *
+ **********************/
+
+typedef struct {		/* UART registers Structure          */
+	__IO uint32_t CFG;				/*!< Offset: 0x000 Configuration register  */
+	__IO uint32_t CTL;				/*!< Offset: 0x004 Control register */
+	__IO uint32_t STAT;				/*!< Offset: 0x008 Status register */
+	__IO uint32_t INTENSET;			/*!< Offset: 0x00C Interrupt Enable Read and Set register */
+	__O  uint32_t INTENCLR;			/*!< Offset: 0x010 Interrupt Enable Clear register */
+	__I  uint32_t RXDAT;		/*!< Offset: 0x014 Receiver Data register */
+	__I  uint32_t RXDATSTAT;	/*!< Offset: 0x018 Rx Data with status */
+	__O  uint32_t TXDAT;			/*!< Offset: 0x01C Transmitter Data Register */
+	__IO uint32_t BRG;				/*!< Offset: 0x020 Baud Rate Generator register */
+	__I  uint32_t INTSTAT;	/*!< Offset: 0x024 Interrupt Status register */
+	__IO uint32_t OSR;				/*!< Offset: 0x028 Oversampling register */
+	__IO uint32_t ADR;				/*!< Offset: 0x02C Address register (for automatic address matching) */
+} LPC_USART_T;
+
+/**
+ * @brief UART CFG register definitions
+ */
+// #define UART_CFG_ENABLE         (0x01 << 0)
+#define UART_CFG_DATALEN_7      (0x00 << 2)		/*!< UART 7 bit length mode */
+#define UART_CFG_DATALEN_8      (0x01 << 2)		/*!< UART 8 bit length mode */
+#define UART_CFG_DATALEN_9      (0x02 << 2)		/*!< UART 9 bit length mode */
+#define UART_CFG_PARITY_NONE    (0x00 << 4)		/*!< No parity */
+#define UART_CFG_PARITY_EVEN    (0x02 << 4)		/*!< Even parity */
+#define UART_CFG_PARITY_ODD     (0x03 << 4)		/*!< Odd parity */
+#define UART_CFG_STOPLEN_1      (0x00 << 6)		/*!< UART One Stop Bit Select */
+#define UART_CFG_STOPLEN_2      (0x01 << 6)		/*!< UART Two Stop Bits Select */
+#define UART_CFG_MODE32K        (0x01 << 7)		/*!< UART 32K MODE */
+#define UART_CFG_LINMODE        (0x01 << 8)		/*!< UART LIN MODE */
+#define UART_CFG_CTSEN          (0x01 << 9)		/*!< CTS enable bit */
+#define UART_CFG_SYNCEN         (0x01 << 11)	/*!< Synchronous mode enable bit */
+#define UART_CFG_CLKPOL         (0x01 << 12)	/*!< Un_RXD rising edge sample enable bit */
+#define UART_CFG_SYNCMST        (0x01 << 14)	/*!< Select master mode (synchronous mode) enable bit */
+#define UART_CFG_LOOP           (0x01 << 15)	/*!< Loopback mode enable bit */
+
+/**
+ * @brief UART CTRL register definitions
+ */
+#define UART_CTRL_TXBRKEN       (0x01 << 1)		/*!< Continuous break enable bit */
+#define UART_CTRL_ADDRDET       (0x01 << 2)		/*!< Address detect mode enable bit */
+#define UART_CTRL_TXDIS         (0x01 << 6)		/*!< Transmit disable bit */
+#define UART_CTRL_CC            (0x01 << 8)		/*!< Continuous Clock mode enable bit */
+#define UART_CTRL_CLRCC         (0x01 << 9)		/*!< Clear Continuous Clock bit */
+#define UART_CTRL_AUTOBAUD      (0x01 << 16)	/*!< Auto baud bit */
+
+/**
+ * @brief UART STAT register definitions
+ */
+#define UART_STAT_RXRDY         (0x01 << 0)			/*!< Receiver ready */
+// #define UART_STAT_RXIDLE        (0x01 << 1)			/*!< Receiver idle */
+#define UART_STAT_TXRDY         (0x01 << 2)			/*!< Transmitter ready for data */
+#define UART_STAT_TXIDLE        (0x01 << 3)			/*!< Transmitter idle */
+// #define UART_STAT_CTS           (0x01 << 4)			/*!< Status of CTS signal */
+#define UART_STAT_DELTACTS      (0x01 << 5)			/*!< Change in CTS state */
+#define UART_STAT_TXDISINT      (0x01 << 6)			/*!< Transmitter disabled */
+#define UART_STAT_OVERRUNINT    (0x01 << 8)			/*!< Overrun Error interrupt flag. */
+#define UART_STAT_RXBRK         (0x01 << 10)		/*!< Received break */
+#define UART_STAT_DELTARXBRK    (0x01 << 11)		/*!< Change in receive break detection */
+#define UART_STAT_START         (0x01 << 12)		/*!< Start detected */
+#define UART_STAT_FRM_ERRINT    (0x01 << 13)		/*!< Framing Error interrupt flag */
+#define UART_STAT_PAR_ERRINT    (0x01 << 14)		/*!< Parity Error interrupt flag */
+#define UART_STAT_RXNOISEINT    (0x01 << 15)		/*!< Received Noise interrupt flag */
+#define UART_STAT_ABERR         (0x01 << 16)		/*!< Auto baud error flag */
+
+/**
+ * @brief UART INTENSET/INTENCLR register definitions
+ */
+#define UART_INTEN_RXRDY        (0x01 << 0)			/*!< Receive Ready interrupt */
+#define UART_INTEN_TXRDY        (0x01 << 2)			/*!< Transmit Ready interrupt */
+#define UART_INTEN_DELTACTS     (0x01 << 5)			/*!< Change in CTS state interrupt */
+#define UART_INTEN_TXDIS        (0x01 << 6)			/*!< Transmitter disable interrupt */
+#define UART_INTEN_OVERRUN      (0x01 << 8)			/*!< Overrun error interrupt */
+#define UART_INTEN_DELTARXBRK   (0x01 << 11)		/*!< Change in receiver break detection interrupt */
+#define UART_INTEN_START        (0x01 << 12)		/*!< Start detect interrupt */
+#define UART_INTEN_FRAMERR      (0x01 << 13)		/*!< Frame error interrupt */
+#define UART_INTEN_PARITYERR    (0x01 << 14)		/*!< Parity error interrupt */
+#define UART_INTEN_RXNOISE      (0x01 << 15)		/*!< Received noise interrupt */
+
+/**
+ * @brief	UART Baud rate calculation structure
+ * @note
+ * Use oversampling (@a ovr) value other than 16, only if the difference
+ * between the actual baud and desired baud has an unacceptable error percentage.
+ * Smaller @a ovr values can cause the sampling position within the data-bit
+ * less accurate an may potentially cause more noise errors or incorrect data
+ * set ovr to < 10 only when there is no other higher values suitable. Note that
+ * the UART OSR and BRG are -1 encoded i.e., when writing to register BRG @a div must
+ * be (div - 1) and when writing to OSR @a ovr must be (ovr - 1)
+ */
+typedef struct {
+	uint32_t clk;	/*!< IN: Base clock to fractional divider; OUT: "Base clock rate for UART" */
+	uint32_t baud;	/*!< IN: Required baud rate; OUT: Actual baud rate */
+	uint8_t ovr;	/*!< IN: Number of desired over samples [0-auto detect or values 5 to 16]; OUT: Auto detected over samples [unchanged if IN is not 0] */
+	uint8_t mul;	/*!< IN: 0 - calculate MUL, 1 - do't calculate (@a clk) has UART base clock; OUT: MUL value to be set in FRG register */
+	uint16_t div;	/*!< OUT: Integer divider to divide the "Base clock rate for UART" */
+} UART_BAUD_T;
+
+/**
+ * @brief	Calculate baudrate parameters for a UART
+ * @param	pUART		: Pointer to selected UARTx peripheral (Ignored)
+ * @param	pBaud		: Pointer to baud structure #UART_BAUD_T
+ * @return	LPC_OK(0) on success; non-zero on failure
+ * @note	Values returned by pBaud is valid only if the return value is LPC_OK.
+ */
+uint32_t Chip_UART_CalcBaud(LPC_USART_T *pUART, UART_BAUD_T *pBaud);
+
+/**
+ * @brief	Enable the UART
+ * @param	pUART		: Pointer to selected UARTx peripheral
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UART_Enable(LPC_USART_T *pUART)
+{
+	pUART->CFG |= UART_CFG_ENABLE;
+}
+
+/**
+ * @brief	Disable the UART
+ * @param	pUART	: Pointer to selected UARTx peripheral
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UART_Disable(LPC_USART_T *pUART)
+{
+	pUART->CFG &= ~UART_CFG_ENABLE;
+}
+
+/**
+ * @brief	Enable transmission on UART TxD pin
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+__STATIC_INLINE void Chip_UART_TXEnable(LPC_USART_T *pUART)
+{
+	pUART->CTL &= ~UART_CTRL_TXDIS;
+}
+
+/**
+ * @brief	Disable transmission on UART TxD pin
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return Nothing
+ */
+__STATIC_INLINE void Chip_UART_TXDisable(LPC_USART_T *pUART)
+{
+	pUART->CTL |= UART_CTRL_TXDIS;
+}
+
+/**
+ * @brief	Set auto baud
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @return true if auto baud succeeds, false if fails
+ */
+__STATIC_INLINE uint32_t Chip_UART_AutoBaud(LPC_USART_T *pUART)
+{
+	while ( (pUART->STAT & UART_STAT_RXIDLE) != UART_STAT_RXIDLE ) {}
+	pUART->CTL |= UART_CTRL_AUTOBAUD;
+	while ( pUART->CTL & UART_CTRL_AUTOBAUD ) {
+		if ( pUART->STAT & UART_STAT_ABERR ) {
+			pUART->STAT = UART_STAT_ABERR;
+			return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * @brief	Transmit a single data byte through the UART peripheral
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	data	: Byte to transmit
+ * @return	Nothing
+ * @note	This function attempts to place a byte into the UART transmit
+ *			holding register regard regardless of UART state.
+ */
+__STATIC_INLINE void Chip_UART_SendByte(LPC_USART_T *pUART, uint8_t data)
+{
+	pUART->TXDAT = (uint32_t) data;
+}
+
+/**
+ * @brief	Read a single byte data from the UART peripheral
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	A single byte of data read
+ * @note	This function reads a byte from the UART receive FIFO or
+ *			receive hold register regard regardless of UART state. The
+ *			FIFO status should be read first prior to using this function
+ */
+__STATIC_INLINE uint32_t Chip_UART_ReadByte(LPC_USART_T *pUART)
+{
+	/* Strip off undefined reserved bits, keep 9 lower bits */
+	return (uint32_t) (pUART->RXDAT & 0x000001FF);
+}
+
+/**
+ * @brief	Sets the UART baudrate divider values (BRG and OSR)
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	div		: Baud rate clock divider value
+ * @param	ovr		: Over sampling value to be used
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UART_Div(LPC_USART_T *pUART, uint32_t div, uint32_t ovr)
+{
+	if (div) {
+		pUART->BRG = div - 1;
+	}
+	if (ovr) {
+		pUART->OSR = ovr - 1;
+	}
+}
+
+/**
+ * @brief	Enable UART interrupts
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	intMask	: OR'ed Interrupts to enable
+ * @return	Nothing
+ * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
+ *			to enable specific UART interrupts.
+ */
+__STATIC_INLINE void Chip_UART_IntEnable(LPC_USART_T *pUART, uint32_t intMask)
+{
+	pUART->INTENSET = intMask;
+}
+
+/**
+ * @brief	Disable UART interrupts
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	intMask	: OR'ed Interrupts to disable
+ * @return	Nothing
+ * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
+ *			to disable specific UART interrupts.
+ */
+__STATIC_INLINE void Chip_UART_IntDisable(LPC_USART_T *pUART, uint32_t intMask)
+{
+	pUART->INTENCLR = intMask;
+}
+
+/**
+ * @brief	Returns UART interrupts that are enabled
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @return	Returns the enabled UART interrupts
+ * @note	Use an OR'ed value of UART_INTEN_* definitions with this function
+ *			to determine which interrupts are enabled. You can check
+ *			for multiple enabled bits if needed.
+ */
+__STATIC_INLINE uint32_t Chip_UART_GetIntsEnabled(LPC_USART_T *pUART)
+{
+	return pUART->INTENSET;
+}
+
+/**
+ * @brief	Get UART interrupt status
+ * @param	pUART	: The base of UART peripheral on the chip
+ * @return	The Interrupt status register of UART
+ * @note	Multiple interrupts may be pending. Mask the return value
+ *			with one or more UART_INTEN_* definitions to determine
+ *			pending interrupts.
+ */
+__STATIC_INLINE uint32_t Chip_UART_GetIntStatus(LPC_USART_T *pUART)
+{
+	return pUART->INTSTAT;
+}
+
+/**
+ * @brief	Configure data width, parity and stop bits
+ * @param	pUART	: Pointer to selected pUART peripheral
+ * @param	config	: UART configuration, OR'ed values of select UART_CFG_* defines
+ * @return	Nothing
+ * @note	Select OR'ed config options for the UART from the UART_CFG_PARITY_*,
+ *			UART_CFG_STOPLEN_*, and UART_CFG_DATALEN_* definitions. For example,
+ *			a configuration of 8 data bits, 1 stop bit, and even (enabled) parity would be
+ *			(UART_CFG_DATALEN_8 | UART_CFG_STOPLEN_1 | UART_CFG_PARITY_EVEN). Will not
+ *			alter other bits in the CFG register.
+ */
+__STATIC_INLINE void Chip_UART_ConfigData(LPC_USART_T *pUART, uint32_t config)
+{
+	pUART->CFG = config;
+}
+
+/**
+ * @brief	Get the UART status register
+ * @param	pUART	: Pointer to selected UARTx peripheral
+ * @return	UART status register
+ * @note	Multiple statuses may be pending. Mask the return value
+ *			with one or more UART_STAT_* definitions to determine
+ *			statuses.
+ */
+__STATIC_INLINE uint32_t Chip_UART_GetStatus(LPC_USART_T *pUART)
+{
+	return pUART->STAT;
+}
+
+/**
+ * @brief	Clear the UART status register
+ * @param	pUART	: Pointer to selected UARTx peripheral
+ * @param	stsMask	: OR'ed statuses to disable
+ * @return	Nothing
+ * @note	Multiple interrupts may be pending. Mask the return value
+ *			with one or more UART_INTEN_* definitions to determine
+ *			pending interrupts.
+ */
+__STATIC_INLINE void Chip_UART_ClearStatus(LPC_USART_T *pUART, uint32_t stsMask)
+{
+	pUART->STAT = stsMask;
+}
+
+/**
+ * @brief	Initialize the UART peripheral
+ * @param	pUART	: The base of UART peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_UART_Init(LPC_USART_T *pUART);
+
+/**
+ * @brief	Deinitialize the UART peripheral
+ * @param	pUART	: The base of UART peripheral on the chip
+ * @return	Nothing
+ */
+void Chip_UART_DeInit(LPC_USART_T *pUART);
+
+/**
+ * @brief	Transmit a byte array through the UART peripheral (non-blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to bytes to transmit
+ * @param	numBytes	: Number of bytes to transmit
+ * @return	The actual number of bytes placed into the FIFO
+ * @note	This function places data into the transmit FIFO until either
+ *			all the data is in the FIFO or the FIFO is full. This function
+ *			will not block in the FIFO is full. The actual number of bytes
+ *			placed into the FIFO is returned. This function ignores errors.
+ */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief	Read data through the UART peripheral (non-blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to bytes array to fill
+ * @param	numBytes	: Size of the passed data array
+ * @return	The actual number of bytes read
+ * @note	This function reads data from the receive FIFO until either
+ *			all the data has been read or the passed buffer is completely full.
+ *			This function will not block. This function ignores errors.
+ */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief	Set baud rate for UART
+ * @param	pUART	: The base of UART peripheral on the chip
+ * @param	baudrate: Baud rate to be set
+ * @return	Nothing
+ * @note
+ * Setting the baud rate of one UART will affect the baud rate of other
+ * UART's as the Fractional divider is shared between all the UART.
+ */
+void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate);
+
+/**
+ * @brief	Transmit a byte array through the UART peripheral (blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to data to transmit
+ * @param	numBytes	: Number of bytes to transmit
+ * @return	The number of bytes transmitted
+ * @note	This function will send or place all bytes into the transmit
+ *			FIFO. This function will block until the last bytes are in the FIFO.
+ */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes);
+
+/**
+ * @brief	Read data through the UART peripheral (blocking)
+ * @param	pUART		: Pointer to selected UART peripheral
+ * @param	data		: Pointer to data array to fill
+ * @param	numBytes	: Size of the passed data array
+ * @return	The size of the dat array
+ * @note	This function reads data from the receive FIFO until the passed
+ *			buffer is completely full. The function will block until full.
+ *			This function ignores errors.
+ */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes);
+
+/**
+ * @brief	UART receive-only interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @return	Nothing
+ * @note	If ring buffer support is desired for the receive side
+ *			of data transfer, the UART interrupt should call this
+ *			function for a receive based interrupt status.
+ */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief	UART transmit-only interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @return	Nothing
+ * @note	If ring buffer support is desired for the transmit side
+ *			of data transfer, the UART interrupt should call this
+ *			function for a transmit based interrupt status.
+ */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB);
+
+/**
+ * @brief	Populate a transmit ring buffer and start UART transmit
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @param	data	: Pointer to buffer to move to ring buffer
+ * @param	count	: Number of bytes to move
+ * @return	The number of bytes placed into the ring buffer
+ * @note	Will move the data into the TX ring buffer and start the
+ *			transfer. If the number of bytes returned is less than the
+ *			number of bytes to send, the ring buffer is considered full.
+ */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int count);
+
+/**
+ * @brief	Copy data from a receive ring buffer
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRB		: Pointer to ring buffer structure to use
+ * @param	data	: Pointer to buffer to fill from ring buffer
+ * @param	bytes	: Size of the passed buffer in bytes
+ * @return	The number of bytes placed into the ring buffer
+ * @note	Will move the data from the RX ring buffer up to the
+ *			the maximum passed buffer size. Returns 0 if there is
+ *			no data in the ring buffer.
+ */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes);
+
+/**
+ * @brief	UART receive/transmit interrupt handler for ring buffers
+ * @param	pUART	: Pointer to selected UART peripheral
+ * @param	pRXRB	: Pointer to transmit ring buffer
+ * @param	pTXRB	: Pointer to receive ring buffer
+ * @return	Nothing
+ * @note	This provides a basic implementation of the UART IRQ
+ *			handler for support of a ring buffer implementation for
+ *			transmit and receive.
+ */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB);
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UART_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/utick_5410x.h ./chip/inc/utick_5410x.h
--- a_tnusFF/chip/inc/utick_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/utick_5410x.h	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,174 @@
+/*
+ * @brief LPC5410X Micro Tick chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __UTICK_5410X_H_
+#define __UTICK_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup UTICK_5410X CHIP: LPC5410X Micro Tick driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief Micro Tick register block structure
+ */
+typedef struct {
+	__IO uint32_t CTRL;				/*!< UTick Control register */
+	__IO uint32_t STATUS;			/*!< UTick Status register */
+} LPC_UTICK_T;
+
+/**
+ * @brief UTick register definitions
+ */
+/** UTick repeat delay bit */
+#define UTICK_CTRL_REPEAT           ((uint32_t) 1UL << 31)
+/** UTick Delay Value Mask */
+#define UTICK_CTRL_DELAY_MASK       ((uint32_t) 0x7FFFFFFF)
+/** UTick Interrupt Status bit */
+#define UTICK_STATUS_INTR           ((uint32_t) 1 << 0)
+/** UTick Active Status bit */
+#define UTICK_STATUS_ACTIVE         ((uint32_t) 1 << 1)
+/** UTick Status Register Mask */
+#define UTICK_STATUS_MASK           ((uint32_t) 0x03)
+
+/**
+ * @brief	Initialize the UTICK peripheral
+ * @param	pUTICK	: UTICK peripheral selected
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UTICK_Init(LPC_UTICK_T *pUTICK)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_UTICK);
+	Chip_SYSCON_PeriphReset(RESET_UTICK);
+}
+
+/**
+ * @brief	De-initialize the UTICK peripheral
+ * @param	pUTICK	: UTICK peripheral selected
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UTICK_DeInit(LPC_UTICK_T *pUTICK)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_UTICK);
+}
+
+/**
+ * @brief	Setup UTICK
+ * @param	pUTICK		: The base address of UTICK block
+ * @param	tick_value	: Tick value, should not exceed UTICK_CTRL_DELAY_MASK
+ * @param	repeat		: If true then delay repeats continuously else it is one time
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UTICK_SetTick(LPC_UTICK_T *pUTICK, uint32_t tick_value, bool repeat)
+{
+	if (repeat) {
+		tick_value |= UTICK_CTRL_REPEAT;
+	}
+
+	pUTICK->CTRL = tick_value;
+}
+
+/**
+ * @brief	Setup UTICK for the passed delay (in mS)
+ * @param	pUTICK	: The base address of UTICK block
+ * @param	delayMs	: Delay value in mS (Maximum is 1000mS)
+ * @param	repeat	: If true then delay repeats continuously else it is one time
+ * @return	Nothing
+ * @note	The WDT oscillator runs at about 500KHz, so delays in uS won't be
+ * too accurate.
+ */
+__STATIC_INLINE void Chip_UTICK_SetDelayMs(LPC_UTICK_T *pUTICK, uint32_t delayMs, bool repeat)
+{
+	uint32_t tick_value = (delayMs * Chip_Clock_GetWDTOSCRate()) / 1000;
+
+	if (repeat) {
+		tick_value |= UTICK_CTRL_REPEAT;
+	}
+	else {
+		tick_value &= ~UTICK_CTRL_REPEAT;
+	}
+
+	pUTICK->CTRL = tick_value;
+}
+
+/**
+ * @brief	Read UTICK Value
+ * @param	pUTICK	: The base address of UTICK block
+ * @return	Current tick value
+ */
+__STATIC_INLINE uint32_t Chip_UTICK_GetTick(LPC_UTICK_T *pUTICK)
+{
+	return pUTICK->CTRL & UTICK_CTRL_DELAY_MASK;
+}
+
+/**
+ * @brief	Halt UTICK timer
+ * @param	pUTICK	: The base address of UTICK block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UTICK_Halt(LPC_UTICK_T *pUTICK)
+{
+	pUTICK->CTRL = 0;
+}
+
+/**
+ * @brief	Returns the status of UTICK
+ * @param	pUTICK	: The base address of UTICK block
+ * @return Micro tick timer status register value
+ */
+__STATIC_INLINE uint32_t Chip_UTICK_GetStatus(LPC_UTICK_T *pUTICK)
+{
+	return pUTICK->STATUS;
+}
+
+/**
+ * @brief	Clears UTICK Interrupt flag
+ * @param	pUTICK	: The base address of UTICK block
+ * @return	Nothing
+ */
+__STATIC_INLINE void Chip_UTICK_ClearInterrupt(LPC_UTICK_T *pUTICK)
+{
+	pUTICK->STATUS = UTICK_STATUS_INTR;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __UTICK_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/inc/wwdt_5410x.h ./chip/inc/wwdt_5410x.h
--- a_tnusFF/chip/inc/wwdt_5410x.h	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/inc/wwdt_5410x.h	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,253 @@
+/*
+ * @brief LPC5410X WWDT chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#ifndef __WWDT_5410X_H_
+#define __WWDT_5410X_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup LPC_WWDT CHIP: LPC5410X Windowed Watchdog driver
+ * @ingroup CHIP_5410X_DRIVERS
+ * @{
+ */
+
+/**
+ * @brief Windowed Watchdog register block structure
+ */
+typedef struct {				/*!< WWDT Structure         */
+	__IO uint32_t  MOD;			/*!< Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer. */
+	__IO uint32_t  TC;			/*!< Watchdog timer constant register. This register determines the time-out value. */
+	__O  uint32_t  FEED;		/*!< Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC. */
+	__I  uint32_t  TV;			/*!< Watchdog timer value register. This register reads out the current value of the Watchdog timer. */
+	__I  uint32_t  RESERVED0;
+	__IO uint32_t  WARNINT;		/*!< Watchdog warning interrupt register. This register contains the Watchdog warning interrupt compare value. */
+	__IO uint32_t  WINDOW;		/*!< Watchdog timer window register. This register contains the Watchdog window value. */
+} LPC_WWDT_T;
+
+/**
+ * @brief Watchdog Mode register definitions
+ */
+/** Watchdog Mode Bitmask */
+#define WWDT_WDMOD_BITMASK          ((uint32_t) 0x3F)
+/** WWDT enable bit */
+#define WWDT_WDMOD_WDEN             ((uint32_t) (1 << 0))
+/** WWDT reset enable bit */
+#define WWDT_WDMOD_WDRESET          ((uint32_t) (1 << 1))
+/** WWDT time-out flag bit */
+#define WWDT_WDMOD_WDTOF            ((uint32_t) (1 << 2))
+/** WWDT warning interrupt flag bit */
+#define WWDT_WDMOD_WDINT            ((uint32_t) (1 << 3))
+/** WWDT Protect flag bit */
+#define WWDT_WDMOD_WDPROTECT        ((uint32_t) (1 << 4))
+/** WWDT lock bit */
+#define WWDT_WDMOD_LOCK             ((uint32_t) (1 << 5))
+
+/**
+ * @brief	Initialize the Watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT);
+
+/**
+ * @brief	Shutdown the Watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+__STATIC_INLINE void Chip_WWDT_DeInit(LPC_WWDT_T *pWWDT)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_WWDT);
+}
+
+/**
+ * @brief	Set WDT timeout constant value used for feed
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return	none
+ */
+__STATIC_INLINE void Chip_WWDT_SetTimeOut(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->TC = timeout;
+}
+
+/**
+ * @brief	Feed watchdog timer
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ * @note	If this function isn't called, a watchdog timer warning will occur.
+ * After the warning, a timeout will occur if a feed has happened.
+ * Note that if WWDT registers are modified in an interrupt then it is a good
+ * idea to prevent those interrupts when writing the feed sequence.
+ */
+__STATIC_INLINE void Chip_WWDT_Feed(LPC_WWDT_T *pWWDT)
+{
+	pWWDT->FEED = 0xAA;
+	pWWDT->FEED = 0x55;
+}
+
+/**
+ * @brief	Set WWDT warning interrupt
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT warning in ticks, between 0 and 1023
+ * @return	None
+ * @note	This is the number of ticks after the watchdog interrupt that the
+ * warning interrupt will be generated.
+ */
+__STATIC_INLINE void Chip_WWDT_SetWarning(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->WARNINT = timeout;
+}
+
+/**
+ * @brief	Get WWDT warning interrupt
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	WWDT warning interrupt
+ */
+__STATIC_INLINE uint32_t Chip_WWDT_GetWarning(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->WARNINT;
+}
+
+/**
+ * @brief	Set WWDT window time
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	timeout	: WDT timeout in ticks, between WWDT_TICKS_MIN and WWDT_TICKS_MAX
+ * @return	None
+ * @note	The watchdog timer must be fed between the timeout from the Chip_WWDT_SetTimeOut()
+ * function and this function, with this function defining the last tick before the
+ * watchdog window interrupt occurs.
+ */
+__STATIC_INLINE void Chip_WWDT_SetWindow(LPC_WWDT_T *pWWDT, uint32_t timeout)
+{
+	pWWDT->WINDOW = timeout;
+}
+
+/**
+ * @brief	Get WWDT window time
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	WWDT window time
+ */
+__STATIC_INLINE uint32_t Chip_WWDT_GetWindow(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->WINDOW;
+}
+
+/**
+ * @brief	Enable watchdog timer options
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	options	: An or'ed set of options of values
+ *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return	None
+ * @note	You can enable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDPROTECT), but use the WWDT_WDMOD_WDEN after all other options
+ * are set (or unset) with no other options. If WWDT_WDMOD_LOCK is used, it cannot
+ * be unset.
+ */
+__STATIC_INLINE void Chip_WWDT_SetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+	pWWDT->MOD = (pWWDT->MOD & WWDT_WDMOD_BITMASK) | options;
+}
+
+/**
+ * @brief	Disable/clear watchdog timer options
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	options	: An or'ed set of options of values
+ *						WWDT_WDMOD_WDEN, WWDT_WDMOD_WDRESET, and WWDT_WDMOD_WDPROTECT
+ * @return	None
+ * @note	You can disable more than one option at once (ie, WWDT_WDMOD_WDRESET |
+ * WWDT_WDMOD_WDTOF).
+ */
+__STATIC_INLINE void Chip_WWDT_UnsetOption(LPC_WWDT_T *pWWDT, uint32_t options)
+{
+	pWWDT->MOD &= (~options) & WWDT_WDMOD_BITMASK;
+}
+
+/**
+ * @brief	Enable WWDT activity
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	None
+ */
+__STATIC_INLINE void Chip_WWDT_Start(LPC_WWDT_T *pWWDT)
+{
+	Chip_WWDT_SetOption(pWWDT, WWDT_WDMOD_WDEN);
+	Chip_WWDT_Feed(pWWDT);
+}
+
+/**
+ * @brief	Read WWDT status flag
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	Watchdog status, an Or'ed value of WWDT_WDMOD_*
+ */
+__STATIC_INLINE uint32_t Chip_WWDT_GetStatus(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->MOD;
+}
+
+/**
+ * @brief	Clear WWDT interrupt status flags
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @param	status	: Or'ed value of status flag(s) that you want to clear, should be:
+ *              - WWDT_WDMOD_WDTOF: Clear watchdog timeout flag
+ *              - WWDT_WDMOD_WDINT: Clear watchdog warning flag
+ * @return	None
+ */
+__STATIC_INLINE void Chip_WWDT_ClearStatusFlag(LPC_WWDT_T *pWWDT, uint32_t status)
+{
+	if (status & WWDT_WDMOD_WDTOF) {
+		pWWDT->MOD &= (~WWDT_WDMOD_WDTOF) & WWDT_WDMOD_BITMASK;
+	}
+	/* Interrupt flag is cleared by writing a 1 */
+	if (status & WWDT_WDMOD_WDINT) {
+		pWWDT->MOD = (pWWDT->MOD & WWDT_WDMOD_BITMASK) | WWDT_WDMOD_WDINT;
+	}
+}
+
+/**
+ * @brief	Get the current value of WDT
+ * @param	pWWDT	: The base of WatchDog Timer peripheral on the chip
+ * @return	current value of WDT
+ */
+__STATIC_INLINE uint32_t Chip_WWDT_GetCurrentCount(LPC_WWDT_T *pWWDT)
+{
+	return pWWDT->TV;
+}
+
+/**
+ * @}
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __WWDT_5410X_H_ */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/libs/libpower.hex ./chip/libs/libpower.hex
--- a_tnusFF/chip/libs/libpower.hex	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/libs/libpower.hex	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,435 @@
+:10000000213C617263683E0A2F202020202020209E
+:100010002020202020202020313433383338323043
+:100020003732202030202020202030202020202087
+:10003000302020202020202035353820202020206E
+:100040002020600A00000016000002720000027208
+:1000500000000272000002720000027200000272D0
+:1000600000000272000002720000027200000272C0
+:1000700000000272000002720000027200000272B0
+:1000800000000272000002720000027200000272A0
+:100090000000027200000272000002720000027290
+:1000A000436869705F504F5745525F504452656CCA
+:1000B0006F63005F5F7365745F6C7076645F6C651F
+:1000C00076656C00436869705F504F5745525F45D5
+:1000D0006E746572506F7765724D6F6465497261B9
+:1000E0006D4F6E6C7900436869705F504F57455291
+:1000F0005F536574504C4C00436869705F504F57B4
+:1001000045525F536574464C415348506F77657252
+:1001100000436869705F504F5745525F536574568E
+:100120006F6C7461676500436869705F504F574535
+:10013000525F52656C6F6341504900436869705F5C
+:10014000504F5745525F456E746572506F776572B8
+:100150004D6F646500436869705F504F5745525F4B
+:10016000456E746572506F7765724D6F6465526548
+:100170006C6F6300436869705F504F5745525F531F
+:10018000657456444C6576656C00436869705F50D1
+:100190004F5745525F5365744C5056444C657665D5
+:1001A0006C004E4F54555345445F46554E43320004
+:1001B0004E4F54555345445F46554E4333004E4FC2
+:1001C00054555345445F46554E4335004368697066
+:1001D0005F504F5745525F53657441434C476174BC
+:1001E0006500436869705F504F5745525F476574BB
+:1001F00041434C47617465004E4F54555345445F2D
+:1002000046554E433600436869705F504F5745521C
+:100210005F476574524F4D56657273696F6E004348
+:100220006869705F4350555F49734D6173746572BF
+:10023000436F726500436869705F4350555F434D7B
+:1002400030426F6F7400436869705F4350555F437D
+:100250004D34426F6F7400436869705F4350555F5F
+:1002600053656C6563744D6173746572436F726539
+:100270000000706F7765725F6C6962726172792ECF
+:100280006F2F31343338333832303732202030203A
+:1002900020202020302020202020313030363636DB
+:1002A000202036323532202020202020600A7F4551
+:1002B0004C460101010000000000000000000100A8
+:1002C0002800010000000000000000000000200BDA
+:1002D00000000000000534000000000028002C0091
+:1002E000290013B5EFF3108472B61C491D4A0B693F
+:1002F00043F004030B614FF08043D3F810120A431C
+:1003000022EA0002C3F800228020164AC3F8C8007F
+:10031000C3F81422D86430BF11F0200014D04FF07D
+:10032000804380225A65C3F810124FF48051096847
+:100330000191C3F8D020094A136923F00403136123
+:1003400084F3108802B010BDC3F818220090009BFF
+:100350007D2BE4D8009B01330093F8E700BF00ED4C
+:1003600000E0DDD7DFFB2000040000B58BB00AA859
+:10037000372340F8143D01A9034B984702980BB06E
+:100380005DF804FB00BF05020003F0B5194C059FA2
+:10039000246814F4885F04D0012829D008B9032FF9
+:1003A00026D1099C089DE40105F00105E4B244EA68
+:1003B0004516079C04F0010446EAC405069C04F0B7
+:1003C000010445EA440403F0010344EA831302F004
+:1003D000010243EA021201F0010142EA810100F048
+:1003E0000100014307F00307034B41EA07211964A9
+:1003F000F0BD0000034000C002404FF080432022C7
+:1004000010B5C3F8142272B60D490D4A0C6944F0B8
+:1004100004040C61D3F81042224322EA0002C3F81C
+:100420000022084AC3F814228022DA6430BFC3F8DD
+:1004300010420B6923F004030B6162B610BD00ED9E
+:1004400000E0DDD7DFFB2000040070B505460C4658
+:10045000FFF7FEFFB0F5885F0ED128462146FFF773
+:10046000FEFF4FF48000FFF7FEFF4FF08043D3F80C
+:10047000B431DB07F9D508E0054B1B68DB6828467B
+:1004800021461B68BDE870401847002070BD00027F
+:10049000000382B04FF080430F4A0F4988B1C3F880
+:1004A0001822C3F8181200230193019B632B02D872
+:1004B000019B0133F8E74FF080438022C3F8C82046
+:1004C00006E0C3F81412C3F814228022C3F8D02027
+:1004D00002B0704700BF0400003820000402F8B5E5
+:1004E00006460D46FFF7FEFFB0F5885F66D14FF078
+:1004F0008043724AC3F81822724B9D421BD8714C3C
+:100500002368DB68002002461B69052198472368A1
+:10051000DB6801201B690B21002298472368DB68F8
+:1005200002201B690B21002298472368DB68032007
+:100530001B6905213EE0644B9D421BD8624C236839
+:10054000DB68002002461B69092198472368DB68A5
+:1005500001201B690B21002298472368DB680220D9
+:100560001B690B21002298472368DB6803201B6965
+:1005700009211FE0564B9D4201D9554E9CE0514C3C
+:100580002368DB68002002461B690B21984723681B
+:10059000DB6801201B690B21002298472368DB6878
+:1005A00002201B690B21002298472368DB681B6926
+:1005B00003200B210022984700267DE0002E7AD1EF
+:1005C000FFF7FEFF41F2021398420BD14FF0804338
+:1005D0004149D3F8FC03404A414B984214BF1346AB
+:1005E0000B4600E03D4B4FF47A72B5FBF2F29A42B3
+:1005F000C3D84FF08043314AC3F81822D3F824718E
+:10060000384B9D4227F470471CD9364B9D421BD96D
+:1006100003F5370303F5D8539D4217D9334B9D4259
+:1006200016D9324B9D4215D903F5370303F5D8533C
+:100630009D4211D92F4B2F4A304CA5428CBF1446F6
+:100640001C460AE02E4C08E02E4C06E02E4C04E03E
+:100650002E4C02E02E4C00E02E4C1A4D2B68DB682D
+:10066000002004F00F0102461B6998472B68DB68E5
+:1006700001201B690B21002298472B68DB68C4F31B
+:1006800003311B690220002298472B68DB68C4F302
+:1006900083411B69032000229847240E4FF08043BA
+:1006A00006D047F0200747EA0434C3F8244103E0AA
+:1006B000C3F8247180E7174E3046F8BD00BF040030
+:1006C0000038FF2C310100020003FFB3C40400E135
+:1006D000F50502000B00A086010000770100CEFEA8
+:1006E000C108001BB70000366E01006CDC020087F9
+:1006F0009303CCC23004CDD2340500BD0105C7B28E
+:100700001C00C8B22001C9B22402CAB22802CBB26E
+:100710002C03CCC2300304000C000A46024921F02D
+:100720000101FFF7FEBF0000000070B505460C4652
+:10073000FFF7FEFFB0F5885F43D1032D4AD8DFE80D
+:1007400005F002081A33234A136923F004031361E6
+:1007500035E072B6204B20491A6942F004021A6152
+:100760004FF08042D2F81002014321EA0401C2F89E
+:10077000001230BF12E072B6174B18491A6942F0E6
+:1007800004021A614FF08042D2F81002014321EABC
+:100790000401C2F8001230BFC2F810021A6922F038
+:1007A00004021A6162B670BD72B60A4A136943F058
+:1007B000040313614FF08043E443C3F8104230BF99
+:1007C00070BD074B1B68DB68284621469B68BDE867
+:1007D0007040184770BD00ED00E05D07CA78DDD7B6
+:1007E000DFFB00020003022803D142F001020846A9
+:1007F0001047FFF7FEBF08B538B9084B1B6813F464
+:10080000885F02D0CB1E022B06D8054B1B68DB6825
+:100810001B699847002008BD034808BD00BF0000C1
+:1008200003400002000306000C0010B586B0FFF77D
+:10083000FEFF41F20113984209D80C4B1B6813F4D8
+:10084000885F12D10B4B4FF4AA721A640DE0094B6A
+:100850001B680020DB680190012100910290039049
+:1008600004905C690A460B46A04706B010BD000024
+:10087000034000C00240000200030148FFF7FEBF32
+:1008800000BF040000384FF08043014AC3F814222F
+:1008900070470400003837B504463D200D46FFF789
+:1008A000FEFF2CB91C4B03221A6020225A602CE058
+:1008B000012C0BD11D2D25D8184B1B6803F00F03FD
+:1008C000052B22D84FF48032134B18E0022C1BD199
+:1008D0001D2D1AD8114B1B6803F00F03033B022B8D
+:1008E00012D80C4B0E4A1A6000220192019A1E2A5D
+:1008F00002D8019A0132F8E71A6842F4C0221A605D
+:10090000002402E0022400E001243D20FFF7FEFF66
+:10091000204603B030BD0000034000C00240040088
+:10092000010010B50446FFF7FEFF41F201139842A3
+:10093000054B1B68DB68204694BF9B6A1B6BBDE8B8
+:100940001040184700BF0002000310B5FFF7FEFF7C
+:1009500041F201139842044B1B68DB68BDE810406C
+:1009600094BFDB6A5B6B184700BF0002000310B541
+:10097000FFF7FEFF41F20113984206D9044B1B68B2
+:10098000DB68BDE810409B6B1847012010BD0002DA
+:100990000003FFF7FEBF084B1B6840F62442C3F379
+:1009A0000B1393424FF08043D3F8000300F0010093
+:1009B00018BF80F00100704700BF00ED00E04FF06D
+:1009C0008043074AC3F80813C3F80403D3F80003AD
+:1009D000054902430143C3F80013C3F800237047DD
+:1009E00000BF0800C4C02800C4C04FF08043074ABD
+:1009F000C3F80813C3F80403D3F8000305490243FE
+:100A00000143C3F80013C3F80023704700BF04007C
+:100A1000C4C01400C4C04FF08043D3F8002322F0B8
+:100A2000410220B942F0404343F4440301E0044B47
+:100A3000134309B143F040034FF08042C2F8003342
+:100A400070470100C4C0004743433A2028474E5531
+:100A500020546F6F6C7320666F722041524D204599
+:100A60006D6265646465642050726F636573736F53
+:100A700072732920342E392E3320323031353035FF
+:100A80003239202872656C6561736529205B41529B
+:100A90004D2F656D6265646465642D345F392D6228
+:100AA00072616E6368207265766973696F6E203259
+:100AB00032343238385D00413600000061656162D1
+:100AC0006900012C00000005436F727465782D4D9C
+:100AD0003400060D074D09020A061204140115011F
+:100AE0001703180119011A011B011E042201002E0F
+:100AF00073796D746162002E737472746162002E7A
+:100B00007368737472746162002E74657874002E59
+:100B100064617461002E627373002E746578742EA4
+:100B2000436869705F504F5745525F504452656C3F
+:100B30006F63002E746578742E67657442524F4D52
+:100B400056657273696F6E002E746578742E5F5FE0
+:100B50007365745F6C7076645F6C6576656C002E8F
+:100B6000746578742E436869705F504F5745525FC3
+:100B7000456E746572506F7765724D6F646549722A
+:100B8000616D4F6E6C79002E72656C2E7465787491
+:100B90002E436869705F504F5745525F53657450DC
+:100BA0004C4C002E746578742E436869705F504F0A
+:100BB0005745525F536574464C415348506F7765B3
+:100BC00072002E72656C2E746578742E436869709D
+:100BD0005F504F5745525F536574566F6C74616731
+:100BE00065002E72656C2E746578742E436869708A
+:100BF0005F504F5745525F52656C6F6341504900DB
+:100C00002E72656C2E746578742E436869705F501F
+:100C10004F5745525F456E746572506F7765724DE0
+:100C20006F6465002E72656C2E746578742E43684F
+:100C300069705F504F5745525F456E746572506FD3
+:100C40007765724D6F646552656C6F63002E7465D5
+:100C500078742E436869705F504F5745525F5365F3
+:100C60007456444C6576656C002E72656C2E746506
+:100C700078742E436869705F504F5745525F5365D3
+:100C8000744C5056444C6576656C002E72656C2E23
+:100C9000746578742E4E4F54555345445F46554EF7
+:100CA0004332002E746578742E4E4F54555345448C
+:100CB0005F46554E4333002E72656C2E7465787412
+:100CC0002E4E4F54555345445F46554E4335002EE6
+:100CD00072656C2E746578742E436869705F504F2E
+:100CE0005745525F53657441434C47617465002E0C
+:100CF00072656C2E746578742E436869705F504F0E
+:100D00005745525F47657441434C47617465002EF7
+:100D100072656C2E746578742E4E4F54555345444D
+:100D20005F46554E4336002E72656C2E746578749E
+:100D30002E436869705F504F5745525F4765745244
+:100D40004F4D56657273696F6E002E746578742E00
+:100D5000436869705F4350555F49734D61737465B3
+:100D600072436F7265002E746578742E43686970E3
+:100D70005F4350555F434D30426F6F74002E746572
+:100D800078742E436869705F4350555F434D344219
+:100D90006F6F74002E746578742E436869705F43BA
+:100DA00050555F53656C6563744D61737465724330
+:100DB0006F7265002E636F6D6D656E74002E41520B
+:100DC0004D2E617474726962757465730000000061
+:100DD0000000000000000000000000000000000013
+:100DE0000000000000000000000000000000000003
+:100DF0000000000000001B000000010000000600D1
+:100E000000000000000034000000000000000000AE
+:100E100000000000000002000000000000002100AF
+:100E2000000001000000030000000000000034008A
+:100E300000000000000000000000000000000100B1
+:100E40000000000000002700000008000000030070
+:100E5000000000000000340000000000000000005E
+:100E600000000000000001000000000000002C0055
+:100E70000000010000000600000000000000340037
+:100E800000008800000000000000000000000400D6
+:100E90000000000000004500000001000000060006
+:100EA000000000000000BC00000020000000000066
+:100EB00000000000000004000000000000005A00D4
+:100EC0000000010000000600000000000000DC003F
+:100ED000000070000000000000000000000004009E
+:100EE000000000000000710000000100000006008A
+:100EF0000000000000004C01000050000000000055
+:100F000000000000000004000000000000009D0040
+:100F100000000100000006000000000000009C012D
+:100F20000000480000000000000000000000040075
+:100F3000000000000000990000000900000000000F
+:100F4000000000000000E4170000180000002A0064
+:100F50000000080000000400000008000000B500C8
+:100F60000000010000000600000000000000E40195
+:100F700000004C0000000000000000000000040021
+:100F8000000000000000D800000001000000060082
+:100F9000000000000000300200003C0200000000E1
+:100FA0000000000000000400000000000000D40069
+:100FB0000000090000000000000000000000FC1715
+:100FC0000000100000002A0000000B0000000400D8
+:100FD000000008000000F80000000100000006000A
+:100FE0000000000000006C04000010000000000081
+:100FF0000000000000000400000000000000F400F9
+:1010000000000900000000000000000000000C18B3
+:101010000000100000002A0000000D000000040085
+:10102000000008000000160100000100000006009A
+:101030000000000000007C040000BC000000000074
+:101040000000000000000400000000000000120189
+:1010500000000900000000000000000000001C1853
+:101060000000080000002A0000000F00000004003B
+:101070000000080000003A01000001000000060026
+:101080000000000000003805000010000000000013
+:101090000000000000000200000000000000360117
+:1010A00000000900000000000000000000002418FB
+:1010B0000000080000002A000000110000000400E9
+:1010C0000000080000005F010000010000000600B1
+:1010D000000000000000480500003400000000008F
+:1010E00000000000000004000000000000007F017C
+:1010F00000000100000006000000000000007C0568
+:10110000000050000000000000000000000004008B
+:101110000000000000007B0100000900000000004A
+:101120000000000000002C180000080000002A0049
+:101130000000140000000400000008000000A101ED
+:101140000000010000000600000000000000CC05C7
+:1011500000000C000000000000000000000004007F
+:101160000000000000009D010000090000000000D8
+:1011700000000000000034180000080000002A00F1
+:101180000000160000000400000008000000B50187
+:101190000000010000000600000000000000D8056B
+:1011A000000010000000000000000000000004002B
+:1011B000000000000000CD0100000100000006005A
+:1011C000000000000000E80500008C0000000000A6
+:1011D0000000000000000400000000000000C90141
+:1011E00000000900000000000000000000003C18A2
+:1011F0000000100000002A00000019000000040098
+:10120000000008000000E5010000010000000600E9
+:10121000000000000000740600002800000000002C
+:101220000000000000000400000000000000E101D8
+:1012300000000900000000000000000000004C1841
+:101240000000080000002A0000001B00000004004D
+:101250000000080000000502000001000000060078
+:101260000000000000009C060000240000000000B8
+:101270000000000000000400000000000000010267
+:1012800000000900000000000000000000005418E9
+:101290000000080000002A0000001D0000000400FB
+:1012A0000000080000002502000001000000060008
+:1012B000000000000000C006000024000000000044
+:1012C00000000000000004000000000000002102F7
+:1012D00000000900000000000000000000005C1891
+:1012E0000000080000002A0000001F0000000400A9
+:1012F0000000080000003D020000010000000600A0
+:10130000000000000000E4060000040000000000EF
+:101310000000000000000200000000000000390290
+:101320000000090000000000000000000000641838
+:101330000000080000002A00000021000000040056
+:101340000000080000005C02000001000000060030
+:10135000000000000000E806000028000000000077
+:1013600000000000000004000000000000007802FF
+:10137000000001000000060000000000000010074F
+:1013800000002C000000000000000000000004002D
+:101390000000000000008F020000010000000600B5
+:1013A0000000000000003C0700002C0000000000CE
+:1013B0000000000000000400000000000000A60281
+:1013C00000000100000006000000000000006807A7
+:1013D00000003000000000000000000000000400D9
+:1013E000000000000000C602000001000000300004
+:1013F00000000000000098070000710000000000DD
+:101400000000000000000100000001000000CF0209
+:101410000000030000700000000000000000090848
+:101420000000370000000000000000000000010084
+:101430000000000000001100000003000000000098
+:1014400000000000000040080000DF020000000073
+:10145000000000000000010000000000000001008A
+:101460000000020000000000000000000000001268
+:101470000000900300002B0000001E00000004008C
+:101480000000100000000900000003000000000040
+:101490000000000000009015000051020000000054
+:1014A000000000000000010000000000000000003B
+:1014B000000000000000000000000000000001002B
+:1014C00000000100000020000000020005000000F4
+:1014D0000000000000000000000003000100000008
+:1014E00000000000000000000000030002000000F7
+:1014F00000000000000000000000030003000000E6
+:1015000000000000000000000000030004000000D4
+:1015100000000000000000000000030005000000C3
+:1015200000000000000000000000030006000000B2
+:1015300000000000000000000000030007000000A1
+:101540000000000000000000000003000800000090
+:101550000000000000000000000003000A0000007E
+:101560000000000000000000000003000B0000006D
+:101570000000000000000000000003000D0000005B
+:101580000000000000000000000003000F00000049
+:101590000000000000000000000003001100000037
+:1015A0000000000000000000000003001300000025
+:1015B0000000000000000000000003001400000014
+:1015C0000000000000000000000003001600000002
+:1015D00000000000000000000000030018000000F0
+:1015E00000000000000000000000030019000000DF
+:1015F0000000000000000000000003001B000000CD
+:101600000000000000000000000003001D000000BA
+:101610000000000000000000000003001F000000A8
+:101620000000000000000000000003002100000096
+:101630000000000000000000000003002300000084
+:101640000000000000000000000003002400000073
+:101650000000000000000000000003002500000062
+:101660000000000000000000000003002600000051
+:101670000000000000000000000003002700000040
+:10168000000000000000000000000300280010001F
+:101690000000010000008800000012000400230088
+:1016A000000001000000700000001200060034007D
+:1016B000000001000000500000001200070056006A
+:1016C000000001000000480000001200080068004F
+:1016D0000000000000000000000010000000820078
+:1016E0000000000000000000000010000000960054
+:1016F0000000010000004C00000012000A00AF00D2
+:101700000000010000003C02000012000B00C500B8
+:101710000000010000001000000012000D00D900C0
+:101720000000000000000000000010000000E000C9
+:10173000000001000000BC00000012000F00FA00D1
+:10174000000001000000100000001200110019014B
+:1017500000000100000034000000120013002F01FF
+:1017600000000100000050000000120014004701BA
+:101770000000010000000C000000120016005501DE
+:1017800000000100000010000000120018006301BA
+:101790000000010000008C0000001200190071011F
+:1017A00000000000000000000000100000008E019A
+:1017B0000000000000000000000010000000AC016C
+:1017C0000000010000002800000012001B00C20100
+:1017D0000000010000002400000012001D00D801DC
+:1017E0000000010000002400000012001F00E601BC
+:1017F0000000010000000400000012002100FF01B1
+:101800000000010000002800000012002300150263
+:101810000000010000002C0000001200240026023D
+:101820000000010000002C0000001200250037021B
+:1018300000000100000030000000120026000067D8
+:10184000657442524F4D56657273696F6E004368FE
+:1018500069705F504F5745525F504452656C6F63DB
+:10186000005F5F7365745F6C7076645F6C6576654E
+:101870006C00436869705F504F5745525F456E7406
+:101880006572506F7765724D6F64654972616D4F17
+:101890006E6C7900436869705F504F5745525F53D3
+:1018A0006574504C4C00436869705F436C6F636BA8
+:1018B0005F536574757053797374656D504C4C004B
+:1018C000436869705F535953434F4E5F506F77655C
+:1018D00072557000436869705F504F5745525F53AF
+:1018E0006574464C415348506F7765720043686990
+:1018F000705F504F5745525F536574566F6C7461FB
+:10190000676500436869705F504F5745525F526585
+:101910006C6F63415049006D656D63707900436879
+:1019200069705F504F5745525F456E746572506FD6
+:101930007765724D6F646500436869705F504F57FB
+:1019400045525F456E746572506F7765724D6F6476
+:101950006552656C6F6300436869705F504F57450F
+:10196000525F53657456444C6576656C00436869F4
+:10197000705F504F5745525F5365744C5056444CFE
+:101980006576656C004E4F54555345445F46554E41
+:101990004332004E4F54555345445F46554E4333F2
+:1019A000004E4F54555345445F46554E4335004312
+:1019B0006869705F436C6F636B5F456E61626C65F5
+:1019C000506572697068436C6F636B00436869703F
+:1019D0005F436C6F636B5F44697361626C655065F4
+:1019E00072697068436C6F636B00436869705F5025
+:1019F0004F5745525F53657441434C4761746500CE
+:101A0000436869705F504F5745525F476574414363
+:101A10004C47617465004E4F54555345445F4655DD
+:101A20004E433600436869705F504F5745525F47D9
+:101A30006574524F4D56657273696F6E00436869E5
+:101A4000705F4350555F49734D6173746572436FA6
+:101A5000726500436869705F4350555F434D304283
+:101A60006F6F7400436869705F4350555F434D3436
+:101A7000426F6F7400436869705F4350555F5365F0
+:101A80006C6563744D6173746572436F72650000B9
+:101A90000000060000000A010000140000000A22F5
+:101AA00000001C0000000A230000060000000A01DC
+:101AB0000000E20000000A0100000C000000021E0D
+:101AC0000000080000001E270000060000000A01B8
+:101AD00000000C0000001E280000040000000A01A5
+:101AE0000000020000001E230000080000000A2F72
+:101AF0000000760000000A300000040000000A0127
+:101B00000000020000000A010000020000000A01BB
+:0A1B10000000000000001E010000AC
+:00000001FF
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/libs/libpower_m0.hex ./chip/libs/libpower_m0.hex
--- a_tnusFF/chip/libs/libpower_m0.hex	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/libs/libpower_m0.hex	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,443 @@
+:10000000213C617263683E0A2F202020202020209E
+:100010002020202020202020313433383338323043
+:100020003737202030202020202030202020202082
+:10003000302020202020202035353820202020206E
+:100040002020600A00000016000002720000027208
+:1000500000000272000002720000027200000272D0
+:1000600000000272000002720000027200000272C0
+:1000700000000272000002720000027200000272B0
+:1000800000000272000002720000027200000272A0
+:100090000000027200000272000002720000027290
+:1000A000436869705F504F5745525F504452656CCA
+:1000B0006F63005F5F7365745F6C7076645F6C651F
+:1000C00076656C00436869705F504F5745525F45D5
+:1000D0006E746572506F7765724D6F6465497261B9
+:1000E0006D4F6E6C7900436869705F504F57455291
+:1000F0005F536574504C4C00436869705F504F57B4
+:1001000045525F536574464C415348506F77657252
+:1001100000436869705F504F5745525F536574568E
+:100120006F6C7461676500436869705F504F574535
+:10013000525F52656C6F6341504900436869705F5C
+:10014000504F5745525F456E746572506F776572B8
+:100150004D6F646500436869705F504F5745525F4B
+:10016000456E746572506F7765724D6F6465526548
+:100170006C6F6300436869705F504F5745525F531F
+:10018000657456444C6576656C00436869705F50D1
+:100190004F5745525F5365744C5056444C657665D5
+:1001A0006C004E4F54555345445F46554E43320004
+:1001B0004E4F54555345445F46554E4333004E4FC2
+:1001C00054555345445F46554E4335004368697066
+:1001D0005F504F5745525F53657441434C476174BC
+:1001E0006500436869705F504F5745525F476574BB
+:1001F00041434C47617465004E4F54555345445F2D
+:1002000046554E433600436869705F504F5745521C
+:100210005F476574524F4D56657273696F6E004348
+:100220006869705F4350555F49734D6173746572BF
+:10023000436F726500436869705F4350555F434D7B
+:1002400030426F6F7400436869705F4350555F437D
+:100250004D34426F6F7400436869705F4350555F5F
+:1002600053656C6563744D6173746572436F726539
+:100270000000706F7765725F6C6962726172792ECF
+:100280006F2F313433383338323037372020302035
+:1002900020202020302020202020313030363636DB
+:1002A000202036333834202020202020600A7F454B
+:1002B0004C460101010000000000000000000100A8
+:1002C0002800010000000000000000000000500BAA
+:1002D00000000000000534000000000028002C0091
+:1002E000290073B5EFF3108472B604221C4D1C4E26
+:1002F0002B6913432B61842280239200DB059958DC
+:10030000194A0A438243802080001A5080221648EE
+:100310000260852080001E50DA6430BF603A0A40D7
+:10032000281C002A11D084258022AD005A6559511D
+:1003300080235B011B6801930D4B1A6003697C3AB3
+:100340009343036184F3108873BD8625AD005E512D
+:100350000092009A7D2AE6D8009A0132F8E700ED73
+:1003600000E020000400DDD7DFFBC8000040D00023
+:100370000040372300B58BB0059305A801A9024BB7
+:10038000984702980BB000BDC04605020003F0B5C7
+:10039000184C266888246401264206D0012827D0FC
+:1003A000002802D1059C032C22D10124FF27089E9E
+:1003B000234026407501099E2240F6013E40079FDA
+:1003C0002E432740FF003E43069F21402740A74081
+:1003D000044003203E439B01334312011A43059B13
+:1003E0008900184011430C430002024B04431C6473
+:1003F000F0BD0000034000C00240F0B58023852717
+:100400002022DB05BF00DA5172B6042484250B4993
+:10041000AD000A6922430A615E59094A32438243A8
+:10042000802080001A50074ADA518022DA6430BFF7
+:100430005E510B69A3430B6162B6F0BDC04600ED8F
+:1004400000E0DDD7DFFB2000040038B5051C0C1CE4
+:10045000FFF7FEFF88235B0198420FD1281C211C67
+:10046000FFF7FEFF8020C003FFF7FEFFDA238022A4
+:100470005B00D205D358DB07F8D507E0054B281CF5
+:100480001B68211CDB681B68984700E0002038BD12
+:10049000C04600020003802313B5DB050E490E4C55
+:1004A00000280ED08622920099509C500023019380
+:1004B000019B632B02D8019B0133F8E78022074B95
+:1004C00006E0852292009C509950953A054BFF3AE0
+:1004D0001A6013BDC0460400003820000402C800A2
+:1004E0000040D0000040F7B5051C0F1CFFF7FEFFD1
+:1004F00088235B01984267D1862380226F499B0045
+:10050000D205D1506E4B9F421BD800206D4C021C6F
+:1005100023680521DB681B69984723680120DB6895
+:100520000B211B690022984723680220DB680B21FE
+:100530001B690022984723680320DB6805211B699B
+:100540003EE0604B9F421BD800205D4C021C23689C
+:100550000921DB681B69984723680120DB680B21B0
+:100560001B690022984723680220DB680B211B6966
+:100570000022984723680320DB6809211B691FE0DC
+:10058000524B9F4201D9514D95E000204D4C021C29
+:1005900023680B21DB681B69984723680120DB680F
+:1005A0000B211B690022984723680220DB680B217E
+:1005B0001B690022984703200B212368DB681B6915
+:1005C00000229847002576E0002D73D1FFF7FEFF4B
+:1005D000404B984209D1FF2380229B00D205D2587C
+:1005E0003D4B9A4201D13C4C00E03C4CFA21381C76
+:1005F0008900FFF7FEFFA042C5D8862380222E493E
+:100600009B00D205374ED150B46A364B1C40364B56
+:1006100001949F4213D9354B9F4212D9354B9F42CB
+:1006200011D9344B9F4210D9344B9F420FD9334BD1
+:100630009F420ED9334B9F420DD8324C0CE0324CC6
+:100640000AE0324C08E0324C06E0324C04E0324C16
+:1006500002E0324C00E0324C00200F21194F2140C3
+:100660003B68021CDB681B6998473B680120DB681C
+:100670000B211B69002298470F223B68210BDB6886
+:1006800011401B690220002298470F223B68A10CF1
+:10069000DB6811401B69032000229847240E06D016
+:1006A0002023019A240313431C43B46203E0019BFB
+:1006B000B36287E71C4D281CFEBD04000038FF2CE8
+:1006C000310100020003FFB3C40400E1F50502009C
+:1006D0000B0002110000CEFEC108A08601000077C9
+:1006E0000100FC000040FF0FFFFF001BB7000036B9
+:1006F0006E0100512502006CDC020087930300A20A
+:100700004A0400BD0105CCC23004C7B21C00C8B207
+:100710002001C9B22402CAB22802CBB22C03CCC237
+:100720003003CDD2340504000C0008B501230A1CA7
+:1007300002499943FFF7FEFF08BD0000000070B5B5
+:10074000051C0C1CFFF7FEFF88235B0198423FD17C
+:10075000032D44D8281C224B0422FFF7FEFF02067B
+:10076000172D19699143196130E072B6196980201B
+:10077000114319618421C005890041581A4D29434C
+:10078000A1438024A400015130BF10E072B6802044
+:1007900084251969C00511431961AD0046591249F4
+:1007A0003143A1438024A400015130BF465119694F
+:1007B0009143196162B612E072B61969E4430A43C3
+:1007C0001A61842380229B00D205D45030BF06E0FA
+:1007D000074B281C1B68211CDB689B68984770BD71
+:1007E000C04600ED00E05D07CA78DDD7DFFB000200
+:1007F000000308B5022804D10123081C1A439047BE
+:1008000001E0FFF7FEFF08BD000010B5002808D189
+:10081000094B1C6888235B011C4202D0CB1E022BB3
+:1008200006D8054B1B68DB681B699847002000E071
+:10083000034810BDC046000003400002000306004C
+:100840000C0010B586B0FFF7FEFF0E4B98420AD899
+:100850000E4B1A6888235B011A4212D1AA220B4B55
+:1008600052001A640DE00A4B00201B68DA6801236D
+:10087000019000930290039004905469191C1A1C73
+:10088000A04706B010BD011100000000034000C0E9
+:1008900002400002000308B50248FFF7FEFF08BD52
+:1008A000C046040000388523802202499B00D205FF
+:1008B000D1507047C0460400003873B5051C3D2078
+:1008C0000E1CFFF7FEFF002D05D103221C4B1A6002
+:1008D0001D325A602DE0012D0DD102241D2E29D884
+:1008E000184B2C1C1A680F231340052B22D880228A
+:1008F000134B52021CE00124022D1BD12C1C1D2E77
+:1009000018D80F4B013C1A680F231340033B022BEE
+:1009100010D80C4A0A4B1A6000220192019A1E2A32
+:1009200002D8019A0132F8E7C0211A68C9020A43C5
+:100930001A6000243D20FFF7FEFF201C76BD00005A
+:10094000034000C002400400010010B5041CFFF782
+:10095000FEFF054B064A1B68DB68904201D89B6A84
+:1009600000E01B6B201C984710BD00020003011122
+:10097000000008B5FFF7FEFF054B054A1B68DB6862
+:10098000904201D8DB6A00E05B6B984708BD00022B
+:1009900000030111000008B5FFF7FEFF054B021C24
+:1009A00001209A4204D9034B1B68DB689B6B984774
+:1009B00008BD011100000002000308B5FFF7FEFFAB
+:1009C00008BD8021C022084B10B51B68084C1B04D1
+:1009D0001B0DC90592000120A34202D08B589843F9
+:1009E00001E08B58184010BDC04600ED00E0240C1B
+:1009F00000008023C222DB05920010B59950C0216F
+:100A0000043A985089005A58034C03481043224333
+:100A10005A50585010BD2800C4C00800C4C08023DC
+:100A2000C222DB05920010B59950C021043A9850BB
+:100A300089005A58034C0348104322435A505850D7
+:100A400010BD1400C4C00400C4C030B5C02280244E
+:100A50004125E4059200A358AB43002801D1044886
+:100A600000E004480343002901D040210B43A35078
+:100A700030BD0000C4C00100C4C0004743433A2059
+:100A800028474E5520546F6F6C7320666F7220415B
+:100A9000524D20456D6265646465642050726F63D9
+:100AA0006573736F72732920342E392E33203230E0
+:100AB000313530353239202872656C6561736529AE
+:100AC000205B41524D2F656D6265646465642D3411
+:100AD0005F392D6272616E63682072657669736931
+:100AE0006F6E203232343238385D00413000000001
+:100AF000616561626900012600000005436F727440
+:100B000065782D4D3000060C074D090112041401C3
+:100B100015011703180119011A011E04002E73791B
+:100B20006D746162002E737472746162002E73685A
+:100B3000737472746162002E74657874002E64613F
+:100B40007461002E627373002E746578742E43688E
+:100B500069705F504F5745525F504452656C6F63E8
+:100B6000002E746578742E67657442524F4D566539
+:100B70007273696F6E002E746578742E5F5F736593
+:100B8000745F6C7076645F6C6576656C002E74655E
+:100B900078742E436869705F504F5745525F456EB9
+:100BA000746572506F7765724D6F64654972616DDF
+:100BB0004F6E6C79002E72656C2E746578742E43BE
+:100BC0006869705F504F5745525F536574504C4C85
+:100BD000002E746578742E436869705F504F5745D6
+:100BE000525F536574464C415348506F77657200AD
+:100BF0002E72656C2E746578742E436869705F5030
+:100C00004F5745525F536574566F6C74616765004A
+:100C10002E72656C2E746578742E436869705F500F
+:100C20004F5745525F52656C6F63415049002E72B9
+:100C3000656C2E746578742E436869705F504F57E9
+:100C400045525F456E746572506F7765724D6F6483
+:100C500065002E72656C2E746578742E4368697019
+:100C60005F504F5745525F456E746572506F7765A0
+:100C7000724D6F646552656C6F63002E7465787495
+:100C80002E436869705F504F5745525F53657456E5
+:100C9000444C6576656C002E72656C2E74657874B4
+:100CA0002E436869705F504F5745525F5365744CCF
+:100CB0005056444C6576656C002E72656C2E7465DA
+:100CC00078742E4E4F54555345445F46554E43322B
+:100CD000002E746578742E4E4F54555345445F462C
+:100CE000554E4333002E72656C2E746578742E4E0B
+:100CF0004F54555345445F46554E4335002E72655B
+:100D00006C2E746578742E436869705F504F574538
+:100D1000525F53657441434C47617465002E7265A0
+:100D20006C2E746578742E436869705F504F574518
+:100D3000525F47657441434C47617465002E72658C
+:100D40006C2E746578742E4E4F54555345445F464F
+:100D5000554E4336002E72656C2E746578742E43A2
+:100D60006869705F504F5745525F476574524F4DE9
+:100D700056657273696F6E002E746578742E4368C1
+:100D800069705F4350555F49734D61737465724379
+:100D90006F7265002E746578742E436869705F43C6
+:100DA00050555F434D30426F6F74002E74657874F8
+:100DB0002E436869705F4350555F434D34426F6FF7
+:100DC00074002E746578742E436869705F435055C3
+:100DD0005F53656C6563744D6173746572436F72C4
+:100DE00065002E636F6D6D656E74002E41524D2E41
+:100DF00061747472696275746573000000000000AC
+:100E000000000000000000000000000000000000E2
+:100E100000000000000000000000000000000000D2
+:100E20000000000000001B000000010000000600A0
+:100E3000000000000000340000000000000000007E
+:100E4000000000000000020000000000000021007F
+:100E5000000001000000030000000000000034005A
+:100E60000000000000000000000000000000010081
+:100E70000000000000002700000008000000030040
+:100E8000000000000000340000000000000000002E
+:100E900000000000000001000000000000002C0025
+:100EA0000000010000000600000000000000340007
+:100EB000000090000000000000000000000004009E
+:100EC00000000000000045000000010000000600D6
+:100ED000000000000000C40000001C000000000032
+:100EE00000000000000004000000000000005A00A4
+:100EF0000000010000000600000000000000E0000B
+:100F000000006C0000000000000000000000040071
+:100F10000000000000007100000001000000060059
+:100F20000000000000004C01000050000000000024
+:100F300000000000000004000000000000009D0010
+:100F400000000100000006000000000000009C01FD
+:100F500000004C0000000000000000000000040041
+:100F600000000000000099000000090000000000DF
+:100F700000000000000058180000180000002A00BF
+:100F80000000080000000400000008000000B50098
+:100F90000000010000000600000000000000E80161
+:100FA00000005000000000000000000000000400ED
+:100FB000000000000000D800000001000000060052
+:100FC00000000000000038020000440200000000A1
+:100FD0000000000000000400000000000000D40039
+:100FE0000000090000000000000000000000701870
+:100FF0000000180000002A0000000B0000000400A0
+:10100000000008000000F8000000010000000600D9
+:101010000000000000007C0400001400000000003C
+:101020000000000000000400000000000000F400C8
+:101030000000090000000000000000000000881807
+:101040000000100000002A0000000D000000040055
+:10105000000008000000160100000100000006006A
+:1010600000000000000090040000B4000000000038
+:101070000000000000000400000000000000120159
+:1010800000000900000000000000000000009818A7
+:101090000000100000002A0000000F000000040003
+:1010A0000000080000003A010000010000000600F6
+:1010B00000000000000044050000160000000000D1
+:1010C00000000000000002000000000000003601E7
+:1010D0000000090000000000000000000000A81847
+:1010E0000000080000002A000000110000000400B9
+:1010F0000000080000005F01000001000000060081
+:101100000000000000005C05000038000000000046
+:1011100000000000000004000000000000007F014B
+:10112000000001000000060000000000000094051F
+:101130000000540000000000000000000000040057
+:101140000000000000007B0100000900000000001A
+:10115000000000000000B0180000080000002A0095
+:101160000000140000000400000008000000A101BD
+:101170000000010000000600000000000000E8057B
+:10118000000010000000000000000000000004004B
+:101190000000000000009D010000090000000000A8
+:1011A000000000000000B8180000080000002A003D
+:1011B0000000160000000400000008000000B50157
+:1011C0000000010000000600000000000000F8051B
+:1011D00000001400000000000000000000000400F7
+:1011E000000000000000CD0100000100000006002A
+:1011F0000000000000000C0600009000000000004D
+:101200000000000000000400000000000000C90110
+:101210000000090000000000000000000000C018ED
+:101220000000100000002A00000019000000040067
+:10123000000008000000E5010000010000000600B9
+:101240000000000000009C060000280000000000D4
+:101250000000000000000400000000000000E101A8
+:101260000000090000000000000000000000D0188D
+:101270000000080000002A0000001B00000004001D
+:101280000000080000000502000001000000060048
+:10129000000000000000C406000024000000000060
+:1012A0000000000000000400000000000000010237
+:1012B0000000090000000000000000000000D81835
+:1012C0000000080000002A0000001D0000000400CB
+:1012D00000000800000025020000010000000600D8
+:1012E000000000000000E8060000240000000000EC
+:1012F00000000000000004000000000000002102C7
+:101300000000090000000000000000000000E018DC
+:101310000000080000002A0000001F000000040078
+:101320000000080000003D0200000100000006006F
+:101330000000000000000C07000008000000000092
+:101340000000000000000200000000000000390260
+:101350000000090000000000000000000000E81884
+:101360000000080000002A00000021000000040026
+:101370000000080000005C02000001000000060000
+:101380000000000000001407000030000000000012
+:1013900000000000000004000000000000007802CF
+:1013A00000000100000006000000000000004407EB
+:1013B00000002C00000000000000000000000400FD
+:1013C0000000000000008F02000001000000060085
+:1013D000000000000000700700002C00000000006A
+:1013E0000000000000000400000000000000A60251
+:1013F00000000100000006000000000000009C0743
+:1014000000003000000000000000000000000400A8
+:10141000000000000000C6020000010000003000D3
+:10142000000000000000CC07000071000000000078
+:101430000000000000000100000001000000CF02D9
+:1014400000000300007000000000000000003D08E4
+:10145000000031000000000000000000000001005A
+:101460000000000000001100000003000000000068
+:101470000000000000006E080000DF020000000015
+:10148000000000000000010000000000000001005A
+:101490000000020000000000000000000000301208
+:1014A0000000B00300002B0000001E00000004003C
+:1014B0000000100000000900000003000000000010
+:1014C000000000000000E0150000750200000000B0
+:1014D000000000000000010000000000000000000B
+:1014E00000000000000000000000000000000100FB
+:1014F0000000010000001C000000020005000000C8
+:1015000000000000000000000000030001000000D7
+:1015100000000000000000000000030002000000C6
+:1015200000000000000000000000030003000000B5
+:1015300000000000000000000000030004000000A4
+:101540000000000000000000000003000500000093
+:101550000000000000000000000003000600000082
+:101560000000000000000000000003000700000071
+:101570000000000000000000000003000800000060
+:101580000000000000000000000003000A0000004E
+:101590000000000000000000000003000B0000003D
+:1015A0000000000000000000000003000D0000002B
+:1015B0000000000000000000000003000F00000019
+:1015C0000000000000000000000003001100000007
+:1015D00000000000000000000000030013000000F5
+:1015E00000000000000000000000030014000000E4
+:1015F00000000000000000000000030016000000D2
+:1016000000000000000000000000030018000000BF
+:1016100000000000000000000000030019000000AE
+:101620000000000000000000000003001B0000009C
+:101630000000000000000000000003001D0000008A
+:101640000000000000000000000003001F00000078
+:101650000000000000000000000003002100000066
+:101660000000000000000000000003002300000054
+:101670000000000000000000000003002400000043
+:101680000000000000000000000003002500000032
+:101690000000000000000000000003002600000021
+:1016A0000000000000000000000003002700000010
+:1016B00000000000000000000000030028001000EF
+:1016C0000000010000009000000012000400230050
+:1016D0000000010000006C00000012000600340051
+:1016E000000001000000500000001200070056003A
+:1016F0000000010000004C0000001200080068001B
+:101700000000000000000000000010000000820047
+:101710000000000000000000000010000000960023
+:101720000000010000005000000012000A00AF009D
+:101730000000000000000000000010000000BD00DC
+:101740000000010000004402000012000B00D30062
+:101750000000010000001400000012000D00E7006E
+:101760000000000000000000000010000000EE007B
+:10177000000001000000B400000012000F0008018A
+:1017800000000000000000000000100000001E012A
+:1017900000000100000016000000120011003D01D1
+:1017A0000000010000003800000012001300530187
+:1017B00000000100000054000000120014006B0142
+:1017C0000000010000001000000012001600790166
+:1017D0000000010000001400000012001800870142
+:1017E00000000100000090000000120019009501A7
+:1017F0000000000000000000000010000000B20126
+:101800000000000000000000000010000000D001F7
+:101810000000010000002800000012001B00E6018B
+:101820000000010000002400000012001D00FC0167
+:101830000000010000002400000012001F000A0246
+:101840000000010000000800000012002100230237
+:1018500000000100000030000000120023003902E7
+:101860000000010000002C000000120024004A02C9
+:101870000000010000002C000000120025005B02A7
+:101880000000010000003000000012002600006788
+:10189000657442524F4D56657273696F6E004368AE
+:1018A00069705F504F5745525F504452656C6F638B
+:1018B000005F5F7365745F6C7076645F6C657665FE
+:1018C0006C00436869705F504F5745525F456E74B6
+:1018D0006572506F7765724D6F64654972616D4FC7
+:1018E0006E6C7900436869705F504F5745525F5383
+:1018F0006574504C4C00436869705F436C6F636B58
+:101900005F536574757053797374656D504C4C00FA
+:10191000436869705F535953434F4E5F506F77650B
+:1019200072557000436869705F504F5745525F535E
+:101930006574464C415348506F776572005F5F6134
+:10194000656162695F756964697600436869705FA3
+:10195000504F5745525F536574566F6C746167659D
+:1019600000436869705F504F5745525F52656C6F16
+:1019700063415049006D656D63707900436869701B
+:101980005F504F5745525F456E746572506F776573
+:10199000724D6F6465005F5F676E755F7468756D2B
+:1019A00062315F636173655F757169004368697077
+:1019B0005F504F5745525F456E746572506F776543
+:1019C000724D6F646552656C6F6300436869705F48
+:1019D000504F5745525F53657456444C6576656C5D
+:1019E00000436869705F504F5745525F5365744CB0
+:1019F0005056444C6576656C004E4F5455534544E3
+:101A00005F46554E4332004E4F54555345445F4652
+:101A1000554E4333004E4F54555345445F46554E43
+:101A2000433500436869705F436C6F636B5F456E5D
+:101A300061626C65506572697068436C6F636B00BE
+:101A4000436869705F436C6F636B5F446973616285
+:101A50006C65506572697068436C6F636B004368B6
+:101A600069705F504F5745525F53657441434C470F
+:101A700061746500436869705F504F5745525F4716
+:101A8000657441434C47617465004E4F545553454E
+:101A9000445F46554E433600436869705F504F5768
+:101AA00045525F476574524F4D56657273696F6E4C
+:101AB00000436869705F4350555F49734D617374AB
+:101AC0006572436F726500436869705F4350555F8C
+:101AD000434D30426F6F7400436869705F435055E7
+:101AE0005F434D34426F6F7400436869705F4350C9
+:101AF000555F53656C6563744D6173746572436FB4
+:101B0000726500000000060000000A0100001600D7
+:101B100000000A2200001E0000000A230000060048
+:101B200000000A010000E60000000A0100000C01AC
+:101B300000000A2500000A0000000A28000010002A
+:101B40000000021E0000060000000A0100001C0048
+:101B500000000A2A0000100000000A29000004000A
+:101B600000000A010000040000000A230000080031
+:101B700000000A3100007C0000000A32000004006E
+:101B800000000A010000020000000A01000002003B
+:0E1B900000000A010000020000000A0100002F
+:00000001FF
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/libs/libpower_m4f_hard.hex ./chip/libs/libpower_m4f_hard.hex
--- a_tnusFF/chip/libs/libpower_m4f_hard.hex	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/libs/libpower_m4f_hard.hex	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,435 @@
+:10000000213C617263683E0A2F202020202020209E
+:10001000202020202020202031343338333831393B
+:100020003138202030202020202030202020202087
+:10003000302020202020202035353820202020206E
+:100040002020600A00000016000002720000027208
+:1000500000000272000002720000027200000272D0
+:1000600000000272000002720000027200000272C0
+:1000700000000272000002720000027200000272B0
+:1000800000000272000002720000027200000272A0
+:100090000000027200000272000002720000027290
+:1000A000436869705F504F5745525F504452656CCA
+:1000B0006F63005F5F7365745F6C7076645F6C651F
+:1000C00076656C00436869705F504F5745525F45D5
+:1000D0006E746572506F7765724D6F6465497261B9
+:1000E0006D4F6E6C7900436869705F504F57455291
+:1000F0005F536574504C4C00436869705F504F57B4
+:1001000045525F536574464C415348506F77657252
+:1001100000436869705F504F5745525F536574568E
+:100120006F6C7461676500436869705F504F574535
+:10013000525F52656C6F6341504900436869705F5C
+:10014000504F5745525F456E746572506F776572B8
+:100150004D6F646500436869705F504F5745525F4B
+:10016000456E746572506F7765724D6F6465526548
+:100170006C6F6300436869705F504F5745525F531F
+:10018000657456444C6576656C00436869705F50D1
+:100190004F5745525F5365744C5056444C657665D5
+:1001A0006C004E4F54555345445F46554E43320004
+:1001B0004E4F54555345445F46554E4333004E4FC2
+:1001C00054555345445F46554E4335004368697066
+:1001D0005F504F5745525F53657441434C476174BC
+:1001E0006500436869705F504F5745525F476574BB
+:1001F00041434C47617465004E4F54555345445F2D
+:1002000046554E433600436869705F504F5745521C
+:100210005F476574524F4D56657273696F6E004348
+:100220006869705F4350555F49734D6173746572BF
+:10023000436F726500436869705F4350555F434D7B
+:1002400030426F6F7400436869705F4350555F437D
+:100250004D34426F6F7400436869705F4350555F5F
+:1002600053656C6563744D6173746572436F726539
+:100270000000706F7765725F6C6962726172792ECF
+:100280006F2F313433383338313931382020302032
+:1002900020202020302020202020313030363636DB
+:1002A000202036323536202020202020600A7F454D
+:1002B0004C460101010000000000000000000100A8
+:1002C0002800010000000000000000000000240BD6
+:1002D00000000000000534000000000028002C0091
+:1002E000290013B5EFF3108472B61C491D4A0B693F
+:1002F00043F004030B614FF08043D3F810120A431C
+:1003000022EA0002C3F800228020164AC3F8C8007F
+:10031000C3F81422D86430BF11F0200014D04FF07D
+:10032000804380225A65C3F810124FF48051096847
+:100330000191C3F8D020094A136923F00403136123
+:1003400084F3108802B010BDC3F818220090009BFF
+:100350007D2BE4D8009B01330093F8E700BF00ED4C
+:1003600000E0DDD7DFFB2000040000B58BB00AA859
+:10037000372340F8143D01A9034B984702980BB06E
+:100380005DF804FB00BF05020003F0B5194C059FA2
+:10039000246814F4885F04D0012829D008B9032FF9
+:1003A00026D1099C089DE40105F00105E4B244EA68
+:1003B0004516079C04F0010446EAC405069C04F0B7
+:1003C000010445EA440403F0010344EA831302F004
+:1003D000010243EA021201F0010142EA810100F048
+:1003E0000100014307F00307034B41EA07211964A9
+:1003F000F0BD0000034000C002404FF080432022C7
+:1004000010B5C3F8142272B60D490D4A0C6944F0B8
+:1004100004040C61D3F81042224322EA0002C3F81C
+:100420000022084AC3F814228022DA6430BFC3F8DD
+:1004300010420B6923F004030B6162B610BD00ED9E
+:1004400000E0DDD7DFFB2000040070B505460C4658
+:10045000FFF7FEFFB0F5885F0ED128462146FFF773
+:10046000FEFF4FF48000FFF7FEFF4FF08043D3F80C
+:10047000B431DB07F9D508E0054B1B68DB6828467B
+:1004800021461B68BDE870401847002070BD00027F
+:10049000000382B04FF080430F4A0F4988B1C3F880
+:1004A0001822C3F8181200230193019B632B02D872
+:1004B000019B0133F8E74FF080438022C3F8C82046
+:1004C00006E0C3F81412C3F814228022C3F8D02027
+:1004D00002B0704700BF0400003820000402F8B5E5
+:1004E00006460D46FFF7FEFFB0F5885F66D14FF078
+:1004F0008043724AC3F81822724B9D421BD8714C3C
+:100500002368DB68002002461B69052198472368A1
+:10051000DB6801201B690B21002298472368DB68F8
+:1005200002201B690B21002298472368DB68032007
+:100530001B6905213EE0644B9D421BD8624C236839
+:10054000DB68002002461B69092198472368DB68A5
+:1005500001201B690B21002298472368DB680220D9
+:100560001B690B21002298472368DB6803201B6965
+:1005700009211FE0564B9D4201D9554E9CE0514C3C
+:100580002368DB68002002461B690B21984723681B
+:10059000DB6801201B690B21002298472368DB6878
+:1005A00002201B690B21002298472368DB681B6926
+:1005B00003200B210022984700267DE0002E7AD1EF
+:1005C000FFF7FEFF41F2021398420BD14FF0804338
+:1005D0004149D3F8FC03404A414B984214BF1346AB
+:1005E0000B4600E03D4B4FF47A72B5FBF2F29A42B3
+:1005F000C3D84FF08043314AC3F81822D3F824718E
+:10060000384B9D4227F470471CD9364B9D421BD96D
+:1006100003F5370303F5D8539D4217D9334B9D4259
+:1006200016D9324B9D4215D903F5370303F5D8533C
+:100630009D4211D92F4B2F4A304CA5428CBF1446F6
+:100640001C460AE02E4C08E02E4C06E02E4C04E03E
+:100650002E4C02E02E4C00E02E4C1A4D2B68DB682D
+:10066000002004F00F0102461B6998472B68DB68E5
+:1006700001201B690B21002298472B68DB68C4F31B
+:1006800003311B690220002298472B68DB68C4F302
+:1006900083411B69032000229847240E4FF08043BA
+:1006A00006D047F0200747EA0434C3F8244103E0AA
+:1006B000C3F8247180E7174E3046F8BD00BF040030
+:1006C0000038FF2C310100020003FFB3C40400E135
+:1006D000F50502000B00A086010000770100CEFEA8
+:1006E000C108001BB70000366E01006CDC020087F9
+:1006F0009303CCC23004CDD2340500BD0105C7B28E
+:100700001C00C8B22001C9B22402CAB22802CBB26E
+:100710002C03CCC2300304000C000A46024921F02D
+:100720000101FFF7FEBF0000000070B505460C4652
+:10073000FFF7FEFFB0F5885F43D1032D4AD8DFE80D
+:1007400005F002081A33234A136923F004031361E6
+:1007500035E072B6204B20491A6942F004021A6152
+:100760004FF08042D2F81002014321EA0401C2F89E
+:10077000001230BF12E072B6174B18491A6942F0E6
+:1007800004021A614FF08042D2F81002014321EABC
+:100790000401C2F8001230BFC2F810021A6922F038
+:1007A00004021A6162B670BD72B60A4A136943F058
+:1007B000040313614FF08043E443C3F8104230BF99
+:1007C00070BD074B1B68DB68284621469B68BDE867
+:1007D0007040184770BD00ED00E05D07CA78DDD7B6
+:1007E000DFFB00020003022803D142F001020846A9
+:1007F0001047FFF7FEBF08B538B9084B1B6813F464
+:10080000885F02D0CB1E022B06D8054B1B68DB6825
+:100810001B699847002008BD034808BD00BF0000C1
+:1008200003400002000306000C0010B586B0FFF77D
+:10083000FEFF41F20113984209D80C4B1B6813F4D8
+:10084000885F12D10B4B4FF4AA721A640DE0094B6A
+:100850001B680020DB680190012100910290039049
+:1008600004905C690A460B46A04706B010BD000024
+:10087000034000C00240000200030148FFF7FEBF32
+:1008800000BF040000384FF08043014AC3F814222F
+:1008900070470400003837B504463D200D46FFF789
+:1008A000FEFF2CB91C4B03221A6020225A602CE058
+:1008B000012C0BD11D2D25D8184B1B6803F00F03FD
+:1008C000052B22D84FF48032134B18E0022C1BD199
+:1008D0001D2D1AD8114B1B6803F00F03033B022B8D
+:1008E00012D80C4B0E4A1A6000220192019A1E2A5D
+:1008F00002D8019A0132F8E71A6842F4C0221A605D
+:10090000002402E0022400E001243D20FFF7FEFF66
+:10091000204603B030BD0000034000C00240040088
+:10092000010010B50446FFF7FEFF41F201139842A3
+:10093000054B1B68DB68204694BF9B6A1B6BBDE8B8
+:100940001040184700BF0002000310B5FFF7FEFF7C
+:1009500041F201139842044B1B68DB68BDE810406C
+:1009600094BFDB6A5B6B184700BF0002000310B541
+:10097000FFF7FEFF41F20113984206D9044B1B68B2
+:10098000DB68BDE810409B6B1847012010BD0002DA
+:100990000003FFF7FEBF084B1B6840F62442C3F379
+:1009A0000B1393424FF08043D3F8000300F0010093
+:1009B00018BF80F00100704700BF00ED00E04FF06D
+:1009C0008043074AC3F80813C3F80403D3F80003AD
+:1009D000054902430143C3F80013C3F800237047DD
+:1009E00000BF0800C4C02800C4C04FF08043074ABD
+:1009F000C3F80813C3F80403D3F8000305490243FE
+:100A00000143C3F80013C3F80023704700BF04007C
+:100A1000C4C01400C4C04FF08043D3F8002322F0B8
+:100A2000410220B942F0404343F4440301E0044B47
+:100A3000134309B143F040034FF08042C2F8003342
+:100A400070470100C4C0004743433A2028474E5531
+:100A500020546F6F6C7320666F722041524D204599
+:100A60006D6265646465642050726F636573736F53
+:100A700072732920342E392E3320323031353035FF
+:100A80003239202872656C6561736529205B41529B
+:100A90004D2F656D6265646465642D345F392D6228
+:100AA00072616E6368207265766973696F6E203259
+:100AB00032343238385D00413800000061656162CF
+:100AC0006900012E00000005436F727465782D4D9A
+:100AD0003400060D074D09020A061204140115011F
+:100AE0001703180119011A011B011C011E04220120
+:100AF000002E73796D746162002E7374727461627A
+:100B0000002E7368737472746162002E7465787459
+:100B1000002E64617461002E627373002E74657818
+:100B2000742E436869705F504F5745525F5044526E
+:100B3000656C6F63002E746578742E67657442521D
+:100B40004F4D56657273696F6E002E746578742E02
+:100B50005F5F7365745F6C7076645F6C6576656CFF
+:100B6000002E746578742E436869705F504F574546
+:100B7000525F456E746572506F7765724D6F646534
+:100B80004972616D4F6E6C79002E72656C2E7465C2
+:100B900078742E436869705F504F5745525F5365B4
+:100BA00074504C4C002E746578742E436869705FE5
+:100BB000504F5745525F536574464C415348506FF0
+:100BC000776572002E72656C2E746578742E43689A
+:100BD00069705F504F5745525F536574566F6C7420
+:100BE000616765002E72656C2E746578742E43689B
+:100BF00069705F504F5745525F52656C6F6341504B
+:100C000049002E72656C2E746578742E4368697085
+:100C10005F504F5745525F456E746572506F7765F0
+:100C2000724D6F6465002E72656C2E746578742E3B
+:100C3000436869705F504F5745525F456E746572E7
+:100C4000506F7765724D6F646552656C6F63002EEF
+:100C5000746578742E436869705F504F5745525FD2
+:100C600053657456444C6576656C002E72656C2E27
+:100C7000746578742E436869705F504F5745525FB2
+:100C80005365744C5056444C6576656C002E726505
+:100C90006C2E746578742E4E4F54555345445F4600
+:100CA000554E4332002E746578742E4E4F54555372
+:100CB00045445F46554E4333002E72656C2E746575
+:100CC00078742E4E4F54555345445F46554E433528
+:100CD000002E72656C2E746578742E436869705F9F
+:100CE000504F5745525F53657441434C476174659B
+:100CF000002E72656C2E746578742E436869705F7F
+:100D0000504F5745525F47657441434C4761746586
+:100D1000002E72656C2E746578742E4E4F545553A8
+:100D200045445F46554E4336002E72656C2E746501
+:100D300078742E436869705F504F5745525F47651E
+:100D400074524F4D56657273696F6E002E746578DC
+:100D5000742E436869705F4350555F49734D6173EA
+:100D6000746572436F7265002E746578742E4368E3
+:100D700069705F4350555F434D30426F6F74002E72
+:100D8000746578742E436869705F4350555F434DB6
+:100D900034426F6F74002E746578742E43686970E6
+:100DA0005F4350555F53656C6563744D6173746543
+:100DB00072436F7265002E636F6D6D656E74002EE9
+:100DC00041524D2E617474726962757465730000CE
+:100DD0000000000000000000000000000000000013
+:100DE0000000000000000000000000000000000003
+:100DF000000000000000000000001B0000000100D7
+:100E000000000600000000000000340000000000A8
+:100E100000000000000000000000020000000000D0
+:100E2000000021000000010000000300000000009D
+:100E3000000034000000000000000000000000007E
+:100E40000000010000000000000027000000080072
+:100E5000000003000000000000003400000000005B
+:100E60000000000000000000000001000000000081
+:100E700000002C000000010000000600000000003F
+:100E800000003400000088000000000000000000A6
+:100E90000000040000000000000045000000010008
+:100EA00000000600000000000000BC000000200060
+:100EB000000000000000000000000400000000002E
+:100EC00000005A00000001000000060000000000C1
+:100ED0000000DC00000070000000000000000000C6
+:100EE000000004000000000000007100000001008C
+:100EF000000006000000000000004C01000050004F
+:100F000000000000000000000000040000000000DD
+:100F100000009D000000010000000600000000002D
+:100F200000009C01000048000000000000000000DC
+:100F3000000004000000000000009900000009000B
+:100F400000000000000000000000E817000018008A
+:100F500000002A0000000800000004000000080053
+:100F60000000B500000001000000060000000000C5
+:100F70000000E40100004C00000000000000000040
+:100F800000000400000000000000D8000000010084
+:100F900000000600000000000000300200003C02DB
+:100FA000000000000000000000000400000000003D
+:100FB0000000D40000000900000000000000000054
+:100FC000000000180000100000002A0000000B00C4
+:100FD00000000400000008000000F800000001000C
+:100FE000000006000000000000006C04000010007B
+:100FF00000000000000000000000040000000000ED
+:101000000000F400000009000000000000000000E3
+:10101000000010180000100000002A0000000D0061
+:10102000000004000000080000001601000001009C
+:10103000000006000000000000007C040000BC006E
+:10104000000000000000000000000400000000009C
+:101050000000120100000900000000000000000074
+:10106000000020180000080000002A0000000F0007
+:10107000000004000000080000003A010000010028
+:10108000000006000000000000003805000010000D
+:10109000000000000000000000000200000000004E
+:1010A0000000360100000900000000000000000000
+:1010B000000028180000080000002A0000001100AD
+:1010C000000004000000080000005F0100000100B3
+:1010D0000000060000000000000048050000340089
+:1010E00000000000000000000000040000000000FC
+:1010F00000007F0100000100000006000000000069
+:1011000000007C050000500000000000000000000E
+:10111000000004000000000000007B010000090046
+:10112000000000000000000000003018000008006F
+:1011300000002A0000001400000004000000080065
+:101140000000A101000001000000060000000000F6
+:101150000000CC0500000C000000000000000000B2
+:10116000000004000000000000009D0100000900D4
+:101170000000000000000000000038180000080017
+:1011800000002A0000001600000004000000080013
+:101190000000B50100000100000006000000000092
+:1011A0000000D80500001000000000000000000052
+:1011B00000000400000000000000CD01000001005C
+:1011C00000000600000000000000E80500008C00A0
+:1011D000000000000000000000000400000000000B
+:1011E0000000C9010000090000000000000000002C
+:1011F000000040180000100000002A000000190044
+:1012000000000400000008000000E50100000100EB
+:101210000000060000000000000074060000280026
+:1012200000000000000000000000040000000000BA
+:101230000000E101000009000000000000000000C3
+:10124000000050180000080000002A0000001B00E9
+:10125000000004000000080000000502000001007A
+:10126000000006000000000000009C0600002400B2
+:10127000000000000000000000000400000000006A
+:101280000000010200000900000000000000000052
+:10129000000058180000080000002A0000001D008F
+:1012A000000004000000080000002502000001000A
+:1012B00000000600000000000000C006000024003E
+:1012C000000000000000000000000400000000001A
+:1012D00000002102000009000000000000000000E2
+:1012E000000060180000080000002A0000001F0035
+:1012F000000004000000080000003D0200000100A2
+:1013000000000600000000000000E40600000400E9
+:1013100000000000000000000000020000000000CB
+:101320000000390200000900000000000000000079
+:10133000000068180000080000002A0000002100DA
+:10134000000004000000080000005C020000010032
+:1013500000000600000000000000E8060000280071
+:101360000000000000000000000004000000000079
+:1013700000007802000001000000060000000000EC
+:101380000000100700002C0000000000000000001A
+:10139000000004000000000000008F0200000100B7
+:1013A000000006000000000000003C0700002C00C8
+:1013B0000000000000000000000004000000000029
+:1013C0000000A6020000010000000600000000006E
+:1013D000000068070000300000000000000000006E
+:1013E00000000400000000000000C6020000010030
+:1013F00000003000000000000000980700007100AD
+:1014000000000000000000000000010000000100DA
+:101410000000CF0200000300007000000000000088
+:101420000000090800003900000000000000000072
+:101430000000010000000000000011000000030097
+:101440000000000000000000000042080000DF0271
+:10145000000000000000000000000100000000008B
+:101460000000010000000200000000000000000079
+:10147000000004120000900300002B0000001E007A
+:10148000000004000000100000000900000003003C
+:101490000000000000000000000094150000510250
+:1014A000000000000000000000000100000000003B
+:1014B000000000000000000000000000000000002C
+:1014C00000000100000001000000200000000200F8
+:1014D0000500000000000000000000000000030004
+:1014E00001000000000000000000000000000300F8
+:1014F00002000000000000000000000000000300E7
+:1015000003000000000000000000000000000300D5
+:1015100004000000000000000000000000000300C4
+:1015200005000000000000000000000000000300B3
+:1015300006000000000000000000000000000300A2
+:101540000700000000000000000000000000030091
+:101550000800000000000000000000000000030080
+:101560000A0000000000000000000000000003006E
+:101570000B0000000000000000000000000003005D
+:101580000D0000000000000000000000000003004B
+:101590000F00000000000000000000000000030039
+:1015A0001100000000000000000000000000030027
+:1015B0001300000000000000000000000000030015
+:1015C0001400000000000000000000000000030004
+:1015D00016000000000000000000000000000300F2
+:1015E00018000000000000000000000000000300E0
+:1015F00019000000000000000000000000000300CF
+:101600001B000000000000000000000000000300BC
+:101610001D000000000000000000000000000300AA
+:101620001F00000000000000000000000000030098
+:101630002100000000000000000000000000030086
+:101640002300000000000000000000000000030074
+:101650002400000000000000000000000000030063
+:101660002500000000000000000000000000030052
+:101670002600000000000000000000000000030041
+:101680002700000000000000000000000000030030
+:101690002800100000000100000088000000120077
+:1016A0000400230000000100000070000000120090
+:1016B000060034000000010000005000000012008D
+:1016C0000700560000000100000048000000120062
+:1016D000080068000000000000000000000010008A
+:1016E0000000820000000000000000000000100068
+:1016F000000096000000010000004C0000001200F5
+:101700000A00AF000000010000003C0200001200CF
+:101710000B00C500000001000000100000001200D6
+:101720000D00D900000000000000000000001000C3
+:101730000000E000000001000000BC0000001200FA
+:101740000F00FA000000010000001000000012006D
+:101750001100190100000100000034000000120017
+:1017600013002F01000001000000500000001200D3
+:10177000140047010000010000000C0000001200EE
+:1017800016005501000001000000100000001200CA
+:10179000180063010000010000008C00000012002E
+:1017A000190071010000000000000000000010009E
+:1017B00000008E010000000000000000000010008A
+:1017C0000000AC0100000100000028000000120031
+:1017D0001B00C201000001000000240000001200F4
+:1017E0001D00D801000001000000240000001200CC
+:1017F0001F00E601000001000000040000001200CC
+:101800002100FF010000010000002800000012007C
+:10181000230015020000010000002C00000012004F
+:10182000240026020000010000002C00000012002D
+:101830002500370200000100000030000000120007
+:1018400026000067657442524F4D56657273696F8A
+:101850006E00436869705F504F5745525F50445265
+:10186000656C6F63005F5F7365745F6C7076645F57
+:101870006C6576656C00436869705F504F574552E0
+:101880005F456E746572506F7765724D6F64654920
+:1018900072616D4F6E6C7900436869705F504F578D
+:1018A00045525F536574504C4C00436869705F4308
+:1018B0006C6F636B5F536574757053797374656D8A
+:1018C000504C4C00436869705F535953434F4E5F0F
+:1018D000506F776572557000436869705F504F575D
+:1018E00045525F536574464C415348506F7765725B
+:1018F00000436869705F504F5745525F5365745697
+:101900006F6C7461676500436869705F504F57453D
+:10191000525F52656C6F63415049006D656D637035
+:101920007900436869705F504F5745525F456E7448
+:101930006572506F7765724D6F64650043686970BA
+:101940005F504F5745525F456E746572506F7765B3
+:10195000724D6F646552656C6F6300436869705FB8
+:10196000504F5745525F53657456444C6576656CCD
+:1019700000436869705F504F5745525F5365744C20
+:101980005056444C6576656C004E4F545553454453
+:101990005F46554E4332004E4F54555345445F46C3
+:1019A000554E4333004E4F54555345445F46554EB4
+:1019B000433500436869705F436C6F636B5F456ECE
+:1019C00061626C65506572697068436C6F636B002F
+:1019D000436869705F436C6F636B5F4469736162F6
+:1019E0006C65506572697068436C6F636B00436827
+:1019F00069705F504F5745525F53657441434C4780
+:101A000061746500436869705F504F5745525F4786
+:101A1000657441434C47617465004E4F54555345BE
+:101A2000445F46554E433600436869705F504F57D8
+:101A300045525F476574524F4D56657273696F6EBC
+:101A400000436869705F4350555F49734D6173741B
+:101A50006572436F726500436869705F4350555FFC
+:101A6000434D30426F6F7400436869705F43505557
+:101A70005F434D34426F6F7400436869705F435039
+:101A8000555F53656C6563744D6173746572436F24
+:101A9000726500000000060000000A01000014004A
+:101AA00000000A2200001C0000000A2300000600BB
+:101AB00000000A010000E20000000A0100000C0022
+:101AC0000000021E0000080000001E2700000600A3
+:101AD00000000A0100000C0000001E2800000400A5
+:101AE00000000A010000020000001E2300000800A0
+:101AF00000000A2F0000760000000A3000000400F9
+:101B000000000A010000020000000A0100000200BB
+:0E1B100000000A010000000000001E0100009D
+:00000001FF
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/adc_5410x.c ./chip/src/adc_5410x.c
--- a_tnusFF/chip/src/adc_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/adc_5410x.c	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,129 @@
+/*
+ * @brief LPC5410X ADC driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the ADC peripheral */
+void Chip_ADC_Init(LPC_ADC_T *pADC, uint32_t flags)
+{
+	/* Power up ADC and enable ADC base clock */
+	Chip_SYSCON_PowerUp(SYSCON_PDRUNCFG_PD_ADC0 | SYSCON_PDRUNCFG_PD_VDDA_ENA | SYSCON_PDRUNCFG_PD_VREFP);
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_ADC0);
+
+	/* Disable ADC interrupts */
+	pADC->INTEN = 0;
+
+	/* Set ADC control options */
+	pADC->CTRL = flags;
+}
+
+/* Shutdown ADC */
+void Chip_ADC_DeInit(LPC_ADC_T *pADC)
+{
+	pADC->INTEN = 0;
+	pADC->CTRL = 0;
+
+	/* Stop ADC clock and then power down ADC */
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_ADC0);
+	Chip_SYSCON_PowerDown(SYSCON_PDRUNCFG_PD_ADC0 | SYSCON_PDRUNCFG_PD_VDDA_ENA | SYSCON_PDRUNCFG_PD_VREFP);
+}
+
+/* Calibrate ADC for system clock frequency */
+uint32_t Chip_ADC_Calibration(LPC_ADC_T *pADC)
+{
+	volatile uint32_t i;
+	uint32_t sysclk_freq = Chip_Clock_GetSystemClockRate();
+
+	pADC->STARTUP = ADC_STARTUP_ENABLE;
+	for ( i = 0; i < 0x10; i++ ) {}
+	if ( !(pADC->STARTUP & ADC_STARTUP_ENABLE) ) {
+		return ERR_ADC_NO_POWER;
+	}
+
+	/* If not in by-pass mode do the calibration */
+	if ( (pADC->CALIBR & ADC_CALREQD) && !(pADC->CTRL & ADC_CR_BYPASS) ) {
+		uint32_t ctrl = pADC->CTRL & 0x7FFF;
+		uint32_t tmp = ctrl;
+
+		/* Set ADC to SYNC mode */
+		tmp &= ~ADC_CR_ASYNC_MODE;
+
+		/* To be safe run calibration at 1MHz UM permits upto 30MHz */
+		if (sysclk_freq > 1000000UL) {
+			pADC->CTRL = tmp | (((sysclk_freq / 1000000UL) - 1) & 0xFF);
+		}
+
+		/* Calibration is needed, do it now. */
+		pADC->CALIBR = ADC_CALIB;
+		i = 0xF0000;
+		while ( (pADC->CALIBR & ADC_CALIB) && --i ) {}
+		pADC->CTRL = ctrl;
+		return i ? LPC_OK : ERR_TIME_OUT;
+	}
+
+	/* A dummy conversion cycle will be performed. */
+	pADC->STARTUP = (pADC->STARTUP | ADC_STARTUP_INIT) & 0x03;
+	i = 0x7FFFF;
+	while ( (pADC->STARTUP & ADC_STARTUP_INIT) && --i ) {}
+	return i ? LPC_OK : ERR_TIME_OUT;
+}
+
+/* Set ADC clock rate */
+void Chip_ADC_SetClockRate(LPC_ADC_T *pADC, uint32_t rate)
+{
+	uint32_t div;
+
+	/* Get ADC clock source to determine base ADC rate. IN sychronous mode,
+	   the ADC base clock comes from the system clock. In ASYNC mode, it
+	   comes from the ASYNC ADC clock and this function doesn't work. */
+	div = Chip_Clock_GetSystemClockRate() / rate;
+	if (div == 0) {
+		div = 1;
+	}
+
+	Chip_ADC_SetDivider(pADC, (uint8_t) div - 1);
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/chip_5410x.c ./chip/src/chip_5410x.c
--- a_tnusFF/chip/src/chip_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/chip_5410x.c	2016-10-22 23:17:43.576840278 -0300
@@ -0,0 +1,59 @@
+/*
+ * @brief LPC5410X Miscellaneous chip specific functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/* System Clock Frequency (Core Clock) */
+uint32_t SystemCoreClock;
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Update system core clock rate, should be called if the system has
+   a clock rate change */
+void SystemCoreClockUpdate(void)
+{
+	/* CPU core speed (main clock speed adjusted by system clock divider) */
+	SystemCoreClock = Chip_Clock_GetSystemClockRate();
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/clock_5410x.c ./chip/src/clock_5410x.c
--- a_tnusFF/chip/src/clock_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/clock_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,393 @@
+/*
+ * @brief LPC5410X clock driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Return asynchronous APB clock rate (no regard for divider) */
+static uint32_t Chip_Clock_GetAsyncSyscon_ClockRate_NoDiv(void)
+{
+	CHIP_ASYNC_SYSCON_SRC_T src;
+	uint32_t clkRate;
+
+	src = Chip_Clock_GetAsyncSysconClockSource();
+	switch (src) {
+	case SYSCON_ASYNC_IRC:
+		clkRate = Chip_Clock_GetIntOscRate();
+		break;
+
+	case SYSCON_ASYNC_WDTOSC:
+		clkRate = Chip_Clock_GetWDTOSCRate();
+		break;
+
+	case SYSCON_ASYNC_MAINCLK:
+		clkRate = Chip_Clock_GetMainClockRate();
+		break;
+
+	case SYSCON_ASYNC_CLKIN:
+		clkRate = Chip_Clock_GetSystemPLLInClockRate();
+		break;
+
+	case SYSCON_ASYNC_SYSPLLOUT:
+		clkRate = Chip_Clock_GetSystemPLLOutClockRate(false);
+		break;
+
+	default:
+		clkRate = 0;
+		break;
+	}
+
+	return clkRate;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Return main A clock rate */
+uint32_t Chip_Clock_GetMain_A_ClockRate(void)
+{
+	uint32_t clkRate = 0;
+
+	switch (Chip_Clock_GetMain_A_ClockSource()) {
+	case SYSCON_MAIN_A_CLKSRC_IRC:
+		clkRate = Chip_Clock_GetIntOscRate();
+		break;
+
+	case SYSCON_MAIN_A_CLKSRCA_CLKIN:
+		clkRate = Chip_Clock_GetExtClockInRate();
+		break;
+
+	case SYSCON_MAIN_A_CLKSRCA_WDTOSC:
+		clkRate = Chip_Clock_GetWDTOSCRate();
+		break;
+
+	default:
+		clkRate = 0;
+		break;
+	}
+
+	return clkRate;
+}
+
+/* Return main B clock rate */
+uint32_t Chip_Clock_GetMain_B_ClockRate(void)
+{
+	uint32_t clkRate = 0;
+
+	switch (Chip_Clock_GetMain_B_ClockSource()) {
+	case SYSCON_MAIN_B_CLKSRC_MAINCLKSELA:
+		clkRate = Chip_Clock_GetMain_A_ClockRate();
+		break;
+
+	case SYSCON_MAIN_B_CLKSRC_SYSPLLIN:
+		clkRate = Chip_Clock_GetSystemPLLInClockRate();
+		break;
+
+	case SYSCON_MAIN_B_CLKSRC_SYSPLLOUT:
+		clkRate = Chip_Clock_GetSystemPLLOutClockRate(false);
+		break;
+
+	case SYSCON_MAIN_B_CLKSRC_RTC:
+		clkRate = Chip_Clock_GetRTCOscRate();
+		break;
+	}
+
+	return clkRate;
+}
+
+/* Set CLKOUT clock source and divider */
+void Chip_Clock_SetCLKOUTSource(CHIP_SYSCON_CLKOUTSRC_T src, uint32_t div)
+{
+	uint32_t srcClk = (uint32_t) src;
+
+	/* Use a clock A source? */
+	if (src >= SYSCON_CLKOUTSRCA_OUTPUT) {
+		/* Not using a CLKOUT A source */
+		LPC_SYSCON->CLKOUTSELB = srcClk - SYSCON_CLKOUTSRCA_OUTPUT;
+	}
+	else {
+		/* Using a clock A source, select A and then switch B to A */
+		LPC_SYSCON->CLKOUTSELA = srcClk;
+		LPC_SYSCON->CLKOUTSELB = 0;
+	}
+
+	LPC_SYSCON->CLKOUTDIV = div;
+}
+
+/* Enable a system or peripheral clock */
+void Chip_Clock_EnablePeriphClock(CHIP_SYSCON_CLOCK_T clk)
+{
+	uint32_t clkEnab = (uint32_t) clk;
+
+	if (clkEnab >= 128) {
+		clkEnab = clkEnab - 128;
+
+		LPC_ASYNC_SYSCON->ASYNCAPBCLKCTRLSET = (1 << clkEnab);
+	}
+	else if (clkEnab >= 32) {
+		LPC_SYSCON->AHBCLKCTRLSET[1] = (1 << (clkEnab - 32));
+	}
+	else {
+		LPC_SYSCON->AHBCLKCTRLSET[0] = (1 << clkEnab);
+	}
+}
+
+/* Disable a system or peripheral clock */
+void Chip_Clock_DisablePeriphClock(CHIP_SYSCON_CLOCK_T clk)
+{
+	uint32_t clkEnab = (uint32_t) clk;
+
+	if (clkEnab >= 128) {
+		clkEnab = clkEnab - 128;
+
+		LPC_ASYNC_SYSCON->ASYNCAPBCLKCTRLCLR = (1 << clkEnab);
+	}
+	else if (clkEnab >= 32) {
+		LPC_SYSCON->AHBCLKCTRLCLR[1] = (1 << (clkEnab - 32));
+	}
+	else {
+		LPC_SYSCON->AHBCLKCTRLCLR[0] = (1 << clkEnab);
+	}
+}
+
+/* Returns the system tick rate as used with the system tick divider */
+uint32_t Chip_Clock_GetSysTickClockRate(void)
+{
+	uint32_t sysRate, div;
+
+	div = LPC_SYSCON->SYSTICKCLKDIV;
+
+	/* If divider is 0, the system tick clock is disabled */
+	if (div == 0) {
+		sysRate = 0;
+	}
+	else {
+		sysRate = Chip_Clock_GetSystemClockRate() / LPC_SYSCON->SYSTICKCLKDIV;
+	}
+
+	return sysRate;
+}
+
+/* Return ADC clock rate */
+uint32_t Chip_Clock_GetADCClockRate(void)
+{
+	uint32_t div, clkRate = 0;
+
+	div = Chip_Clock_GetADCClockDiv();
+
+	/* ADC clock only enabled if div>0 */
+	if (div > 0) {
+		switch (Chip_Clock_GetADCClockSource()) {
+		case SYSCON_ADCCLKSELSRC_MAINCLK:
+			clkRate = Chip_Clock_GetMainClockRate();
+			break;
+
+		case SYSCON_ADCCLKSELSRC_SYSPLLOUT:
+			clkRate = Chip_Clock_GetSystemPLLOutClockRate(false);
+			break;
+
+		case SYSCON_ADCCLKSELSRC_IRC:
+			clkRate = Chip_Clock_GetIntOscRate();
+			break;
+		}
+
+		clkRate = clkRate / div;
+	}
+
+	return clkRate;
+}
+
+/* Set asynchronous APB clock source */
+void Chip_Clock_SetAsyncSysconClockSource(CHIP_ASYNC_SYSCON_SRC_T src)
+{
+	uint32_t clkSrc = (uint32_t) src;
+
+	if (src >= SYSCON_ASYNC_MAINCLK) {
+		LPC_ASYNC_SYSCON->ASYNCAPBCLKSELB = (clkSrc - 4);
+	}
+	else {
+		LPC_ASYNC_SYSCON->ASYNCAPBCLKSELA = clkSrc;
+		LPC_ASYNC_SYSCON->ASYNCAPBCLKSELB = 3;
+	}
+}
+
+/* Get asynchronous APB clock source */
+CHIP_ASYNC_SYSCON_SRC_T Chip_Clock_GetAsyncSysconClockSource(void)
+{
+	uint32_t clkSrc;
+
+	if (LPC_ASYNC_SYSCON->ASYNCAPBCLKSELB == 3) {
+		clkSrc = LPC_ASYNC_SYSCON->ASYNCAPBCLKSELA;
+	}
+	else {
+		clkSrc = 4 + LPC_ASYNC_SYSCON->ASYNCAPBCLKSELB;
+	}
+
+	return (CHIP_ASYNC_SYSCON_SRC_T) clkSrc;
+}
+
+/* Return asynchronous APB clock rate */
+uint32_t Chip_Clock_GetAsyncSyscon_ClockRate(void)
+{
+	uint32_t clkRate, div;
+
+	clkRate = Chip_Clock_GetAsyncSyscon_ClockRate_NoDiv();
+	div = LPC_ASYNC_SYSCON->ASYNCCLKDIV;
+	if (div == 0) {
+		/* Clock is disabled */
+		return 0;
+	}
+
+	return clkRate / div;
+}
+
+/* Set main system clock source */
+void Chip_Clock_SetMainClockSource(CHIP_SYSCON_MAINCLKSRC_T src)
+{
+	uint32_t clkSrc = (uint32_t) src;
+
+	if (clkSrc >= 4) {
+		/* Main B source only, not using main A */
+		Chip_Clock_SetMain_B_ClockSource((CHIP_SYSCON_MAIN_B_CLKSRC_T) (clkSrc - 4));
+	}
+	else {
+		/* Select main A clock source and set main B source to use main A */
+		Chip_Clock_SetMain_A_ClockSource((CHIP_SYSCON_MAIN_A_CLKSRC_T) clkSrc);
+		Chip_Clock_SetMain_B_ClockSource(SYSCON_MAIN_B_CLKSRC_MAINCLKSELA);
+	}
+}
+
+/* Returns the main clock source */
+CHIP_SYSCON_MAINCLKSRC_T Chip_Clock_GetMainClockSource(void)
+{
+	CHIP_SYSCON_MAIN_B_CLKSRC_T srcB;
+	uint32_t clkSrc;
+
+	/* Get main B clock source */
+	srcB = Chip_Clock_GetMain_B_ClockSource();
+	if (srcB == SYSCON_MAIN_B_CLKSRC_MAINCLKSELA) {
+		/* Using source A, so return source A */
+		clkSrc = (uint32_t) Chip_Clock_GetMain_A_ClockSource();
+	}
+	else {
+		/* Using source B */
+		clkSrc = 4 + (uint32_t) srcB;
+	}
+
+	return (CHIP_SYSCON_MAINCLKSRC_T) clkSrc;
+}
+
+/* Return main clock rate */
+uint32_t Chip_Clock_GetMainClockRate(void)
+{
+	uint32_t clkRate;
+
+	if (Chip_Clock_GetMain_B_ClockSource() == SYSCON_MAIN_B_CLKSRC_MAINCLKSELA) {
+		/* Return main A clock rate */
+		clkRate = Chip_Clock_GetMain_A_ClockRate();
+	}
+	else {
+		/* Return main B clock rate */
+		clkRate = Chip_Clock_GetMain_B_ClockRate();
+	}
+
+	return clkRate;
+}
+
+/* Return system clock rate */
+uint32_t Chip_Clock_GetSystemClockRate(void)
+{
+	/* No point in checking for divide by 0 */
+	return Chip_Clock_GetMainClockRate() / LPC_SYSCON->AHBCLKDIV;
+}
+
+/* Get UART base rate */
+uint32_t Chip_Clock_GetUARTBaseClockRate(void)
+{
+	uint64_t inclk;
+
+	/* Get clock rate into FRG */
+	inclk = (uint64_t) Chip_Clock_GetAsyncSyscon_ClockRate();
+
+	if (inclk != 0) {
+		uint32_t mult, divmult;
+
+		divmult = LPC_ASYNC_SYSCON->FRGCTRL & 0xFF;
+		if ((divmult & 0xFF) == 0xFF) {
+			/* Fractional part is enabled, get multiplier */
+			mult = (divmult >> 8) & 0xFF;
+
+			/* Get fractional error */
+			inclk = (inclk * 256) / (uint64_t) (256 + mult);
+		}
+	}
+
+	return (uint32_t) inclk;
+}
+
+/* Set UART base rate */
+uint32_t Chip_Clock_SetUARTBaseClockRate(uint32_t rate)
+{
+	uint32_t div, inclk, err;
+	uint64_t uart_fra_multiplier;
+
+	/* Input clock into FRG block is the main system cloock */
+	inclk = Chip_Clock_GetAsyncSyscon_ClockRate();
+
+	/* Get integer divider for coarse rate */
+	div = inclk / rate;
+	if (div == 0) {
+		div = 1;
+	}
+
+	/* Enable FRG clock */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_FRG);
+
+	err = inclk - (rate * div);
+	uart_fra_multiplier = (((uint64_t) err + (uint64_t) rate) * 256) / (uint64_t) (rate * div);
+
+	/* Enable fractional divider and set multiplier */
+	LPC_ASYNC_SYSCON->FRGCTRL = 0xFF | (uart_fra_multiplier << 8);
+
+	return Chip_Clock_GetUARTBaseClockRate();
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/crc_5410x.c ./chip/src/crc_5410x.c
--- a_tnusFF/chip/src/crc_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/crc_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,118 @@
+/*
+ * @brief LPC5410X Cyclic Redundancy Check (CRC) Engine driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize CRC engine */
+void Chip_CRC_Init(void)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_CRC);
+	Chip_SYSCON_PeriphReset(RESET_CRC);
+}
+
+/* De-initialize CRC engine */
+void Chip_CRC_Deinit(void)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_CRC);
+}
+
+/* Sets up the CRC engine with defaults based on the polynomial to be used */
+void Chip_CRC_UseDefaultConfig(CRC_POLY_T poly)
+{
+	switch (poly) {
+	case CRC_POLY_CRC16:
+		Chip_CRC_UseCRC16();
+		break;
+
+	case CRC_POLY_CRC32:
+		Chip_CRC_UseCRC32();
+		break;
+
+	case CRC_POLY_CCITT:
+	default:
+		Chip_CRC_UseCCITT();
+		break;
+	}
+}
+
+/* configure CRC engine and compute CCITT checksum from 8-bit data */
+uint32_t Chip_CRC_CRC8(const uint8_t *data, uint32_t bytes)
+{
+	Chip_CRC_UseCCITT();
+	while (bytes > 0) {
+		Chip_CRC_Write8(*data);
+		data++;
+		bytes--;
+	}
+
+	return Chip_CRC_Sum();
+}
+
+/* Convenience function for computing a standard CRC16 checksum from 16-bit data block */
+uint32_t Chip_CRC_CRC16(const uint16_t *data, uint32_t hwords)
+{
+	Chip_CRC_UseCRC16();
+	while (hwords > 0) {
+		Chip_CRC_Write16(*data);
+		data++;
+		hwords--;
+	}
+
+	return Chip_CRC_Sum();
+}
+
+/* Convenience function for computing a standard CRC32 checksum from 32-bit data block */
+uint32_t Chip_CRC_CRC32(const uint32_t *data, uint32_t words)
+{
+	Chip_CRC_UseCRC32();
+	while (words > 0) {
+		Chip_CRC_Write32(*data);
+		data++;
+		words--;
+	}
+
+	return Chip_CRC_Sum();
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/dma_5410x.c ./chip/src/dma_5410x.c
--- a_tnusFF/chip/src/dma_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/dma_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,67 @@
+/*
+ * @brief DMA driver declarations and functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* DMA SRAM table - this can be optionally used with the Chip_DMA_SetSRAMBase()
+   function if a DMA SRAM table is needed. This table is correctly aligned for
+     the DMA controller. */
+
+/* Set alignement to 512 bytes */
+ALIGN(512) DMA_CHDESC_T Chip_DMA_Table[MAX_DMA_CHANNEL];
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Sets up a DMA channel with the passed DMA transfer descriptor */
+bool Chip_DMA_SetupTranChannel(LPC_DMA_T *pDMA, DMA_CHID_T ch, DMA_CHDESC_T *desc)
+{
+	bool good = false;
+	DMA_CHDESC_T *pDesc = (DMA_CHDESC_T *) pDMA->SRAMBASE;
+
+	if ((Chip_DMA_GetActiveChannels(pDMA) & (1 << ch)) == 0) {
+		/* Channel is not active, so update the descriptor */
+		pDesc[ch] = *desc;
+
+		good = true;
+	}
+
+	return good;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/fifo_5410x.c ./chip/src/fifo_5410x.c
--- a_tnusFF/chip/src/fifo_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/fifo_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,306 @@
+/*
+ * @brief LPC5410X System FIFO chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/** SPI FIFO read FIFO statuses */
+#define LPC_SPIRXFIFO_STAT_SSEL0N       (1 << 16)		/*!< Slave select for receive on SSEL0 (active low) */
+#define LPC_SPIRXFIFO_STAT_SSEL1N       (1 << 17)		/*!< Slave select for receive on SSEL1 (active low) */
+#define LPC_SPIRXFIFO_STAT_SSEL2N       (1 << 18)		/*!< Slave select for receive on SSEL2 (active low) */
+#define LPC_SPIRXFIFO_STAT_SSEL3N       (1 << 19)		/*!< Slave select for receive on SSEL3 (active low) */
+#define LPC_SPIRXFIFO_STAT_SOT          (1 << 20)		/*!< This flag will be 1 if this is the first data after the SSELs went from deasserted to asserted */
+
+/** SPI FIFO write FIFO control */
+#define LPC_SPITXFIFO_CTRL_SSEL0N       (1 << 16)		/*!< Master assert for receive on SSEL0 (active low) */
+#define LPC_SPITXFIFO_CTRL_SSEL1N       (1 << 17)		/*!< Master assert for receive on SSEL1 (active low) */
+#define LPC_SPITXFIFO_CTRL_SSEL2N       (1 << 18)		/*!< Master assert for receive on SSEL2 (active low) */
+#define LPC_SPITXFIFO_CTRL_SSEL3N       (1 << 19)		/*!< Master assert for receive on SSEL3 (active low) */
+#define LPC_SPITXFIFO_CTRL_EOT          (1 << 20)		/*!< End of Transfer. The asserted SSEL will be deasserted at the end of a transfer */
+#define LPC_SPITXFIFO_CTRL_EOF          (1 << 21)		/*!< End of Frame. Between frames, a delay may be inserted, as defined by the FRAME_DELAY value in the DLY register */
+#define LPC_SPITXFIFO_CTRL_RXIGNORE     (1 << 22)		/*!< Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver */
+#define LPC_SPITXFIFO_CTRL_LEN(n)       ((n) << 24)		/*!< Data Length. Specifies the data length from 1 to 16 bits ((n-1) encoded) */
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initializes the system FIFO */
+void Chip_FIFO_Init(LPC_FIFO_T *pFIFO)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_FIFO);
+	Chip_SYSCON_PeriphReset(RESET_FIFO);
+}
+
+/* Deinitializes the system FIFO */
+void Chip_FIFO_Deinit(LPC_FIFO_T *pFIFO)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_FIFO);
+}
+
+/* Get the FIFO space available for the USART/SPI direction */
+uint32_t Chip_FIFO_GetFifoSpace(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir)
+{
+	uint32_t pcfg;
+
+	if (periphId == FIFO_USART) {
+		pcfg = pFIFO->common.FIFOCTLUSART;
+	}
+	else {
+		pcfg = pFIFO->common.FIFOCTLSPI;
+	}
+
+	if (dir == FIFO_RX) {
+		pcfg = pcfg >> 16;
+	}
+	else {
+		pcfg = pcfg >> 24;
+	}
+
+	return pcfg & 0xFF;
+}
+
+/* Pause a peripheral FIFO */
+void Chip_FIFO_PauseFifo(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir)
+{
+	if (periphId == FIFO_USART) {
+		if (dir == FIFO_RX) {
+			pFIFO->common.FIFOCTLUSART |= (1 << 0);
+		}
+		else {
+			pFIFO->common.FIFOCTLUSART |= (1 << 8);
+		}
+	}
+	else {
+		if (dir == FIFO_RX) {
+			pFIFO->common.FIFOCTLSPI |= (1 << 0);
+		}
+		else {
+			pFIFO->common.FIFOCTLSPI |= (1 << 8);
+		}
+	}
+}
+
+/* Unpause a peripheral FIFO */
+void Chip_FIFO_UnpauseFifo(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_DIR_T dir)
+{
+	if (periphId == FIFO_USART) {
+		if (dir == FIFO_RX) {
+			pFIFO->common.FIFOCTLUSART &= ~(1 << 0);
+		}
+		else {
+			pFIFO->common.FIFOCTLUSART &= ~(1 << 8);
+		}
+	}
+	else {
+		if (dir == FIFO_RX) {
+			pFIFO->common.FIFOCTLSPI &= ~(1 << 0);
+		}
+		else {
+			pFIFO->common.FIFOCTLSPI &= ~(1 << 8);
+		}
+	}
+}
+
+/* Configure a peripheral's FIFO sizes */
+void Chip_FIFO_ConfigFifoSize(LPC_FIFO_T *pFIFO, LPC_FIFO_PERIPHID_T periphId, LPC_FIFO_CFGSIZE_T *pSizes)
+{
+	int maxP, i;
+	uint32_t upDateMask;
+	volatile uint32_t *updateReg, *pFifoSizes, *pFifoPause;
+
+	/* Pause FIFOs */
+	Chip_FIFO_PauseFifo(LPC_FIFO, periphId, FIFO_RX);
+	Chip_FIFO_PauseFifo(LPC_FIFO, periphId, FIFO_TX);
+
+	/* Maximum peripheral FIFOs supported */
+	if (periphId == FIFO_USART) {
+		maxP = LPC_FIFO_USART_MAX;
+		updateReg = &pFIFO->common.FIFOUPDATEUSART;
+		upDateMask = 0xF | (0xF << 16);
+		pFifoSizes = &pFIFO->common.FIFOCFGUSART[0];
+		pFifoPause = &pFIFO->common.FIFOCTLUSART;
+	}
+	else {
+		maxP = LPC_FIFO_SPI_MAX;
+		updateReg = &pFIFO->common.FIFOUPDATESPI;
+		upDateMask = 0x3 | (0x3 << 16);
+		pFifoSizes = &pFIFO->common.FIFOCFGSPI[0];
+		pFifoPause = &pFIFO->common.FIFOCTLSPI;
+	}
+
+	/* Wait for FIFO pause */
+	while ((*pFifoPause & ((1 << 0) | (1 << 8))) != ((1 << 0) | (1 << 8))) {}
+
+	/* Update FIFO sizes */
+	for (i = 0; i < maxP; i++) {
+		pFifoSizes[i] = ((uint32_t) (pSizes->fifoRXSize[i]) << 0) |
+						((uint32_t) (pSizes->fifoTXSize[i]) << 8);
+	}
+
+	/* Update all peripheral FIFO sizes */
+	*updateReg = upDateMask;
+}
+
+/* Configure the USART system FIFO */
+void Chip_FIFOUSART_Configure(LPC_FIFO_T *pFIFO, int usartIndex, LPC_FIFO_CFG_T *pUSARTCfg)
+{
+	pFIFO->usart[usartIndex].CFG =
+		(pUSARTCfg->noTimeoutContWrite << 4) |
+		(pUSARTCfg->noTimeoutContEmpty << 5) |
+		(pUSARTCfg->timeoutBase << 8) |
+		(pUSARTCfg->timeoutValue << 12) |
+		(pUSARTCfg->rxThreshold << 16) |
+		(pUSARTCfg->txThreshold << 24);
+}
+
+/* Write data to a system FIFO (non-blocking) */
+int Chip_FIFOUSART_WriteTX(LPC_FIFO_T *pFIFO, int usartIndex, bool sz8, void *buff, int numData)
+{
+	int datumWritten, sz16;
+	uint8_t *p8 = (uint8_t *) buff;
+	uint16_t *p16 = (uint16_t *) buff;
+
+	/* Get configured FIFO size to determine write size, limit to buffer size */
+	sz16 = (pFIFO->usart[usartIndex].STAT >> 24) & 0xFF;
+	if (sz16 > numData) {
+		sz16 = numData;
+	}
+	datumWritten = sz16;
+
+	/* Write from buffer */
+	while (sz16 > 0) {
+		if (sz8) {
+			pFIFO->usart[usartIndex].TXDAT = (uint32_t) *p8;
+			p8++;
+		}
+		else {
+			pFIFO->usart[usartIndex].TXDAT = (uint32_t) *p16;
+			p16++;
+		}
+
+		sz16--;
+	}
+
+	return datumWritten;
+}
+
+/* Read data from a system FIFO (non-blocking) */
+int Chip_FIFOUSART_ReadRX(LPC_FIFO_T *pFIFO, int usartIndex, bool sz8, void *buff, int numData)
+{
+	int datumRead, sz16;
+	uint8_t *p8 = (uint8_t *) buff;
+	uint16_t *p16 = (uint16_t *) buff;
+
+	/* Get configured FIFO size to determine read size, limit to buffer size */
+	sz16 = (pFIFO->usart[usartIndex].STAT >> 16) & 0xFF;
+	if (sz16 > numData) {
+		sz16 = numData;
+	}
+	datumRead = sz16;
+
+	/* Read into buffer */
+	while (sz16 > 0) {
+		if (sz8) {
+			*p8 = (uint8_t) (pFIFO->usart[usartIndex].RXDAT & 0xFF);
+			p8++;
+		}
+		else {
+			*p16 = (uint16_t) (pFIFO->usart[usartIndex].RXDAT & 0x1FF);
+			p16++;
+		}
+
+		sz16--;
+	}
+
+	return datumRead;
+}
+
+/* Read data from a system FIFO with status (non-blocking) */
+int Chip_FIFOUSART_ReadRXStatus(LPC_FIFO_T *pFIFO, int usartIndex, uint16_t *buff, int numData)
+{
+	int datumRead, sz16;
+	uint16_t *p16 = (uint16_t *) buff;
+
+	/* Get configured FIFO size to determine read size, limit to buffer size */
+	sz16 = (pFIFO->usart[usartIndex].STAT >> 16) & 0xFF;
+	if (sz16 > numData) {
+		sz16 = numData;
+	}
+	datumRead = sz16;
+
+	/* Read into buffer */
+	while (sz16 > 0) {
+		*p16 = (uint16_t) (pFIFO->usart[usartIndex].RXDATSTAT & 0xFFFF);
+		p16++;
+		sz16--;
+	}
+
+	return datumRead;
+}
+
+#if 0	/* Sorry, not yet support */
+/* Configure the USART system FIFO */
+void Chip_FIFOSPI_Configure(LPC_FIFO_T *pFIFO, int spiIndex, LPC_FIFO_CFG_T *pSPICfg)
+{
+	pFIFO->spi[spiIndex].CFG =
+		(pSPICfg->noTimeoutContWrite << 4) |
+		(pSPICfg->noTimeoutContEmpty << 5) |
+		(pSPICfg->timeoutBase << 6) |
+		(pSPICfg->timeoutValue << 12) |
+		(pSPICfg->rxThreshold << 16) |
+		(pSPICfg->txThreshold << 24);
+}
+
+/* Start a data transfer (non-blocking) */
+void Chip_FIFOSPI_StartTransfer(LPC_FIFO_T *pFIFO, LPC_FIFO_SPICTL_T *pSetupData)
+{
+	pSetupData->start = 1;
+	Chip_FIFOSPI_Transfer(pFIFO, pSetupData);
+}
+
+/* Feed a SPI data transfer (non-blocking) */
+void Chip_FIFOSPI_Transfer(LPC_FIFO_T *pFIFO, LPC_FIFO_SPICTL_T *pSetupData)
+{
+	// FIXME - not yet ready
+}
+
+#endif
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/fpu_init.c ./chip/src/fpu_init.c
--- a_tnusFF/chip/src/fpu_init.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/fpu_init.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,96 @@
+/*
+ * @brief FPU init code
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#if defined(CORE_M4)
+
+#include "cmsis.h"
+#include "stdint.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define LPC_CPACR           0xE000ED88
+
+#define SCB_MVFR0           0xE000EF40
+#define SCB_MVFR0_RESET     0x10110021
+
+#define SCB_MVFR1           0xE000EF44
+#define SCB_MVFR1_RESET     0x11000011
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Early initialization of the FPU */
+void fpuInit(void)
+{
+#if __FPU_PRESENT != 0
+	// from arm trm manual:
+	//                ; CPACR is located at address 0xE000ED88
+	//                LDR.W R0, =0xE000ED88
+	//                ; Read CPACR
+	//                LDR R1, [R0]
+	//                ; Set bits 20-23 to enable CP10 and CP11 coprocessors
+	//                ORR R1, R1, #(0xF << 20)
+	//                ; Write back the modified value to the CPACR
+	//                STR R1, [R0]
+
+	volatile uint32_t *regCpacr = (uint32_t *) LPC_CPACR;
+	volatile uint32_t *regMvfr0 = (uint32_t *) SCB_MVFR0;
+	volatile uint32_t *regMvfr1 = (uint32_t *) SCB_MVFR1;
+	volatile uint32_t Cpacr;
+	volatile uint32_t Mvfr0;
+	volatile uint32_t Mvfr1;
+	char vfpPresent = 0;
+
+	Mvfr0 = *regMvfr0;
+	Mvfr1 = *regMvfr1;
+
+	vfpPresent = ((SCB_MVFR0_RESET == Mvfr0) && (SCB_MVFR1_RESET == Mvfr1));
+
+	if (vfpPresent) {
+		Cpacr = *regCpacr;
+		Cpacr |= (0xF << 20);
+		*regCpacr = Cpacr;	// enable CP10 and CP11 for full access
+	}
+#endif /* __FPU_PRESENT != 0 */
+}
+
+#endif /* defined(CORE_M4 */
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/gpio_5410x.c ./chip/src/gpio_5410x.c
--- a_tnusFF/chip/src/gpio_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/gpio_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,108 @@
+/*
+ * @brief LPC5410X GPIO driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* GPIO initilisation function */
+void Chip_GPIO_Init(LPC_GPIO_T *pGPIO)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GPIO0);
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_GPIO1);
+	Chip_SYSCON_PeriphReset(RESET_GPIO0);
+	Chip_SYSCON_PeriphReset(RESET_GPIO1);
+}
+
+/* GPIO deinitialisation function */
+void Chip_GPIO_DeInit(LPC_GPIO_T *pGPIO)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GPIO0);
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_GPIO1);
+}
+
+/* Set GPIO direction for a single GPIO pin */
+void Chip_GPIO_WriteDirBit(LPC_GPIO_T *pGPIO, uint32_t port, uint8_t pin, bool setting)
+{
+	if (setting) {
+		pGPIO->DIR[port] |= 1UL << pin;
+	}
+	else {
+		pGPIO->DIR[port] &= ~(1UL << pin);
+	}
+}
+
+/* Set GPIO direction for a single GPIO pin */
+void Chip_GPIO_SetPinDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint8_t pin, bool output)
+{
+	if (output) {
+		Chip_GPIO_SetPinDIROutput(pGPIO, port, pin);
+	}
+	else {
+		Chip_GPIO_SetPinDIRInput(pGPIO, port, pin);
+	}
+}
+
+/* Set Direction for a GPIO port */
+void Chip_GPIO_SetDir(LPC_GPIO_T *pGPIO, uint8_t portNum, uint32_t bitValue, uint8_t out)
+{
+	if (out) {
+		pGPIO->DIR[portNum] |= bitValue;
+	}
+	else {
+		pGPIO->DIR[portNum] &= ~bitValue;
+	}
+}
+
+/* Set GPIO direction for a all selected GPIO pins to an input or output */
+void Chip_GPIO_SetPortDIR(LPC_GPIO_T *pGPIO, uint8_t port, uint32_t pinMask, bool outSet)
+{
+	if (outSet) {
+		Chip_GPIO_SetPortDIROutput(pGPIO, port, pinMask);
+	}
+	else {
+		Chip_GPIO_SetPortDIRInput(pGPIO, port, pinMask);
+	}
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/gpiogroup_5410x.c ./chip/src/gpiogroup_5410x.c
--- a_tnusFF/chip/src/gpiogroup_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/gpiogroup_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,48 @@
+/*
+ * @brief LPC5410x GPIO group driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/i2cm_5410x.c ./chip/src/i2cm_5410x.c
--- a_tnusFF/chip/src/i2cm_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/i2cm_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,226 @@
+/*
+ * @brief LPC5410x I2C master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Sets HIGH and LOW duty cycle registers */
+void Chip_I2CM_SetDutyCycle(LPC_I2C_T *pI2C, uint16_t sclH, uint16_t sclL)
+{
+	/* Limit to usable range of timing values */
+	if (sclH < 2) {
+		sclH = 2;
+	}
+	else if (sclH > 9) {
+		sclH = 9;
+	}
+	if (sclL < 2) {
+		sclL = 2;
+	}
+	else if (sclL > 9) {
+		sclL = 9;
+	}
+
+	pI2C->MSTTIME = (((sclH - 2) & 0x07) << 4) | ((sclL - 2) & 0x07);
+}
+
+/* Set up bus speed for LPC_I2C interface */
+void Chip_I2CM_SetBusSpeed(LPC_I2C_T *pI2C, uint32_t busSpeed)
+{
+	uint32_t scl;
+
+	scl = Chip_Clock_GetAsyncSyscon_ClockRate() / (Chip_I2C_GetClockDiv(pI2C) * busSpeed);
+	Chip_I2CM_SetDutyCycle(pI2C, (scl >> 1), (scl - (scl >> 1)));
+}
+
+/* Master transfer state change handler handler */
+uint32_t Chip_I2CM_XferHandler(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	uint32_t status = Chip_I2CM_GetStatus(pI2C);
+
+	if (status & I2C_STAT_MSTRARBLOSS) {
+		/* Master Lost Arbitration */
+		/* Set transfer status as Arbitration Lost */
+		xfer->status = I2CM_STATUS_ARBLOST;
+		/* Clear Status Flags */
+		Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTRARBLOSS);
+		/* Master continue */
+		if (status & I2C_STAT_MSTPENDING) {
+			pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+		}
+	}
+	else if (status & I2C_STAT_MSTSTSTPERR) {
+		/* Master Start Stop Error */
+		/* Set transfer status as Bus Error */
+		xfer->status = I2CM_STATUS_BUS_ERROR;
+		/* Clear Status Flags */
+		Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTSTSTPERR);
+
+		/* Master continue */
+		if (status & I2C_STAT_MSTPENDING) {
+			pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+		}
+	}
+	else if (status & I2C_STAT_MSTPENDING) {
+		/* Master is Pending */
+		/* Branch based on Master State Code */
+		switch (Chip_I2CM_GetMasterState(pI2C)) {
+		case I2C_STAT_MSTCODE_IDLE:	/* Master idle */
+			/* Can transition to idle between transmit and receive states */
+			if (xfer->txSz) {
+				/* Start transmit state */
+				Chip_I2CM_WriteByte(pI2C, (xfer->slaveAddr << 1));
+				pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
+			}
+			else if (xfer->rxSz) {
+				/* Start receive state with start ot repeat start */
+				Chip_I2CM_WriteByte(pI2C, (xfer->slaveAddr << 1) | 0x1);
+				pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
+			}
+			else {
+				/* No data to send, done */
+				xfer->status = I2CM_STATUS_OK;
+			}
+			break;
+
+		case I2C_STAT_MSTCODE_RXREADY:	/* Receive data is available */
+			/* Read Data up until the buffer size */
+			if (xfer->rxSz) {
+				*xfer->rxBuff = pI2C->MSTDAT;
+				xfer->rxBuff++;
+				xfer->rxSz--;
+			}
+
+			if (xfer->rxSz) {
+				pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+			}
+			else {
+				/* Last byte to receive, send stop after byte received */
+				pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE | I2C_MSTCTL_MSTSTOP;
+			}
+			break;
+
+		case I2C_STAT_MSTCODE_TXREADY:	/* Master Transmit available */
+			if (xfer->txSz) {
+				/* If Tx data available transmit data and continue */
+				pI2C->MSTDAT = (uint32_t) *xfer->txBuff;
+				pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+				xfer->txBuff++;
+				xfer->txSz--;
+			}
+			else if (xfer->rxSz == 0) {
+				pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
+			}
+			else {
+				/* Start receive state with start ot repeat start */
+				Chip_I2CM_WriteByte(pI2C, (xfer->slaveAddr << 1) | 0x1);
+				pI2C->MSTCTL = I2C_MSTCTL_MSTSTART;
+			}
+			break;
+
+		case I2C_STAT_MSTCODE_NACKADR:	/* Slave address was NACK'ed */
+			/* Set transfer status as NACK on address */
+			xfer->status = I2CM_STATUS_NAK_ADR;
+			pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
+			break;
+
+		case I2C_STAT_MSTCODE_NACKDAT:	/* Slave data was NACK'ed */
+			/* Set transfer status as NACK on data */
+			xfer->status = I2CM_STATUS_NAK_DAT;
+			pI2C->MSTCTL = I2C_MSTCTL_MSTSTOP;
+			break;
+
+		default:
+			/* Illegal I2C master state machine case. This should never happen.
+			     Try to advance state machine by continuing. */
+			xfer->status = I2CM_STATUS_ERROR;
+			pI2C->MSTCTL = I2C_MSTCTL_MSTCONTINUE;
+			break;
+		}
+	}
+	else {
+		/* Unsupported operation. This may be a call to the master handler
+		     for a wrong interrupt type. This handler should only be called when a
+		     master arbitration loss, master start/stop error, or master pending status
+		     occurs. */
+		xfer->status = I2CM_STATUS_ERROR;
+	}
+
+	return xfer->status != I2CM_STATUS_BUSY;
+}
+
+/* Transmit and Receive data in master mode */
+void Chip_I2CM_Xfer(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	/* set the transfer status as busy */
+	xfer->status = I2CM_STATUS_BUSY;
+
+	/* Reset master state machine */
+	Chip_I2CM_Disable(pI2C);
+	Chip_I2CM_Enable(pI2C);
+
+	/* Clear controller state. */
+	Chip_I2CM_ClearStatus(pI2C, I2C_STAT_MSTRARBLOSS | I2C_STAT_MSTSTSTPERR);
+
+	/* Handle transfer via initial call to handler */
+	Chip_I2CM_XferHandler(pI2C, xfer);
+}
+
+/* Transmit and Receive data in master mode */
+uint32_t Chip_I2CM_XferBlocking(LPC_I2C_T *pI2C, I2CM_XFER_T *xfer)
+{
+	/* start transfer */
+	Chip_I2CM_Xfer(pI2C, xfer);
+
+	while (xfer->status == I2CM_STATUS_BUSY) {
+		/* wait for status change interrupt */
+		while (!Chip_I2CM_IsMasterPending(pI2C)) {}
+		/* call state change handler */
+		Chip_I2CM_XferHandler(pI2C, xfer);
+	}
+
+	return xfer->status == I2CM_STATUS_OK;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/i2cs_5410x.c ./chip/src/i2cs_5410x.c
--- a_tnusFF/chip/src/i2cs_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/i2cs_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,104 @@
+/*
+ * @brief LPC5410x I2C slave driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Slave transfer state change handler */
+uint32_t Chip_I2CS_XferHandler(LPC_I2C_T *pI2C, const I2CS_XFER_T *xfers)
+{
+	uint32_t done = 0, xferDone = 0;
+
+	uint8_t data;
+	uint32_t state;
+
+	/* Transfer complete? */
+	if ((Chip_I2C_GetPendingInt(pI2C) & I2C_INTENSET_SLVDESEL) != 0) {
+		Chip_I2CS_ClearStatus(pI2C, I2C_STAT_SLVDESEL);
+		xfers->slaveDone();
+		xferDone = 1;
+	}
+	else {
+		/* Determine the current I2C slave state */
+		state = Chip_I2CS_GetSlaveState(pI2C);
+
+		switch (state) {
+		case I2C_STAT_SLVCODE_ADDR:		/* Slave address received */
+			/* Get slave address that needs servicing */
+			data = Chip_I2CS_GetSlaveAddr(pI2C, Chip_I2CS_GetSlaveMatchIndex(pI2C));
+
+			/* Call address callback */
+			xfers->slaveStart(data);
+			break;
+
+		case I2C_STAT_SLVCODE_RX:		/* Data byte received, not used with DMA */
+			/* Get received data */
+			data = Chip_I2CS_ReadByte(pI2C);
+			done = xfers->slaveRecv(data);
+			break;
+
+		case I2C_STAT_SLVCODE_TX:		/* Get byte that needs to be sent, or start DMA */
+			/* Get data to send */
+			done = xfers->slaveSend(&data);
+			if (!((done == I2C_SLVCTL_SLVNACK) || (done == I2C_SLVCTL_SLVDMA))) {
+				Chip_I2CS_WriteByte(pI2C, data);
+			}
+			break;
+		}
+
+		if (done == I2C_SLVCTL_SLVNACK) {
+			Chip_I2CS_SlaveNACK(pI2C);
+		}
+		else if (done == I2C_SLVCTL_SLVDMA) {
+			Chip_I2CS_SlaveEnableDMA(pI2C);
+		}
+		else {
+			Chip_I2CS_SlaveContinue(pI2C);
+		}
+	}
+
+	return xferDone;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/iap.c ./chip/src/iap.c
--- a_tnusFF/chip/src/iap.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/iap.c	2016-10-22 23:23:55.480850238 -0300
@@ -0,0 +1,175 @@
+/*
+ * @brief Common FLASH support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2013
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Prepare sector for write operation */
+uint8_t Chip_IAP_PreSectorForReadWrite(uint32_t strSector, uint32_t endSector)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_PREWRRITE_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Copy RAM to flash */
+uint8_t Chip_IAP_CopyRamToFlash(uint32_t dstAdd, uint32_t *srcAdd, uint32_t byteswrt)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_WRISECTOR_CMD;
+	command[1] = dstAdd;
+	command[2] = (uint32_t) srcAdd;
+	command[3] = byteswrt;
+	command[4] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Erase sector */
+uint8_t Chip_IAP_EraseSector(uint32_t strSector, uint32_t endSector)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_ERSSECTOR_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	command[3] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Blank check sector */
+uint8_t Chip_IAP_BlankCheckSector(uint32_t strSector, uint32_t endSector)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_BLANK_CHECK_SECTOR_CMD;
+	command[1] = strSector;
+	command[2] = endSector;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Read part identification number */
+uint32_t Chip_IAP_ReadPID()
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_REPID_CMD;
+	iap_entry(command, result);
+
+	return result[1];
+}
+
+/* Read boot code version number */
+uint8_t Chip_IAP_ReadBootCode()
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_READ_BOOT_CODE_CMD;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* IAP compare */
+uint8_t Chip_IAP_Compare(uint32_t dstAdd, uint32_t srcAdd, uint32_t bytescmp)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_COMPARE_CMD;
+	command[1] = dstAdd;
+	command[2] = srcAdd;
+	command[3] = bytescmp;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Reinvoke ISP */
+uint8_t Chip_IAP_ReinvokeISP()
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_REINVOKE_ISP_CMD;
+	iap_entry(command, result);
+
+	return result[0];
+}
+
+/* Read the unique ID */
+uint32_t Chip_IAP_ReadUID()
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_READ_UID_CMD;
+	iap_entry(command, result);
+
+	return result[1];
+}
+
+/* Erase page */
+uint8_t Chip_IAP_ErasePage(uint32_t strPage, uint32_t endPage)
+{
+	unsigned int command[5], result[4];
+
+	command[0] = IAP_ERASE_PAGE_CMD;
+	command[1] = strPage;
+	command[2] = endPage;
+	command[3] = SystemCoreClock / 1000;
+	iap_entry(command, result);
+
+	return result[0];
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/iocon_5410x.c ./chip/src/iocon_5410x.c
--- a_tnusFF/chip/src/iocon_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/iocon_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,58 @@
+/*
+ * @brief LPC5410X IOCON driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set all I/O Control pin muxing */
+void Chip_IOCON_SetPinMuxing(LPC_IOCON_T *pIOCON, const PINMUX_GRP_T *pinArray, uint32_t arrayLength)
+{
+	uint32_t ix;
+
+	for (ix = 0; ix < arrayLength; ix++ ) {
+		Chip_IOCON_PinMuxSet(pIOCON, pinArray[ix].port, pinArray[ix].pin, pinArray[ix].modefunc);
+	}
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/pinint_5410x.c ./chip/src/pinint_5410x.c
--- a_tnusFF/chip/src/pinint_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/pinint_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,79 @@
+/*
+ * @brief LPC5410X Pin Interrupt and Pattern Match Registers and driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set source for pattern match engine */
+void Chip_PININT_SetPatternMatchSrc(LPC_PIN_INT_T *pPININT,
+									Chip_PININT_SELECT_T channelNum,
+									Chip_PININT_BITSLICE_T sliceNum)
+{
+	uint32_t pmsrc_reg;
+
+	/* Source source for pattern matching */
+	pmsrc_reg = pPININT->PMSRC & ~(PININT_SRC_BITSOURCE_MASK << (PININT_SRC_BITSOURCE_START + (sliceNum * 3)));
+	pPININT->PMSRC = pmsrc_reg | (channelNum << (PININT_SRC_BITSOURCE_START + (sliceNum * 3)));
+}
+
+/* Configure Pattern match engine */
+void Chip_PININT_SetPatternMatchConfig(LPC_PIN_INT_T *pPININT, Chip_PININT_BITSLICE_T sliceNum,
+									   Chip_PININT_BITSLICE_CFG_T slice_cfg, bool end_point)
+{
+	uint32_t pmcfg_reg;
+
+	/* Configure bit slice configuration */
+	pmcfg_reg = pPININT->PMCFG & ~(PININT_SRC_BITCFG_MASK << (PININT_SRC_BITCFG_START + (sliceNum * 3)));
+	pPININT->PMCFG = pmcfg_reg | (slice_cfg << (PININT_SRC_BITCFG_START + (sliceNum * 3)));
+
+	/* If end point is true, enable the bits */
+	if (end_point == true) {
+		/* By default slice 7 is final component */
+		if (sliceNum != PININTBITSLICE7) {
+			pPININT->PMCFG |= (0x1 << sliceNum);
+		}
+	}
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/pll_5410x.c ./chip/src/pll_5410x.c
--- a_tnusFF/chip/src/pll_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/pll_5410x.c	2016-10-22 23:17:43.580840278 -0300
@@ -0,0 +1,884 @@
+/*
+ * @brief LPC5410X PLL driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define NVALMAX                     (0x100)
+#define PVALMAX                     (0x20)
+#define MVALMAX                     (0x8000)
+
+/* SYS PLL related bit fields */
+#define SYS_PLL_SELR(d)             (((d) & 0xf) << 0)		/*!< Bandwidth select R value */
+#define SYS_PLL_SELI(d)             (((d) & 0x3f) << 4)		/*!< Bandwidth select I value */
+#define SYS_PLL_SELP(d)             (((d) & 0x1f) << 10)	/*!< Bandwidth select P value */
+#define SYS_PLL_BYPASS              (1 << 15)				/*!< Enable PLL bypass */
+#define SYS_PLL_BYPASSCCODIV2       (1 << 16)				/*!< Enable bypass of extra divider by 2 */
+#define SYS_PLL_UPLIMOFF            (1 << 17)				/*!< Enable spread spectrum/fractional mode */
+#define SYS_PLL_BANDSEL             (1 << 18)				/*!< Enable MDEC control */
+#define SYS_PLL_DIRECTI             (1 << 19)				/*!< PLL0 direct input enable */
+#define SYS_PLL_DIRECTO             (1 << 20)				/*!< PLL0 direct output enable */
+
+// #define FRAC_BITS_SELI			(8)		// For retaining fractions in divisions
+#define PLL_SSCG0_MDEC_VAL_P    (0)			// MDEC is in bits  16 downto 0
+#define PLL_SSCG0_MDEC_VAL_M    (0x1FFFFUL << PLL_SSCG0_MDEC_VAL_P)		// NDEC is in bits  9 downto 0
+#define PLL_NDEC_VAL_P          (0)			// NDEC is in bits  9:0
+#define PLL_NDEC_VAL_M          (0x3FFUL << PLL_NDEC_VAL_P)
+#define PLL_PDEC_VAL_P          (0)			// PDEC is in bits 6:0
+#define PLL_PDEC_VAL_M          (0x3FFUL << PLL_PDEC_VAL_P)
+
+#define PLL_MIN_CCO_FREQ_MHZ    (75000000)
+#define PLL_MAX_CCO_FREQ_MHZ    (150000000)
+#define PLL_LOWER_IN_LIMIT      (4000)				/*!< Minimum PLL input rate */
+#define PLL_MIN_IN_SSMODE       (2000000)
+#define PLL_MAX_IN_SSMODE       (4000000)
+
+// Middle of the range values for spread-spectrum
+#define PLL_SSCG_MF_FREQ_VALUE                               4
+#define PLL_SSCG_MC_COMP_VALUE                               2
+#define PLL_SSCG_MR_DEPTH_VALUE                              4
+#define PLL_SSCG_DITHER_VALUE                                0
+
+// pll SYSPLLCTRL Bits
+#define SYSCON_SYSPLLCTRL_SELR_P                                0
+#define SYSCON_SYSPLLCTRL_SELR_M                                (0xFUL << SYSCON_SYSPLLCTRL_SELR_P)
+#define SYSCON_SYSPLLCTRL_SELI_P                                4
+#define SYSCON_SYSPLLCTRL_SELI_M                                (0x3FUL << SYSCON_SYSPLLCTRL_SELI_P)
+#define SYSCON_SYSPLLCTRL_SELP_P                                10
+#define SYSCON_SYSPLLCTRL_SELP_M                                (0x1FUL << SYSCON_SYSPLLCTRL_SELP_P)
+#define SYSCON_SYSPLLCTRL_BYPASS_P                          15		// sys_pll150_ctrl
+#define SYSCON_SYSPLLCTRL_BYPASS                                (1UL << SYSCON_SYSPLLCTRL_BYPASS_P)
+#define SYSCON_SYSPLLCTRL_BYPASS_FBDIV2_P               16
+#define SYSCON_SYSPLLCTRL_BYPASS_FBDIV2                 (1UL << SYSCON_SYSPLLCTRL_BYPASS_FBDIV2_P)
+#define SYSCON_SYSPLLCTRL_UPLIMOFF_P                        17
+#define SYSCON_SYSPLLCTRL_UPLIMOFF                          (1UL << SYSCON_SYSPLLCTRL_UPLIMOFF_P)
+#define SYSCON_SYSPLLCTRL_BANDSEL_SSCGREG_N_P       18
+#define SYSCON_SYSPLLCTRL_BANDSEL_SSCGREG_N         (1UL << SYSCON_SYSPLLCTRL_BANDSEL_SSCGREG_N_P)
+#define SYSCON_SYSPLLCTRL_DIRECTI_P                         19
+#define SYSCON_SYSPLLCTRL_DIRECTI                               (1UL << SYSCON_SYSPLLCTRL_DIRECTI_P)
+#define SYSCON_SYSPLLCTRL_DIRECTO_P                         20
+#define SYSCON_SYSPLLCTRL_DIRECTO                               (1UL << SYSCON_SYSPLLCTRL_DIRECTO_P)
+
+#define SYSCON_SYSPLLSTAT_LOCK_P                                0
+#define SYSCON_SYSPLLSTAT_LOCK                              (1UL << SYSCON_SYSPLLSTAT_LOCK_P)
+
+#define PLL_CTRL_BYPASS_P                                                  15		// sys_pll150_ctrl
+#define PLL_CTRL_BYPASS_FBDIV2_P                                           16
+#define PLL_CTRL_UPLIMOFF_P                                                17
+#define PLL_CTRL_BANDSEL_SSCGREG_N_P                                       18
+#define PLL_CTRL_DIRECTI_P                                                 19
+#define PLL_CTRL_DIRECTO_P                                                 20
+
+#define PLL_CTRL_BYPASS                                                    (1 << PLL_CTRL_BYPASS_P)
+#define PLL_CTRL_DIRECTI                                                   (1 << PLL_CTRL_DIRECTI_P)
+#define PLL_CTRL_DIRECTO                                                   (1 << PLL_CTRL_DIRECTO_P)
+#define PLL_CTRL_UPLIMOFF                                                  (1 << PLL_CTRL_UPLIMOFF_P)
+#define PLL_CTRL_BANDSEL_SSCGREG_N                                         (1 << PLL_CTRL_BANDSEL_SSCGREG_N_P)
+#define PLL_CTRL_BYPASS_FBDIV2                                             (1 << PLL_CTRL_BYPASS_FBDIV2_P)
+
+// SSCG control[0]
+// #define PLL_SSCG0_MDEC_VAL_P                                                0    // MDEC is in bits  16 downto 0
+#define PLL_SSCG0_MREQ_P                                                   17
+#define PLL_SSCG0_SEL_EXT_SSCG_N_P                                         18
+#define PLL_SSCG0_SEL_EXT_SSCG_N                                           (1 << PLL_SSCG0_SEL_EXT_SSCG_N_P)
+#define PLL_SSCG0_MREQ                                                     (1 << PLL_SSCG0_MREQ_P)
+
+// SSCG control[1]
+#define PLL_SSCG1_MD_REQ_P                                                 19
+#define PLL_SSCG1_MOD_PD_SSCGCLK_N_P                                       28
+#define PLL_SSCG1_DITHER_P                                                 29
+#define PLL_SSCG1_MOD_PD_SSCGCLK_N                                         (1 << PLL_SSCG1_MOD_PD_SSCGCLK_N_P)
+#define PLL_SSCG1_DITHER                                                   (1 << PLL_SSCG1_DITHER_P)
+#define PLL_SSCG1_MD_REQ                                                   (1 << PLL_SSCG1_MD_REQ_P)
+
+// PLL NDEC reg
+#define PLL_NDEC_VAL_SET(value)                     (((unsigned long) (value) << PLL_NDEC_VAL_P) & PLL_NDEC_VAL_M)
+#define PLL_NDEC_NREQ_P                                     10
+#define PLL_NDEC_NREQ                                           (1 << PLL_NDEC_NREQ_P)
+
+// PLL PDEC reg
+#define PLL_PDEC_VAL_SET(value)                     (((unsigned long) (value) << PLL_PDEC_VAL_P) & PLL_PDEC_VAL_M)
+#define PLL_PDEC_PREQ_P                                     7
+#define PLL_PDEC_PREQ                                           (1 << PLL_PDEC_PREQ_P)
+
+// SSCG control[0]
+#define PLL_SSCG0_MDEC_VAL_SET(value)        (((unsigned long) (value) << PLL_SSCG0_MDEC_VAL_P) & PLL_SSCG0_MDEC_VAL_M)
+#define PLL_SSCG0_MREQ_P                     17
+#define PLL_SSCG0_MREQ                       (1 << PLL_SSCG0_MREQ_P)
+#define PLL_SSCG0_SEL_EXT_SSCG_N_P           18
+#define PLL_SSCG0_SEL_EXT_SSCG_N             (1 << PLL_SSCG0_SEL_EXT_SSCG_N_P)
+
+// SSCG control[1]
+#define PLL_SSCG1_MD_FRACT_P                                        0
+#define PLL_SSCG1_MD_INT_P                                          11
+#define PLL_SSCG1_MF_P                                              20
+#define PLL_SSCG1_MC_P                                              26
+#define PLL_SSCG1_MR_P                                              23
+
+#define PLL_SSCG1_MD_FRACT_M                                        (0x7FFUL << PLL_SSCG1_MD_FRACT_P)
+#define PLL_SSCG1_MD_INT_M                                          (0xFFUL << PLL_SSCG1_MD_INT_P)
+#define PLL_SSCG1_MF_M                                              (0x7UL << PLL_SSCG1_MF_P)
+#define PLL_SSCG1_MC_M                                              (0x3UL << PLL_SSCG1_MC_P)
+#define PLL_SSCG1_MR_M                                              (0x7UL << PLL_SSCG1_MR_P)
+
+#define PLL_SSCG1_MD_FRACT_SET(value)                               (((unsigned long) (value) << \
+																	  PLL_SSCG1_MD_FRACT_P) & PLL_SSCG1_MD_FRACT_M)
+#define PLL_SSCG1_MD_INT_SET(value)                                 (((unsigned long) (value) << \
+																	  PLL_SSCG1_MD_INT_P)   & PLL_SSCG1_MD_INT_M)
+
+// Middle of the range values for spread-spectrum
+#define PLL0_SSCG_MF_FREQ_VALUE     4
+#define PLL0_SSCG_MC_COMP_VALUE     2
+#define PLL0_SSCG_MR_DEPTH_VALUE    4
+#define PLL0_SSCG_DITHER_VALUE      0
+
+#define PLL_MAX_N_DIV       0x100
+
+/* Saved value of PLL output rate, computed whenever needed to save run-time
+   computation on each call to retrive the PLL rate. */
+static uint32_t curPllRate;
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Find encoded NDEC value for raw N value, max N = NVALMAX */
+static uint32_t pllEncodeN(uint32_t N)
+{
+	uint32_t x, i;
+
+	/* Find NDec */
+	switch (N) {
+	case 0:
+		x = 0x3FF;
+		break;
+
+	case 1:
+		x = 0x302;
+		break;
+
+	case 2:
+		x = 0x202;
+		break;
+
+	default:
+		x = 0x080;
+		for (i = N; i <= NVALMAX; i++) {
+			x = (((x ^ (x >> 2) ^ (x >> 3) ^ (x >> 4)) & 1) << 7) | ((x >> 1) & 0x7F);
+		}
+		break;
+	}
+
+	return x & (PLL_NDEC_VAL_M >> PLL_NDEC_VAL_P);
+}
+
+/* Find decoded N value for raw NDEC value */
+static uint32_t pllDecodeN(uint32_t NDEC)
+{
+	uint32_t n, x, i;
+
+	/* Find NDec */
+	switch (NDEC) {
+	case 0x3FF:
+		n = 0;
+		break;
+
+	case 0x302:
+		n = 1;
+		break;
+
+	case 0x202:
+		n = 2;
+		break;
+
+	default:
+		x = 0x080;
+		n = 0xFFFFFFFF;
+		for (i = NVALMAX; ((i >= 3) && (n == 0xFFFFFFFF)); i--) {
+			x = (((x ^ (x >> 2) ^ (x >> 3) ^ (x >> 4)) & 1) << 7) | ((x >> 1) & 0x7F);
+			if ((x & (PLL_NDEC_VAL_M >> PLL_NDEC_VAL_P)) == NDEC) {
+				/* Decoded value of NDEC */
+				n = i;
+			}
+		}
+		break;
+	}
+
+	return n;
+}
+
+/* Find encoded PDEC value for raw P value, max P = PVALMAX */
+static uint32_t pllEncodeP(uint32_t P)
+{
+	uint32_t x, i;
+
+	/* Find PDec */
+	switch (P) {
+	case 0:
+		x = 0xFF;
+		break;
+
+	case 1:
+		x = 0x62;
+		break;
+
+	case 2:
+		x = 0x42;
+		break;
+
+	default:
+		x = 0x10;
+		for (i = P; i <= PVALMAX; i++) {
+			x = (((x ^ (x >> 2)) & 1) << 4) | ((x >> 1) & 0xF);
+		}
+		break;
+	}
+
+	return x & (PLL_PDEC_VAL_M >> PLL_PDEC_VAL_P);
+}
+
+/* Find decoded P value for raw PDEC value */
+static uint32_t pllDecodeP(uint32_t PDEC)
+{
+	uint32_t p, x, i;
+
+	/* Find PDec */
+	switch (PDEC) {
+	case 0xFF:
+		p = 0;
+		break;
+
+	case 0x62:
+		p = 1;
+		break;
+
+	case 0x42:
+		p = 2;
+		break;
+
+	default:
+		x = 0x10;
+		p = 0xFFFFFFFF;
+		for (i = PVALMAX; ((i >= 3) && (p == 0xFFFFFFFF)); i--) {
+			x = (((x ^ (x >> 2)) & 1) << 4) | ((x >> 1) & 0xF);
+			if ((x & (PLL_PDEC_VAL_M >> PLL_PDEC_VAL_P)) == PDEC) {
+				/* Decoded value of PDEC */
+				p = i;
+			}
+		}
+		break;
+	}
+
+	return p;
+}
+
+/* Find encoded MDEC value for raw M value, max M = MVALMAX */
+static uint32_t pllEncodeM(uint32_t M)
+{
+	uint32_t i, x;
+
+	/* Find MDec */
+	switch (M) {
+	case 0:
+		x = 0x1FFFF;
+		break;
+
+	case 1:
+		x = 0x18003;
+		break;
+
+	case 2:
+		x = 0x10003;
+		break;
+
+	default:
+		x = 0x04000;
+		for (i = M; i <= MVALMAX; i++) {
+			x = (((x ^ (x >> 1)) & 1) << 14) | ((x >> 1) & 0x3FFF);
+		}
+		break;
+	}
+
+	return x & (PLL_SSCG0_MDEC_VAL_M >> PLL_SSCG0_MDEC_VAL_P);
+}
+
+/* Find decoded M value for raw MDEC value */
+static uint32_t pllDecodeM(uint32_t MDEC)
+{
+	uint32_t m, i, x;
+
+	/* Find MDec */
+	switch (MDEC) {
+	case 0x1FFFF:
+		m = 0;
+		break;
+
+	case 0x18003:
+		m = 1;
+		break;
+
+	case 0x10003:
+		m = 2;
+		break;
+
+	default:
+		x = 0x04000;
+		m = 0xFFFFFFFF;
+		for (i = MVALMAX; ((i >= 3) && (m == 0xFFFFFFFF)); i--) {
+			x = (((x ^ (x >> 1)) & 1) << 14) | ((x >> 1) & 0x3FFF);
+			if ((x & (PLL_SSCG0_MDEC_VAL_M >> PLL_SSCG0_MDEC_VAL_P)) == MDEC) {
+				/* Decoded value of MDEC */
+				m = i;
+			}
+		}
+		break;
+	}
+
+	return m;
+}
+
+/* Find SELP, SELI, and SELR values for raw M value, max M = MVALMAX */
+static void pllFindSel(uint32_t M, bool bypassFBDIV2, uint32_t *pSelP, uint32_t *pSelI, uint32_t *pSelR)
+{
+	/* If the bypass divider is disabled, the multiplier is doubled */
+	if (bypassFBDIV2 == true) {
+		M *= 2;
+	}
+
+	/* bandwidth: compute selP from Multiplier */
+	if (M < 60) {
+		*pSelP = (M >> 1) + 1;
+	}
+	else {
+		*pSelP = PVALMAX - 1;
+	}
+
+	/* bandwidth: compute selI from Multiplier */
+	if (M > 16384) {
+		*pSelI = 1;
+	}
+	else if (M > 8192) {
+		*pSelI = 2;
+	}
+	else if (M > 2048) {
+		*pSelI = 4;
+	}
+	else if (M >= 501) {
+		*pSelI = 8;
+	}
+	else if (M >= 60) {
+		*pSelI = 4 * (1024 / (M + 9));
+	}
+	else {
+		*pSelI = (M & 0x3C) + 4;
+	}
+
+	if (*pSelI > (SYSCON_SYSPLLCTRL_SELI_M >> SYSCON_SYSPLLCTRL_SELI_P)) {
+		*pSelI = (SYSCON_SYSPLLCTRL_SELI_M >> SYSCON_SYSPLLCTRL_SELI_P);
+	}
+
+	*pSelR = 0;
+}
+
+/* Get predivider (N) from PLL NDEC setting */
+uint32_t findPllPreDiv(uint32_t ctrlReg, uint32_t nDecReg)
+{
+	uint32_t preDiv = 1;
+
+	/* Direct input is not used? */
+	if ((ctrlReg & SYSCON_SYSPLLCTRL_DIRECTI) == 0) {
+		/* Decode NDEC value to get (N) pre divider */
+		preDiv = pllDecodeN(nDecReg & 0x3FF);
+		if (preDiv == 0) {
+			preDiv = 1;
+		}
+	}
+
+	/* Adjusted by 1, directi is used to bypass */
+	return preDiv;
+}
+
+/* Get postdivider (P) from PLL PDEC setting */
+uint32_t findPllPostDiv(uint32_t ctrlReg, uint32_t pDecReg)
+{
+	uint32_t postDiv = 1;
+
+	/* Direct input is not used? */
+	if ((ctrlReg & SYS_PLL_DIRECTO) == 0) {
+		/* Decode PDEC value to get (P) post divider */
+		postDiv = 2 * pllDecodeP(pDecReg & 0x7F);
+		if (postDiv == 0) {
+			postDiv = 2;
+		}
+	}
+
+	/* Adjusted by 1, directo is used to bypass */
+	return postDiv;
+}
+
+/* Get multiplier (M) from PLL MDEC and BYPASS_FBDIV2 settings */
+uint32_t findPllMMult(uint32_t ctrlReg, uint32_t mDecReg)
+{
+	uint32_t mMult = 1;
+
+	/* Decode MDEC value to get (M) multiplier */
+	mMult = pllDecodeM(mDecReg & 0x1FFFF);
+
+	/* Extra multiply by 2 needed? */
+	if ((ctrlReg & SYSCON_SYSPLLCTRL_BYPASS_FBDIV2) == 0) {
+		mMult *= 2;
+	}
+
+	if (mMult == 0) {
+		mMult = 1;
+	}
+
+	return mMult;
+}
+
+static uint32_t FindGreatestCommonDivisor(uint32_t m, uint32_t n)
+{
+	uint32_t tmp;
+
+	while (n != 0) {
+		tmp = n;
+		n = m % n;
+		m = tmp;
+	}
+
+	return m;
+}
+
+/* Set PLL output based on desired output rate */
+static PLL_ERROR_T Chip_Clock_GetPllConfig(uint32_t finHz, uint32_t foutHz, PLL_SETUP_T *pSetup,
+										   bool useFeedbackDiv2, bool useSS)
+{
+	uint32_t nDivOutHz, fccoHz, multFccoDiv;
+	uint32_t pllPreDivider, pllMultiplier, pllBypassFBDIV2, pllPostDivider;
+	uint32_t pllDirectInput, pllDirectOutput;
+	uint32_t pllSelP, pllSelI, pllSelR, bandsel, uplimoff;
+
+	/* Baseline parameters (no input or output dividers) */
+	pllPreDivider = 1;	/* 1 implies pre-divider will be disabled */
+	pllPostDivider = 0;	/* 0 implies post-divider will be disabled */
+	pllDirectOutput = 1;
+	if (useFeedbackDiv2) {
+		/* Using feedback divider for M, so disable bypass */
+		pllBypassFBDIV2 = 0;
+	}
+	else {
+		pllBypassFBDIV2 = 1;
+	}
+	multFccoDiv = (2 - pllBypassFBDIV2);
+
+	/* Verify output rate parameter */
+	if (foutHz > PLL_MAX_CCO_FREQ_MHZ) {
+		/* Maximum PLL output with post divider=1 cannot go above this frequency */
+		return PLL_ERROR_OUTPUT_TOO_HIGH;
+	}
+	if (foutHz < (PLL_MIN_CCO_FREQ_MHZ / (PVALMAX << 1))) {
+		/* Minmum PLL output with maximum post divider cannot go below this frequency */
+		return PLL_ERROR_OUTPUT_TOO_LOW;
+	}
+
+	/* If using SS mode, input clock needs to be between 2MHz and 4MHz */
+	if (useSS) {
+		/* Verify input rate parameter */
+		if (finHz < PLL_MIN_IN_SSMODE) {
+			/* Input clock into the PLL cannot be lower than this */
+			return PLL_ERROR_INPUT_TOO_LOW;
+		}
+
+		/* PLL input in SS mode must be under 4MHz */
+		pllPreDivider = finHz / ((PLL_MIN_IN_SSMODE + PLL_MAX_IN_SSMODE) / 2);
+		if (pllPreDivider > NVALMAX) {
+			return PLL_ERROR_INPUT_TOO_HIGH;
+		}
+	}
+	else {
+		/* Verify input rate parameter */
+		if (finHz < PLL_LOWER_IN_LIMIT) {
+			/* Input clock into the PLL cannot be lower than this */
+			return PLL_ERROR_INPUT_TOO_LOW;
+		}
+	}
+
+	/* Find the optimal CCO frequency for the output and input that
+	   will keep it inside the PLL CCO range. This may require
+	   tweaking the post-divider for the PLL. */
+	fccoHz = foutHz;
+	while (fccoHz < PLL_MIN_CCO_FREQ_MHZ) {
+		/* CCO output is less than minimum CCO range, so the CCO output
+		   needs to be bumped up and the post-divider is used to bring
+		   the PLL output back down. */
+		pllPostDivider++;
+		if (pllPostDivider > PVALMAX) {
+			return PLL_ERROR_OUTSIDE_INTLIMIT;
+		}
+
+		/* Target CCO goes up, PLL output goes down */
+		fccoHz = foutHz * (pllPostDivider * 2);
+		pllDirectOutput = 0;
+	}
+
+	/* Determine if a pre-divider is needed to get the best frequency */
+	if ((finHz > PLL_LOWER_IN_LIMIT) && (fccoHz >= finHz) && (useSS == false)) {
+		uint32_t a = FindGreatestCommonDivisor(fccoHz, (multFccoDiv * finHz));
+
+		if (a > 20000) {
+			a = (multFccoDiv * finHz) / a;
+			if ((a != 0) && (a < PLL_MAX_N_DIV)) {
+				pllPreDivider = a;
+			}
+		}
+	}
+
+	/* Bypass pre-divider hardware if pre-divider is 1 */
+	if (pllPreDivider > 1) {
+		pllDirectInput = 0;
+	}
+	else {
+		pllDirectInput = 1;
+	}
+
+	/* Determine PLL multipler */
+	nDivOutHz = (finHz / pllPreDivider);
+	pllMultiplier = (fccoHz / nDivOutHz) / multFccoDiv;
+
+	/* Find optimal values for filter */
+	if (useSS == false) {
+		/* Will bumping up M by 1 get us closer to the desired CCO frequency? */
+		if ((nDivOutHz * ((multFccoDiv * pllMultiplier * 2) + 1)) < (fccoHz * 2)) {
+			pllMultiplier++;
+		}
+
+		/* Setup filtering */
+		pllFindSel(pllMultiplier, pllBypassFBDIV2, &pllSelP, &pllSelI, &pllSelR);
+		bandsel = 1;
+		uplimoff = 0;
+
+		/* Get encoded value for M (mult) and use manual filter, disable SS mode */
+		pSetup->SYSPLLSSCTRL[0] = (PLL_SSCG0_MDEC_VAL_SET(pllEncodeM(pllMultiplier)) |
+								   (1 << PLL_SSCG0_SEL_EXT_SSCG_N_P));
+
+		/* Power down SSC, not used */
+		pSetup->SYSPLLSSCTRL[1] = PLL_SSCG1_MOD_PD_SSCGCLK_N;
+	}
+	else {
+		uint64_t fc;
+
+		/* Filtering will be handled by SSC */
+		pllSelR = pllSelI = pllSelP = 0;
+		bandsel = 0;
+		uplimoff = 1;
+
+		/* The PLL multiplier will get very close and slightly under the
+		   desired target frequency. A small fractional component can be
+		   added to fine tune the frequency upwards to the target. */
+		fc = ((uint64_t) (fccoHz % (multFccoDiv * nDivOutHz)) << 11) / (multFccoDiv * nDivOutHz);
+
+		/* MDEC set by SSC */
+		pSetup->SYSPLLSSCTRL[0] = 0;
+
+		/* Set multiplier */
+		pSetup->SYSPLLSSCTRL[1] = PLL_SSCG1_MD_INT_SET(pllMultiplier) |
+								  PLL_SSCG1_MD_FRACT_SET((uint32_t) fc);
+	}
+
+	/* Get encoded values for N (prediv) and P (postdiv) */
+	pSetup->SYSPLLNDEC = PLL_NDEC_VAL_SET(pllEncodeN(pllPreDivider));
+	pSetup->SYSPLLPDEC = PLL_PDEC_VAL_SET(pllEncodeP(pllPostDivider));
+
+	/* PLL control */
+	pSetup->SYSPLLCTRL =
+		(pllSelR << SYSCON_SYSPLLCTRL_SELR_P) |					/* Filter coefficient */
+		(pllSelI << SYSCON_SYSPLLCTRL_SELI_P) |					/* Filter coefficient */
+		(pllSelP << SYSCON_SYSPLLCTRL_SELP_P) |					/* Filter coefficient */
+		(0 << SYSCON_SYSPLLCTRL_BYPASS_P) |						/* PLL bypass mode disabled */
+		(pllBypassFBDIV2 << SYSCON_SYSPLLCTRL_BYPASS_FBDIV2_P) |	/* Extra M / 2 divider? */
+		(uplimoff << SYSCON_SYSPLLCTRL_UPLIMOFF_P) |			/* SS/fractional mode disabled */
+		(bandsel << SYSCON_SYSPLLCTRL_BANDSEL_SSCGREG_N_P) |	/* Manual bandwidth selection enabled */
+		(pllDirectInput << SYSCON_SYSPLLCTRL_DIRECTI_P) |		/* Bypass pre-divider? */
+		(pllDirectOutput << SYSCON_SYSPLLCTRL_DIRECTO_P);		/* Bypass post-divider? */
+
+	return PLL_ERROR_SUCCESS;
+}
+
+/* Update local PLL rate variable */
+static void Chip_Clock_GetSystemPLLOutFromSetupUpdate(PLL_SETUP_T *pSetup)
+{
+	curPllRate = Chip_Clock_GetSystemPLLOutFromSetup(pSetup);
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Return System PLL input clock rate */
+uint32_t Chip_Clock_GetSystemPLLInClockRate(void)
+{
+	uint32_t clkRate = 0;
+
+	switch ((CHIP_SYSCON_PLLCLKSRC_T) (LPC_SYSCON->SYSPLLCLKSEL & 0x3)) {
+	case SYSCON_PLLCLKSRC_IRC:
+		clkRate = Chip_Clock_GetIntOscRate();
+		break;
+
+	case SYSCON_PLLCLKSRC_CLKIN:
+		clkRate = Chip_Clock_GetExtClockInRate();
+		break;
+
+	case SYSCON_PLLCLKSRC_WDTOSC:
+		clkRate = Chip_Clock_GetWDTOSCRate();
+		break;
+
+	case SYSCON_PLLCLKSRC_RTC:
+		clkRate = Chip_Clock_GetRTCOscRate();
+		break;
+	}
+
+	return clkRate;
+}
+
+/* Return System PLL output clock rate from setup structure */
+uint32_t Chip_Clock_GetSystemPLLOutFromSetup(PLL_SETUP_T *pSetup)
+{
+	uint32_t prediv, postdiv, mMult, inPllRate;
+	uint64_t workRate;
+
+	inPllRate = Chip_Clock_GetSystemPLLInClockRate();
+	if ((pSetup->SYSPLLCTRL & SYSCON_SYSPLLCTRL_BYPASS_P) == 0) {
+		/* PLL is not in bypass mode, get pre-divider, post-divider, and M divider */
+		prediv = findPllPreDiv(pSetup->SYSPLLCTRL, pSetup->SYSPLLNDEC);
+		postdiv = findPllPostDiv(pSetup->SYSPLLCTRL, pSetup->SYSPLLPDEC);
+
+		/* Adjust input clock */
+		inPllRate = inPllRate / prediv;
+
+		/* If using the SS, use the multiplier */
+		if (pSetup->SYSPLLSSCTRL[1] & PLL_SSCG1_MOD_PD_SSCGCLK_N) {
+			/* MDEC used for rate */
+			mMult = findPllMMult(pSetup->SYSPLLCTRL, pSetup->SYSPLLSSCTRL[0]);
+			workRate = (uint64_t) inPllRate * (uint64_t) mMult;
+		}
+		else {
+			uint64_t fract;
+
+			/* SS multipler used for rate */
+			mMult = (pSetup->SYSPLLSSCTRL[1] & PLL_SSCG1_MD_INT_M) >> PLL_SSCG1_MD_INT_P;
+			workRate = (uint64_t) inPllRate * (uint64_t) mMult;
+
+			/* Adjust by fractional */
+			fract = (uint64_t) (pSetup->SYSPLLSSCTRL[1] & PLL_SSCG1_MD_FRACT_M) >> PLL_SSCG1_MD_FRACT_P;
+			workRate = workRate + ((inPllRate * fract) / 0x7FF);
+		}
+
+		workRate = workRate / ((uint64_t) postdiv);
+	}
+	else {
+		/* In bypass mode */
+		workRate = (uint64_t) inPllRate;
+	}
+
+	return (uint32_t) workRate;
+}
+
+/* Return System PLL output clock rate */
+uint32_t Chip_Clock_GetSystemPLLOutClockRate(bool recompute)
+{
+	PLL_SETUP_T Setup;
+	uint32_t rate;
+
+	if ((recompute == true) || (curPllRate == 0)) {
+		Setup.SYSPLLCTRL = LPC_SYSCON->SYSPLLCTRL;
+		Setup.SYSPLLNDEC = LPC_SYSCON->SYSPLLNDEC;
+		Setup.SYSPLLPDEC = LPC_SYSCON->SYSPLLPDEC;
+		Setup.SYSPLLSSCTRL[0] = LPC_SYSCON->SYSPLLSSCTRL[0];
+		Setup.SYSPLLSSCTRL[1] = LPC_SYSCON->SYSPLLSSCTRL[1];
+
+		Chip_Clock_GetSystemPLLOutFromSetupUpdate(&Setup);
+	}
+
+	rate = curPllRate;
+
+	return rate;
+}
+
+/* Enables and disables PLL bypass mode */
+void Chip_Clock_SetBypassPLL(bool bypass)
+{
+	if (bypass) {
+		LPC_SYSCON->SYSPLLCTRL |= SYSCON_SYSPLLCTRL_BYPASS_P;
+	}
+	else {
+		LPC_SYSCON->SYSPLLCTRL &= ~SYSCON_SYSPLLCTRL_BYPASS_P;
+	}
+}
+
+/* Set PLL output based on the passed PLL setup data */
+PLL_ERROR_T Chip_Clock_SetupPLLData(PLL_CONFIG_T *pControl, PLL_SETUP_T *pSetup)
+{
+	uint32_t inRate;
+	bool useSS = (bool) ((pControl->flags & PLL_CONFIGFLAG_FORCENOFRACT) == 0);
+	PLL_ERROR_T pllError;
+
+	/* Determine input rate for the PLL */
+	if ((pControl->flags & PLL_CONFIGFLAG_USEINRATE) != 0) {
+		inRate = pControl->InputRate;
+	}
+	else {
+		inRate = Chip_Clock_GetSystemPLLInClockRate();
+	}
+
+	/* PLL flag options */
+	pllError = Chip_Clock_GetPllConfig(inRate, pControl->desiredRate, pSetup, false, useSS);
+	if ((useSS) && (pllError == PLL_ERROR_SUCCESS)) {
+		/* If using SS mode, then some tweaks are made to the generated setup */
+		pSetup->SYSPLLSSCTRL[1] |= (uint32_t) pControl->ss_mf | (uint32_t) pControl->ss_mr |
+								   (uint32_t) pControl->ss_mc;
+		if (pControl->mfDither) {
+			pSetup->SYSPLLSSCTRL[1] |= PLL_SSCG1_DITHER;
+		}
+	}
+
+	return pllError;
+}
+
+/* Set PLL output from PLL setup structure */
+PLL_ERROR_T Chip_Clock_SetupSystemPLLPrec(PLL_SETUP_T *pSetup)
+{
+	/* Power off PLL during setup changes */
+	Chip_SYSCON_PowerDown(SYSCON_PDRUNCFG_PD_SYS_PLL);
+
+	/* Write PLL setup data */
+	LPC_SYSCON->SYSPLLCTRL = pSetup->SYSPLLCTRL;
+	LPC_SYSCON->SYSPLLNDEC = pSetup->SYSPLLNDEC;
+	LPC_SYSCON->SYSPLLNDEC = pSetup->SYSPLLNDEC | PLL_NDEC_NREQ;/* latch */
+	LPC_SYSCON->SYSPLLPDEC = pSetup->SYSPLLPDEC;
+	LPC_SYSCON->SYSPLLPDEC = pSetup->SYSPLLPDEC | PLL_PDEC_PREQ;/* latch */
+	LPC_SYSCON->SYSPLLSSCTRL[0] = pSetup->SYSPLLSSCTRL[0];
+	LPC_SYSCON->SYSPLLSSCTRL[0] = pSetup->SYSPLLSSCTRL[0] | PLL_SSCG0_MREQ;	/* latch */
+	LPC_SYSCON->SYSPLLSSCTRL[1] = pSetup->SYSPLLSSCTRL[1];
+	LPC_SYSCON->SYSPLLSSCTRL[1] = pSetup->SYSPLLSSCTRL[1] | PLL_SSCG1_MD_REQ;	/* latch */
+
+	/* Flags for lock or power on */
+	if ((pSetup->flags & (PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK)) != 0) {
+		Chip_SYSCON_PowerUp(SYSCON_PDRUNCFG_PD_SYS_PLL);
+	}
+	if ((pSetup->flags & PLL_SETUPFLAG_WAITLOCK) != 0) {
+		while (Chip_Clock_IsSystemPLLLocked() == false) {}
+	}
+
+	/* Update current programmed PLL rate var */
+	Chip_Clock_GetSystemPLLOutFromSetupUpdate(pSetup);
+
+	/* System voltage adjustment, occurs prior to setting main system clock */
+	if ((pSetup->flags & PLL_SETUPFLAG_ADGVOLT) != 0) {
+		Chip_POWER_SetVoltage(POWER_LOW_POWER_MODE, curPllRate);
+	}
+	curPllRate = 0;
+
+	return PLL_ERROR_SUCCESS;
+}
+
+/*
+    Set System PLL clock based on the input frequency and multiplier
+
+    Here is the configuration used by this function:
+    - input divider -- set to 2
+    - output -- direct (p-divider is not used)
+    - direct in = off
+    - direct out = on
+
+    There is a subtle doubling of the "multiply_by" factor.
+    There is a feedback clock that is not disabled.
+    Because it halves the divider, it doubles the frequency.
+    This is used to compensate for the input divider value.
+
+ */
+
+void Chip_Clock_SetupSystemPLL(uint32_t multiply_by, uint32_t input_freq)
+{
+	uint32_t cco_freq = input_freq * multiply_by;
+	uint32_t pdec = 1;
+	uint32_t selr;
+	uint32_t seli;
+	uint32_t selp;
+	uint32_t mdec, ndec;
+
+	uint32_t directo = SYS_PLL_DIRECTO;
+
+	while (cco_freq < 75000000) {
+		multiply_by <<= 1;	/* double value in each iteration */
+		pdec <<= 1;			/* correspondingly double pdec to cancel effect of double msel */
+		cco_freq = input_freq * multiply_by;
+	}
+	selr = 0;
+	seli = (multiply_by & 0x3c) + 4;
+	selp = (multiply_by >> 1) + 1;
+
+	if (pdec > 1) {
+		directo = 0;	/* use post divider */
+		pdec = pdec / 2;	/* Account for minus 1 encoding */
+		/* Translate P value */
+		pdec = (pdec == 1)  ? 0x62 :	/* 1  * 2 */
+			   (pdec == 2)  ? 0x42 :	/* 2  * 2 */
+			   (pdec == 4)  ? 0x02 :	/* 4  * 2 */
+			   (pdec == 8)  ? 0x0b :	/* 8  * 2 */
+			   (pdec == 16) ? 0x11 :	/* 16 * 2 */
+			   (pdec == 32) ? 0x08 : 0x08;	/* 32 * 2 */
+	}
+
+	/* Only support values of 2 to 16 (to keep driver simple) */
+	mdec = 0x7fff >> (16 - (multiply_by - 1));
+	ndec = 0x202;	/* pre divide by 2 (hardcoded) */
+
+	LPC_SYSCON->SYSPLLCTRL = SYS_PLL_BANDSEL | directo | (selr << SYSCON_SYSPLLCTRL_SELR_P) |
+							 (seli << SYSCON_SYSPLLCTRL_SELI_P) | (selp << SYSCON_SYSPLLCTRL_SELP_P);
+
+	LPC_SYSCON->SYSPLLPDEC = pdec;									/* set PDEC value */
+	LPC_SYSCON->SYSPLLPDEC = pdec | (1 << 7);						/* Assert PDEC reload request: load register into PLL */
+
+	LPC_SYSCON->SYSPLLNDEC = ndec;									/* set NDEC value */
+	LPC_SYSCON->SYSPLLNDEC = ndec | (1 << 10);						/* Assert NDEC reload request: load register into PLL */
+
+	LPC_SYSCON->SYSPLLSSCTRL[0] = (1 << 18) | mdec;					/* set MDEC value*/
+	LPC_SYSCON->SYSPLLSSCTRL[0] = (1 << 18) | (1 << 17) | mdec;		/* Load register into the PLL */
+
+	curPllRate = 0;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/ring_buffer.c ./chip/src/ring_buffer.c
--- a_tnusFF/chip/src/ring_buffer.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/ring_buffer.c	2016-10-22 23:21:09.408845790 -0300
@@ -0,0 +1,181 @@
+/*
+ * @brief Common ring buffer support functions
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2012
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include <string.h>
+#include "ring_buffer.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define RB_INDH(rb)                ((rb)->head & ((rb)->count - 1))
+#define RB_INDT(rb)                ((rb)->tail & ((rb)->count - 1))
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize ring buffer */
+int RingBuffer_Init(RINGBUFF_T *RingBuff,
+					void *buffer,
+					int itemSize,
+					int count,
+					void *(*cpyFunc)(void *dst, const void *src, uint32_t len))
+{
+	RingBuff->data = buffer;
+	RingBuff->count = count;
+	RingBuff->itemSz = itemSize;
+	RingBuff->head = RingBuff->tail = 0;
+	if (!cpyFunc) {
+		cpyFunc = (void *(*)(void *, const void *, uint32_t)) memcpy;
+	}
+	RingBuff->copy = cpyFunc;
+
+	return 1;
+}
+
+/* Insert a single item into Ring Buffer */
+int RingBuffer_Insert(RINGBUFF_T *RingBuff, const void *data)
+{
+	uint8_t *ptr = RingBuff->data;
+
+	/* We cannot insert when queue is full */
+	if (RingBuffer_IsFull(RingBuff)) {
+		return 0;
+	}
+
+	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+	RingBuff->copy(ptr, data, RingBuff->itemSz);
+	RingBuff->head++;
+
+	return 1;
+}
+
+/* Insert multiple items into Ring Buffer */
+int RingBuffer_InsertMult(RINGBUFF_T *RingBuff, const void *data, int num)
+{
+	uint8_t *ptr = RingBuff->data;
+	int cnt1, cnt2;
+
+	/* We cannot insert when queue is full */
+	if (RingBuffer_IsFull(RingBuff)) {
+		return 0;
+	}
+
+	/* Calculate the segment lengths */
+	cnt1 = cnt2 = RingBuffer_GetFree(RingBuff);
+	if (RB_INDH(RingBuff) + cnt1 >= RingBuff->count) {
+		cnt1 = RingBuff->count - RB_INDH(RingBuff);
+	}
+	cnt2 -= cnt1;
+
+	cnt1 = MIN(cnt1, num);
+	num -= cnt1;
+
+	cnt2 = MIN(cnt2, num);
+	num -= cnt2;
+
+	/* Write segment 1 */
+	ptr += RB_INDH(RingBuff) * RingBuff->itemSz;
+	RingBuff->copy(ptr, data, cnt1 * RingBuff->itemSz);
+	RingBuff->head += cnt1;
+
+	/* Write segment 2 */
+	ptr = (uint8_t *) RingBuff->data + RB_INDH(RingBuff) * RingBuff->itemSz;
+	data = (const uint8_t *) data + cnt1 * RingBuff->itemSz;
+	RingBuff->copy(ptr, data, cnt2 * RingBuff->itemSz);
+	RingBuff->head += cnt2;
+
+	return cnt1 + cnt2;
+}
+
+/* Pop single item from Ring Buffer */
+int RingBuffer_Pop(RINGBUFF_T *RingBuff, void *data)
+{
+	uint8_t *ptr = RingBuff->data;
+
+	/* We cannot pop when queue is empty */
+	if (RingBuffer_IsEmpty(RingBuff)) {
+		return 0;
+	}
+
+	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+	RingBuff->copy(data, ptr, RingBuff->itemSz);
+	RingBuff->tail++;
+
+	return 1;
+}
+
+/* Pop multiple items from Ring buffer */
+int RingBuffer_PopMult(RINGBUFF_T *RingBuff, void *data, int num)
+{
+	uint8_t *ptr = RingBuff->data;
+	int cnt1, cnt2;
+
+	/* We cannot insert when queue is empty */
+	if (RingBuffer_IsEmpty(RingBuff)) {
+		return 0;
+	}
+
+	/* Calculate the segment lengths */
+	cnt1 = cnt2 = RingBuffer_GetCount(RingBuff);
+	if (RB_INDT(RingBuff) + cnt1 >= RingBuff->count) {
+		cnt1 = RingBuff->count - RB_INDT(RingBuff);
+	}
+	cnt2 -= cnt1;
+
+	cnt1 = MIN(cnt1, num);
+	num -= cnt1;
+
+	cnt2 = MIN(cnt2, num);
+	num -= cnt2;
+
+	/* Write segment 1 */
+	ptr += RB_INDT(RingBuff) * RingBuff->itemSz;
+	RingBuff->copy(data, ptr, cnt1 * RingBuff->itemSz);
+	RingBuff->tail += cnt1;
+
+	/* Write segment 2 */
+	ptr = (uint8_t *) RingBuff->data + RB_INDT(RingBuff) * RingBuff->itemSz;
+	data = (uint8_t *) data + cnt1 * RingBuff->itemSz;
+	RingBuff->copy(data, ptr, cnt2 * RingBuff->itemSz);
+	RingBuff->tail += cnt2;
+
+	return cnt1 + cnt2;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/ritimer_5410x.c ./chip/src/ritimer_5410x.c
--- a_tnusFF/chip/src/ritimer_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/ritimer_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,105 @@
+/*
+ * @brief LPC5410X RITimer chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the RIT */
+void Chip_RIT_Init(LPC_RITIMER_T *pRITimer)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_RIT);
+	Chip_SYSCON_PeriphReset(RESET_RIT);
+
+	/* Default is timer disabled */
+	pRITimer->CTRL = 0x0;
+}
+
+/* DeInitialize the RIT */
+void Chip_RIT_DeInit(LPC_RITIMER_T *pRITimer)
+{
+	pRITimer->CTRL = 0x0;
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_RIT);
+}
+
+/* Set timer interval value */
+void Chip_RIT_SetTimerInterval(LPC_RITIMER_T *pRITimer, uint32_t time_interval)
+{
+	uint32_t cmp_value;
+
+	/* Determine aapproximate compare value based on clock rate and passed interval */
+	cmp_value = (Chip_Clock_GetMainClockRate() / 1000) * time_interval;
+
+	/* Set timer compare value */
+	Chip_RIT_SetCOMPVAL(pRITimer, cmp_value);
+}
+
+/* Set timer interval value (48-bit) */
+void Chip_RIT_SetTimerInterval64(LPC_RITIMER_T *pRITimer, uint64_t time_interval)
+{
+	uint64_t cmp_value;
+
+	/* Determine aapproximate compare value based on clock rate and passed interval */
+	cmp_value = (uint64_t) Chip_Clock_GetMainClockRate() / 1000;
+	cmp_value = cmp_value * time_interval;
+
+	/* Set timer compare value */
+	Chip_RIT_SetCOMPVAL64(pRITimer, cmp_value);
+}
+
+/* Check whether interrupt is pending */
+IntStatus Chip_RIT_GetIntStatus(LPC_RITIMER_T *pRITimer)
+{
+	uint8_t result;
+
+	if ((pRITimer->CTRL & RIT_CTRL_INT) == 1) {
+		result = SET;
+	}
+	else {
+		return RESET;
+	}
+
+	return (IntStatus) result;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/rtc_ut.c ./chip/src/rtc_ut.c
--- a_tnusFF/chip/src/rtc_ut.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/rtc_ut.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,202 @@
+/*
+ * @brief RTC tick to (a more) Universal Time
+ * Adds conversion functions to use an RTC that only provides a
+ * seconds capability to provide "struct tm" support.
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "rtc_ut.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+#define SECSPERMIN      (60)
+#define MINSPERHOUR     (60)
+#define SECSPERHOUR     (SECSPERMIN * MINSPERHOUR)
+#define HOURSPERDAY     (24)
+#define SECSPERDAY      (SECSPERMIN * MINSPERHOUR * HOURSPERDAY)
+#define DAYSPERWEEK     (7)
+#define MONETHSPERYEAR  (12)
+#define DAYSPERYEAR     (365)
+#define DAYSPERLEAPYEAR (366)
+
+/* Days per month, LY is special */
+static uint8_t daysPerMonth[2][MONETHSPERYEAR] = {
+	{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},	/* Normal year */
+	{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},	/* Leap year */
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Converts the number of days offset from the start year to real year
+   data accounting for leap years */
+static void GetDMLY(int dayOff, struct tm *pTime)
+{
+	bool YearFound = false;
+	int daysYear = dayOff;
+	int leapYear, curLeapYear, year = TM_YEAR_BASE, monthYear = 0;
+	bool MonthFound = false;
+
+	/* Leap year check for less than 1 year time */
+	if ((year % 4) == 0) {
+		curLeapYear = 1;
+	}
+	else {
+		curLeapYear = 0;
+	}
+
+	/* Determine offset of years from days offset */
+	while (YearFound == false) {
+		if ((year % 4) == 0) {
+			/* Leap year, 366 days */
+			daysYear = DAYSPERLEAPYEAR;
+			leapYear = 1;
+		}
+		else {
+			/* Leap year, 365 days */
+			daysYear = DAYSPERYEAR;
+			leapYear = 0;
+		}
+
+		if (dayOff > daysYear) {
+			dayOff -= daysYear;
+			year++;
+		}
+		else {
+			YearFound = true;
+			curLeapYear = leapYear;	/* In a leap year */
+		}
+	}
+
+	/* Save relative year and day into year */
+	pTime->tm_year = year - TM_YEAR_BASE;	/* Base year relative */
+	pTime->tm_yday = dayOff;/* 0 relative */
+
+	/* Determine offset of months from days offset */
+	while (MonthFound == false) {
+		if ((dayOff + 1) > daysPerMonth[curLeapYear][monthYear]) {
+			/* Next month */
+			dayOff -= daysPerMonth[curLeapYear][monthYear];
+			monthYear++;
+		}
+		else {
+			/* Month found */
+			MonthFound = true;
+		}
+	}
+
+	pTime->tm_mday = dayOff + 1;/* 1 relative */
+	pTime->tm_mon = monthYear;	/* 0 relative */
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Converts an RTC tick time to Universal time */
+void ConvertRtcTime(uint32_t rtcTick, struct tm *pTime)
+{
+	int daySeconds, dayNum;
+
+	/* Get day offset and seconds since start */
+	dayNum = (int) (rtcTick / SECSPERDAY);
+	daySeconds = (int) (rtcTick % SECSPERDAY);
+
+	/* Fill in secs, min, hours */
+	pTime->tm_sec = daySeconds % 60;
+	pTime->tm_hour = daySeconds / SECSPERHOUR;
+	pTime->tm_min = (daySeconds - (pTime->tm_hour * SECSPERHOUR)) / SECSPERMIN;
+
+	/* Weekday, 0 = Sunday, 6 = Saturday */
+	pTime->tm_wday = (dayNum + TM_DAYOFWEEK) % DAYSPERWEEK;
+
+	/* Get year, month, day of month, and day of year */
+	GetDMLY(dayNum, pTime);
+
+	/* Not supported in this driver */
+	pTime->tm_isdst = 0;
+}
+
+/* Converts a Universal time to RTC tick time */
+void ConvertTimeRtc(struct tm *pTime, uint32_t *rtcTick)
+{
+	int leapYear, year = pTime->tm_year + TM_YEAR_BASE;
+	uint32_t dayOff, monthOff, monthCur, rtcTicks = 0;
+
+	/* Leap year check for less than 1 year time */
+	if ((year % 4) == 0) {
+		leapYear = 1;
+	}
+	else {
+		leapYear = 0;
+	}
+
+	/* Add days for each year and leap year */
+	while (year > TM_YEAR_BASE) {
+		if ((year % 4) == 0) {
+			/* Leap year, 366 days */
+			rtcTicks += DAYSPERLEAPYEAR * SECSPERDAY;
+			leapYear = 1;
+		}
+		else {
+			/* Leap year, 365 days */
+			rtcTicks += DAYSPERYEAR * SECSPERDAY;
+			leapYear = 0;
+		}
+
+		year--;
+	}
+
+	/* Day and month are 0 relative offsets since day and month
+	   start at 1 */
+	dayOff = (uint32_t) pTime->tm_mday - 1;
+	monthOff = (uint32_t) pTime->tm_mon;
+
+	/* Add in seconds for passed months */
+	for (monthCur = 0; monthCur < monthOff; monthCur++) {
+		rtcTicks += (uint32_t) (daysPerMonth[leapYear][monthCur] * SECSPERDAY);
+	}
+
+	/* Add in seconds for day offset into the current month */
+	rtcTicks += (dayOff * SECSPERDAY);
+
+	/* Add in seconds for hours, minutes, and seconds */
+	rtcTicks += (uint32_t) (pTime->tm_hour * SECSPERHOUR);
+	rtcTicks += (uint32_t) (pTime->tm_min * SECSPERMIN);
+	rtcTicks += (uint32_t) pTime->tm_sec;
+
+	*rtcTick = rtcTicks;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/sct_5410x.c ./chip/src/sct_5410x.c
--- a_tnusFF/chip/src/sct_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/sct_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,81 @@
+/*
+ * @brief LPC5410X State Configurable Timer driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize SCT */
+void Chip_SCT_Init(LPC_SCT_T *pSCT)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_SCT0);
+	Chip_SYSCON_PeriphReset(RESET_SCT0);
+}
+
+/* Shutdown SCT */
+void Chip_SCT_DeInit(LPC_SCT_T *pSCT)
+{
+	Chip_Clock_DisablePeriphClock(SYSCON_CLOCK_SCT0);
+}
+
+/* Set/Clear SCT control register */
+void Chip_SCT_SetClrControl(LPC_SCT_T *pSCT, uint32_t value, FunctionalState ena)
+{
+	if (ena == ENABLE) {
+		Chip_SCT_SetControl(pSCT, value);
+	}
+	else {
+		Chip_SCT_ClearControl(pSCT, value);
+	}
+}
+
+/* Set Conflict resolution */
+void Chip_SCT_SetConflictResolution(LPC_SCT_T *pSCT, uint8_t outnum, uint8_t value)
+{
+	uint32_t tem;
+
+	tem = pSCT->RES & (~(0x03 << (2 * outnum)));
+	pSCT->RES = tem | (value << (2 * outnum));
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/sct_pwm_5410x.c ./chip/src/sct_pwm_5410x.c
--- a_tnusFF/chip/src/sct_pwm_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/sct_pwm_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,86 @@
+/*
+ * @brief LPC5410x State Configurable Timer PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Setup the OUTPUT pin corresponding to the PWM index */
+void Chip_SCTPWM_SetOutPin(LPC_SCT_T *pSCT, uint8_t index, uint8_t pin)
+{
+	int ix = (int) index;
+	pSCT->EVENT[ix].CTRL = index | (1 << 12);
+	pSCT->EVENT[ix].STATE = 1;
+	pSCT->OUT[pin].SET = 1;
+	pSCT->OUT[pin].CLR = 1 << ix;
+
+	/* Clear the output in-case of conflict */
+	pSCT->RES = (pSCT->RES & ~(3 << (pin << 1))) | (0x01 << (pin << 1));
+
+	/* Set and Clear do not depend on direction */
+	pSCT->OUTPUTDIRCTRL = (pSCT->OUTPUTDIRCTRL & ~(3 << (pin << 1)));
+}
+
+/* Set the PWM frequency */
+void Chip_SCTPWM_SetRate(LPC_SCT_T *pSCT, uint32_t freq)
+{
+	uint32_t rate;
+
+	rate = Chip_Clock_GetSystemClockRate() / freq;
+
+	/* Stop the SCT before configuration */
+	Chip_SCTPWM_Stop(pSCT);
+
+	/* Set MATCH0 for max limit */
+	pSCT->REGMODE_L = 0;
+	pSCT->REGMODE_H = 0;
+	Chip_SCT_SetMatchCount(pSCT, SCT_MATCH_0, 0);
+	Chip_SCT_SetMatchReload(pSCT, SCT_MATCH_0, rate);
+	pSCT->EVENT[0].CTRL = 1 << 12;
+	pSCT->EVENT[0].STATE = 1;
+
+	/* Set SCT Counter to count 32-bits and reset to 0 after reaching MATCH0 */
+	Chip_SCT_Config(pSCT, SCT_CONFIG_32BIT_COUNTER | SCT_CONFIG_AUTOLIMIT_L);
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/spi_common_5410x.c ./chip/src/spi_common_5410x.c
--- a_tnusFF/chip/src/spi_common_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/spi_common_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,71 @@
+/*
+ * @brief LPC5410X SPI driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Setup SAPI configuration */
+void Chip_SPI_ConfigureSPI(LPC_SPI_T *pSPI, SPI_CFGSETUP_T *pCFG)
+{
+	uint32_t reg;
+
+	/* Get register and mask off config bits this function alters */
+	reg = pSPI->CFG & ~(SPI_CFG_MASTER_EN | SPI_CFG_LSB_FIRST_EN |
+						SPI_CFG_CPHA_SECOND | SPI_CFG_CPOL_HI);
+
+	if (pCFG->master) {
+		reg |= SPI_CFG_MASTER_EN;
+	}
+	if (pCFG->lsbFirst) {
+		reg |= SPI_CFG_LSB_FIRST_EN;
+	}
+	reg |= (uint32_t) pCFG->mode;
+
+	Chip_SPI_SetCFGRegBits(pSPI, reg);
+
+	/* Deassert all chip selects, only in master mode */
+	pSPI->TXCTRL = SPI_TXDATCTL_DEASSERT_ALL;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/spim_5410x.c ./chip/src/spim_5410x.c
--- a_tnusFF/chip/src/spim_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/spim_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,201 @@
+/*
+ * @brief LPC5410X SPI master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Get SPI master bit rate */
+uint32_t Chip_SPIM_GetClockRate(LPC_SPI_T *pSPI)
+{
+	return Chip_Clock_GetAsyncSyscon_ClockRate() / (pSPI->DIV + 1);
+}
+
+/* Set SPI master bit rate */
+uint32_t Chip_SPIM_SetClockRate(LPC_SPI_T *pSPI, uint32_t rate)
+{
+	uint32_t baseClock, div;
+
+	/* Get peripheral base clock rate */
+	baseClock = Chip_Clock_GetAsyncSyscon_ClockRate();
+
+	/* Compute divider */
+	div = baseClock / rate;
+
+	/* Limit values */
+	if (div == 0) {
+		div = 1;
+	}
+	else if (div > 0x10000) {
+		div = 0x10000;
+	}
+	pSPI->DIV = div - 1;
+
+	return Chip_SPIM_GetClockRate(pSPI);
+}
+
+/* Handler SPI transfer RX */
+__STATIC_INLINE int Chip_SPIM_HandlerRx(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
+{
+	int ret = 0;
+	int flen = (xfer->options >> 8) & 0xF;
+	uint32_t data = Chip_SPI_ReadRawRXFifo(pSPI);
+
+	if (xfer->rxCount > xfer->rxDoneCount) {
+		if (flen > 8) {
+			((uint16_t *) xfer->rxBuff)[xfer->rxDoneCount] = data;
+		}
+		else {
+			((uint8_t *) xfer->rxBuff)[xfer->rxDoneCount] = data;
+		}
+		ret = 1;
+	}
+	xfer->rxDoneCount++;
+	if ((xfer->rxCount == xfer->rxDoneCount) && xfer->cbFunc) {
+		xfer->cbFunc(SPIM_EVT_RXDONE, xfer);
+	}
+	return ret;
+}
+
+/* SPI master transfer state change handler */
+void Chip_SPIM_XferHandler(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
+{
+	uint32_t data;
+	uint8_t flen;
+
+	/* Get length of a receive value */
+	flen = (pSPI->TXCTRL >> 24) & 0xF;
+
+	/* Master asserts slave */
+	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSA) != 0) {
+		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSA);
+
+		xfer->state = SPIM_XFER_STATE_BUSY;
+		/* SSEL assertion callback */
+		if (xfer->cbFunc) {
+			xfer->cbFunc(SPIM_EVT_SSELASSERT, xfer);
+		}
+	}
+
+	/* Slave de-assertion */
+	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSD) != 0) {
+		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSD);
+
+		xfer->state = SPIM_XFER_STATE_DONE;
+		/* SSEL assertion callback */
+		if (xfer->cbFunc) {
+			xfer->cbFunc(SPIM_EVT_SSELDEASSERT, xfer);
+		}
+	}
+
+	/* Data received? */
+	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) != 0 && Chip_SPIM_HandlerRx(pSPI, xfer)) {}
+
+	/* Transmit data? */
+	while (((Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY) != 0)) {
+		int32_t len = xfer->rxCount > xfer->txCount ? xfer->rxCount : xfer->txCount;
+		if ((xfer->rxCount <= xfer->rxDoneCount) && (xfer->txCount <= xfer->txDoneCount)) {
+			xfer->state = SPIM_XFER_STATE_DONE;
+			/* Transfer is done, this will be last data */
+			Chip_SPIM_ForceEndOfTransfer(pSPI);
+			return;
+		}
+		data = 0;
+		if (xfer->txCount > xfer->txDoneCount) {
+			if (flen > 8) {
+				data = ((uint16_t *) xfer->txBuff)[xfer->txDoneCount];
+			}
+			else {
+				data = ((uint8_t *) xfer->txBuff)[xfer->txDoneCount];
+			}
+		}
+
+		/* Check for end of transfer and end the transfer if needed */
+		if ((len == (xfer->txDoneCount + 1)) && (xfer->options & SPIM_XFER_OPTION_EOT)) {
+			pSPI->TXDATCTL = pSPI->TXCTRL | SPI_TXDATCTL_EOT | data;
+		}
+		else {
+			Chip_SPI_WriteTXData(pSPI, data);
+		}
+
+		xfer->txDoneCount++;
+		if ((xfer->txCount == xfer->txDoneCount) && xfer->cbFunc) {
+			xfer->cbFunc(SPIM_EVT_TXDONE, xfer);
+		}
+
+		/* Check if we have a data ready to receive */
+		if (Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) {
+			Chip_SPIM_HandlerRx(pSPI, xfer);
+		}
+	}
+}
+
+/* Start non-blocking SPI master transfer */
+void Chip_SPIM_Xfer(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
+{
+	/* Setup SPI master select, data length, EOT/EOF timing, and RX data ignore */
+	pSPI->TXCTRL =
+		((xfer->options <<
+		  16) | SPI_TXDATCTL_DEASSERT_ALL | (xfer->rxBuff ? 0 : SPI_TXDATCTL_RXIGNORE)) & ~SPI_TXDATCTL_EOT;
+	Chip_SPIM_AssertSSEL(pSPI, xfer->sselNum);
+
+	/* Clear initial transfer states */
+	xfer->txDoneCount = xfer->rxDoneCount = 0;
+
+	/* Call main handler to start transfer */
+	Chip_SPIM_XferHandler(pSPI, xfer);
+}
+
+/* Perform blocking SPI master transfer */
+void Chip_SPIM_XferBlocking(LPC_SPI_T *pSPI, SPIM_XFER_T *xfer)
+{
+	/* Start trasnfer */
+	Chip_SPIM_Xfer(pSPI, xfer);
+
+	/* Wait for termination */
+	while (xfer->state != SPIM_XFER_STATE_DONE) {
+		Chip_SPIM_XferHandler(pSPI, xfer);
+	}
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/spis_5410x.c ./chip/src/spis_5410x.c
--- a_tnusFF/chip/src/spis_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/spis_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,154 @@
+/*
+ * @brief LPC5410X SPI master driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Determine SSEL associated with the current data value */
+static uint8_t Chip_SPIS_FindSSEL(LPC_SPI_T *pSPI, uint32_t data)
+{
+	int i;
+	uint8_t ssel = 0;
+
+	for (i = 0; i <= 3; i++) {
+		if ((data & SPI_RXDAT_RXSSELNUM_INACTIVE(i)) == 0) {
+			/* Signal is active on low */
+			ssel = (uint8_t) i;
+		}
+	}
+
+	return ssel;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* SPI slave transfer state change handler */
+uint32_t Chip_SPIS_XferHandler(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
+{
+	uint32_t staterr, data;
+	uint8_t flen;
+
+	/* Get length of a receive value */
+	flen = (pSPI->TXCTRL >> 24) & 0xF;
+
+	/* Data received? */
+	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) != 0) {
+		/* Get raw data and status */
+		data = Chip_SPI_ReadRXData(pSPI);
+		if (xfer->rxCount > xfer->rxDoneCount) {
+			if (flen > 8) {
+				((uint16_t *) xfer->rxBuff)[xfer->rxDoneCount] = data;
+			}
+			else {
+				((uint8_t *) xfer->rxBuff)[xfer->rxDoneCount] = data;
+			}
+		}
+		xfer->rxDoneCount++;
+		if (xfer->cbFunc && (xfer->rxCount == xfer->rxDoneCount)) {
+			xfer->cbFunc(SPIS_EVT_RXDONE, xfer);
+		}
+	}
+
+	/* Get errors for later, we'll continue even if errors occur, but we notify
+	   caller on return */
+	staterr = Chip_SPI_GetStatus(pSPI) & (SPI_STAT_RXOV | SPI_STAT_TXUR);
+	if (staterr != 0) {
+		Chip_SPI_ClearStatus(pSPI, staterr);
+	}
+
+	/* Slave assertion */
+	if ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSA) != 0) {
+		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSA);
+
+		/* Determine SPI select. Read the data FIFO to get the slave number. Data
+		   should not be in the receive FIFO yet, only the statuses */
+		xfer->sselNum = Chip_SPIS_FindSSEL(pSPI, Chip_SPI_ReadRawRXFifo(pSPI));
+
+		xfer->state = SPIS_XFER_STATE_BUSY;
+		/* SSEL assertion callback */
+		if (xfer->cbFunc) {
+			xfer->cbFunc(SPIS_EVT_SSELASSERT, xfer);
+		}
+	}
+
+	/* Transmit data? */
+	while ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_TXRDY) != 0) {
+		data = 0;
+		if (xfer->txCount > xfer->txDoneCount) {
+			data = flen > 8 ?
+				   (uint32_t) ((uint16_t *) xfer->txBuff)[xfer->txDoneCount] :
+				   (uint32_t) ((uint8_t *) xfer->txBuff)[xfer->txDoneCount];
+		}
+		Chip_SPI_WriteTXData(pSPI, data);
+		xfer->txDoneCount++;
+		if (xfer->cbFunc && (xfer->txCount == xfer->txDoneCount)) {
+			xfer->cbFunc(SPIS_EVT_TXDONE, xfer);
+		}
+	}
+
+	/* Slave de-assertion */
+	if (((Chip_SPI_GetStatus(pSPI) & SPI_STAT_SSD) != 0) && ((Chip_SPI_GetStatus(pSPI) & SPI_STAT_RXRDY) == 0)) {
+		Chip_SPI_ClearStatus(pSPI, SPI_STAT_SSD);
+		xfer->state = SPIS_XFER_STATE_DONE;
+		/* SSEL assertion callback */
+		if (xfer->cbFunc) {
+			xfer->cbFunc(SPIS_EVT_SSELDEASSERT, xfer);
+		}
+	}
+
+	return staterr;
+}
+
+/* SPI slave transfer blocking function */
+uint32_t Chip_SPIS_XferBlocking(LPC_SPI_T *pSPI, SPIS_XFER_T *xfer)
+{
+	uint32_t status = 0;
+
+	/* Wait forever until deassertion event */
+	while (xfer->state != SPIS_XFER_STATE_DONE) {
+		status = Chip_SPIS_XferHandler(pSPI, xfer);
+	}
+
+	return status;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/stopwatch_5410x.c ./chip/src/stopwatch_5410x.c
--- a_tnusFF/chip/src/stopwatch_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/stopwatch_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,109 @@
+/*
+ * @brief LPC5410x specific stopwatch implementation
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+#include "stopwatch.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/* Precompute these to optimize runtime */
+static uint32_t ticksPerSecond;
+static uint32_t ticksPerMs;
+static uint32_t ticksPerUs;
+
+/* Use this timer for stopwatch */
+#define LPC_TIMER32_1 LPC_TIMER0
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize stopwatch */
+void StopWatch_Init(void)
+{
+	/* Set prescaler to divide by 8 */
+	const uint32_t prescaleDivisor = 8;
+	Chip_TIMER_Init(LPC_TIMER32_1);
+	Chip_TIMER_PrescaleSet(LPC_TIMER32_1, prescaleDivisor - 1);
+	Chip_TIMER_Enable(LPC_TIMER32_1);
+
+	/* Pre-compute tick rate. */
+	ticksPerSecond = Chip_Clock_GetAsyncSyscon_ClockRate() / prescaleDivisor;
+	ticksPerMs = ticksPerSecond / 1000;
+	ticksPerUs = ticksPerSecond / 1000000;
+}
+
+/* Start a stopwatch */
+uint32_t StopWatch_Start(void)
+{
+	/* Return the current timer count. */
+	return Chip_TIMER_ReadCount(LPC_TIMER32_1);
+}
+
+/* Returns number of ticks per second of the stopwatch timer */
+uint32_t StopWatch_TicksPerSecond(void)
+{
+	return ticksPerSecond;
+}
+
+/* Converts from stopwatch ticks to mS. */
+uint32_t StopWatch_TicksToMs(uint32_t ticks)
+{
+	return ticks / ticksPerMs;
+}
+
+/* Converts from stopwatch ticks to uS. */
+uint32_t StopWatch_TicksToUs(uint32_t ticks)
+{
+	return ticks / ticksPerUs;
+}
+
+/* Converts from mS to stopwatch ticks. */
+uint32_t StopWatch_MsToTicks(uint32_t mS)
+{
+	return mS * ticksPerMs;
+}
+
+/* Converts from uS to stopwatch ticks. */
+uint32_t StopWatch_UsToTicks(uint32_t uS)
+{
+	return uS * ticksPerUs;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/syscon_5410x.c ./chip/src/syscon_5410x.c
--- a_tnusFF/chip/src/syscon_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/syscon_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,192 @@
+/*
+ * @brief LPC5410X System & Control driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Set source for non-maskable interrupt (NMI) */
+void Chip_SYSCON_SetNMISource(uint32_t intsrc)
+{
+	uint32_t reg;
+
+	reg = LPC_SYSCON->NMISRC;
+#if defined(CORE_M4)
+	reg &= ~SYSCON_NMISRC_M4_ENABLE;
+#else
+	reg &= ~SYSCON_NMISRC_M0_ENABLE;
+	intsrc = (intsrc << 8);
+#endif
+
+	/* First write without NMI bit, and then write source */
+	LPC_SYSCON->NMISRC = reg;
+	LPC_SYSCON->NMISRC = reg | intsrc;
+}
+
+/* Enable interrupt used for NMI source */
+void Chip_SYSCON_EnableNMISource(void)
+{
+#if defined(CORE_M4)
+	LPC_SYSCON->NMISRC |= SYSCON_NMISRC_M4_ENABLE;
+#else
+	LPC_SYSCON->NMISRC |= SYSCON_NMISRC_M0_ENABLE;
+#endif
+}
+
+/* Disable interrupt used for NMI source */
+void Chip_SYSCON_DisableNMISource(void)
+{
+#if defined(CORE_M4)
+	LPC_SYSCON->NMISRC &= ~SYSCON_NMISRC_M4_ENABLE;
+#else
+	LPC_SYSCON->NMISRC &= ~SYSCON_NMISRC_M0_ENABLE;
+#endif
+}
+
+/* Enable or disable asynchronous APB bridge and subsystem */
+void Chip_SYSCON_Enable_ASYNC_Syscon(bool enable)
+{
+	if (enable) {
+		LPC_SYSCON->ASYNCAPBCTRL = 0x01;
+	}
+	else {
+		LPC_SYSCON->ASYNCAPBCTRL = 0x00;
+	}
+}
+
+/* Resets a peripheral */
+void Chip_SYSCON_PeriphReset(CHIP_SYSCON_PERIPH_RESET_T periph)
+{
+	uint32_t pid = (uint32_t) periph;
+
+	if (pid >= 128) {
+		/* Async resets mapped to 128 and above, offset for peripheral bit index */
+		pid = 1 << (((uint32_t) periph) - 128);
+		LPC_ASYNC_SYSCON->ASYNCPRESETCTRLSET = pid;
+		LPC_ASYNC_SYSCON->ASYNCPRESETCTRLCLR = pid;
+	}
+	else if (periph >= 32) {
+		pid = 1 << (((uint32_t) periph) - 32);
+		LPC_SYSCON->PRESETCTRLSET[1] = pid;
+		LPC_SYSCON->PRESETCTRLCLR[1] = pid;
+	}
+	else {
+		pid = 1 << ((uint32_t) periph);
+		LPC_SYSCON->PRESETCTRLSET[0] = pid;
+		LPC_SYSCON->PRESETCTRLCLR[0] = pid;
+	}
+}
+
+/* Returns the computed value for a frequency measurement cycle */
+uint32_t Chip_SYSCON_GetCompFreqMeas(uint32_t refClockRate)
+{
+	uint32_t capval;
+	uint64_t clkrate = 0;
+
+	/* Get raw capture value */
+	capval = Chip_SYSCON_GetRawFreqMeasCapval();
+
+	/* Limit CAPVAL check */
+	if (capval > 2) {
+		clkrate = (((uint64_t) capval - 2) * (uint64_t) refClockRate) / 0x4000;
+	}
+
+	return (uint32_t) clkrate;
+}
+
+uint32_t Chip_SYSCON_PLLDelay(void)
+{
+	uint32_t ifreq = Chip_Clock_GetSystemPLLInClockRate();
+	uint32_t coreclk = Chip_Clock_GetMainClockRate(), div = 0;
+	if (coreclk) {
+		div = 12000000 / coreclk;
+	}
+	if (!div) {
+		div = 1;
+	}
+	if (ifreq <= 100000) {
+		/* Dealy for 600 uSecs */
+		return 1430 / div;
+	}
+	else if (ifreq <= 1000000) {
+		/* Delay for 300 uSecs */
+		return 1210 / div;
+	}
+	else if (ifreq <= 10000000) {
+		return 657 / div;
+	}
+	else {
+		return 172 / div;	/* 72 uSecs */
+	}
+}
+
+void Chip_SYSCON_PowerUp(uint32_t powerupmask)
+{
+	/* If turning the PLL back on, perform the following sequence to accelerate PLL lock */
+	if (powerupmask & SYSCON_PDRUNCFG_PD_SYS_PLL) {
+		volatile uint32_t delayX;
+		uint32_t maxCCO = (1 << 18) | 0x5dd2;	/* CCO = 1.6Ghz + MDEC enabled*/
+		uint32_t curSSCTRL = LPC_SYSCON->SYSPLLSSCTRL[0] & ~(1 << 17);	/* current value with mreq cleared */
+
+		/* Initialize  and power up PLL */
+		LPC_SYSCON->SYSPLLSSCTRL[0] = maxCCO;
+		LPC_SYSCON->PDRUNCFGCLR = SYSCON_PDRUNCFG_PD_SYS_PLL;
+
+		/* Set mreq to activate */
+		LPC_SYSCON->SYSPLLSSCTRL[0] = maxCCO | (1 << 17);
+
+		/* Delay for 72 uSec @ 12Mhz */
+		for (delayX = Chip_SYSCON_PLLDelay(); delayX; --delayX) {}
+
+		/* clear mreq to prepare for restoring mreq */
+		LPC_SYSCON->SYSPLLSSCTRL[0] = curSSCTRL;
+
+		/* set original value back and activate */
+		LPC_SYSCON->SYSPLLSSCTRL[0] = curSSCTRL | (1 << 17);
+	}
+
+	/* Enable peripheral states by setting low */
+	LPC_SYSCON->PDRUNCFGCLR = powerupmask;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/sysinit_5410x.c ./chip/src/sysinit_5410x.c
--- a_tnusFF/chip/src/sysinit_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/sysinit_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,169 @@
+/*
+ * @brief LPC5410X Chip specific SystemInit
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Sets the best FLASH clock arte for the passed frequency */
+static void setupFlashClocks(uint32_t freq)
+{
+	/* v17.0 ROM support only - coarse FLASH clocking timing.
+	   FLASH access is setup based on voltage for v17.1 and later ROMs
+	   as part of the power library. */
+	if (Chip_POWER_GetROMVersion() == LPC5410X_ROMVER_0) {
+		if (freq < 20000000) {
+			Chip_SYSCON_SetFLASHAccess(SYSCON_FLASH_1CYCLE);
+		}
+		else if (freq < 48000000) {
+			Chip_SYSCON_SetFLASHAccess(SYSCON_FLASH_2CYCLE);
+		}
+		else if (freq < 72000000) {
+			Chip_SYSCON_SetFLASHAccess(SYSCON_FLASH_3CYCLE);
+		}
+		else {
+			Chip_SYSCON_SetFLASHAccess(SYSCON_FLASH_4CYCLE);
+		}
+	}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Clock and PLL initialization based on the internal oscillator */
+void Chip_SetupIrcClocking(uint32_t iFreq)
+{
+	PLL_CONFIG_T pllConfig;
+	PLL_SETUP_T pllSetup;
+	PLL_ERROR_T pllError;
+
+	/* Turn on the IRC by clearing the power down bit */
+	Chip_SYSCON_PowerUp(SYSCON_PDRUNCFG_PD_IRC_OSC | SYSCON_PDRUNCFG_PD_IRC);
+
+	/* Select the PLL input to the IRC */
+	Chip_Clock_SetSystemPLLSource(SYSCON_PLLCLKSRC_IRC);
+
+	/* Setup FLASH access */
+	setupFlashClocks(iFreq);
+
+	/* Power down PLL to change the PLL divider ratio */
+	Chip_SYSCON_PowerDown(SYSCON_PDRUNCFG_PD_SYS_PLL);
+
+	/* Setup PLL configuration */
+	pllConfig.desiredRate = iFreq;
+	pllConfig.InputRate = 0;
+	pllConfig.flags = PLL_CONFIGFLAG_FORCENOFRACT;
+	pllError = Chip_Clock_SetupPLLData(&pllConfig, &pllSetup);
+	if (pllError == PLL_ERROR_SUCCESS) {
+		pllSetup.flags = PLL_SETUPFLAG_WAITLOCK | PLL_SETUPFLAG_ADGVOLT;
+		pllError = Chip_Clock_SetupSystemPLLPrec(&pllSetup);
+	}
+
+	/* Set system clock divider to 1 */
+	Chip_Clock_SetSysClockDiv(1);
+
+	/* Set main clock source to the system PLL. This will drive 24MHz
+	   for the main clock and 24MHz for the system clock */
+	Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_PLLOUT);
+
+	/* ASYSNC SYSCON needs to be on or all serial peripheral won't work.
+	   Be careful if PLL is used or not, ASYNC_SYSCON source needs to be
+	   selected carefully. */
+	Chip_SYSCON_Enable_ASYNC_Syscon(true);
+	Chip_Clock_SetAsyncSysconClockDiv(1);
+	Chip_Clock_SetAsyncSysconClockSource(SYSCON_ASYNC_IRC);
+}
+
+/* Clock and PLL initialization based on the external clock input */
+void Chip_SetupExtInClocking(uint32_t iFreq)
+{
+	PLL_CONFIG_T pllConfig;
+	PLL_SETUP_T pllSetup;
+	PLL_ERROR_T pllError;
+
+	/* IOCON clock left on, this is needed is CLKIN is used. */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_IOCON);
+
+	/* Select external clock input pin */
+	Chip_IOCON_PinMuxSet(LPC_IOCON, 0, 22, (IOCON_MODE_PULLUP |
+											IOCON_FUNC1 | IOCON_DIGITAL_EN | IOCON_INPFILT_OFF));
+
+	/* Select the PLL input to the EXT clock input */
+	Chip_Clock_SetSystemPLLSource(SYSCON_PLLCLKSRC_CLKIN);
+
+	/* Setup FLASH access */
+	setupFlashClocks(iFreq);
+
+	/* Power down PLL to change the PLL divider ratio */
+	Chip_SYSCON_PowerDown(SYSCON_PDRUNCFG_PD_SYS_PLL);
+
+	/* Setup PLL configuration */
+	pllConfig.desiredRate = iFreq;
+	pllConfig.InputRate = 0;
+	pllConfig.flags = PLL_CONFIGFLAG_FORCENOFRACT;
+	pllError = Chip_Clock_SetupPLLData(&pllConfig, &pllSetup);
+	if (pllError == PLL_ERROR_SUCCESS) {
+		pllSetup.flags = PLL_SETUPFLAG_WAITLOCK | PLL_SETUPFLAG_ADGVOLT;
+		pllError = Chip_Clock_SetupSystemPLLPrec(&pllSetup);
+	}
+
+	/* Set system clock divider to 1 */
+	Chip_Clock_SetSysClockDiv(1);
+
+	/* Set main clock source to the system PLL. This will drive 24MHz
+	   for the main clock and 24MHz for the system clock */
+	Chip_Clock_SetMainClockSource(SYSCON_MAINCLKSRC_PLLOUT);
+
+	/* ASYSNC SYSCON needs to be on or all serial peripheral won't work.
+	   Be careful if PLL is used or not, ASYNC_SYSCON source needs to be
+	   selected carefully. */
+	Chip_SYSCON_Enable_ASYNC_Syscon(true);
+	Chip_Clock_SetAsyncSysconClockDiv(1);
+	Chip_Clock_SetAsyncSysconClockSource(SYSCON_ASYNC_IRC);
+}
+
+/* Set up and initialize hardware prior to call to main */
+void Chip_SystemInit(void)
+{
+	/* Initial internal clocking @100MHz */
+	Chip_SetupIrcClocking(96000000);
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/timer_5410x.c ./chip/src/timer_5410x.c
--- a_tnusFF/chip/src/timer_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/timer_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,133 @@
+/*
+ * @brief LPC5410X 32-bit Timer/PWM driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+struct TBASE_TO_TMRBITS {
+	uint32_t base;
+	uint8_t  clockID;
+	uint8_t  resetID;
+};
+
+#define LAST_TIMER      (4)
+static const struct TBASE_TO_TMRBITS tbaseToTimerIDs[LAST_TIMER + 1] = {
+	{LPC_TIMER0_BASE, (uint8_t) SYSCON_CLOCK_TIMER0, (uint8_t) RESET_TIMER0},
+	{LPC_TIMER1_BASE, (uint8_t) SYSCON_CLOCK_TIMER1, (uint8_t) RESET_TIMER1},
+	{LPC_TIMER2_BASE, (uint8_t) SYSCON_CLOCK_TIMER2, (uint8_t) RESET_TIMER2},
+	{LPC_TIMER3_BASE, (uint8_t) SYSCON_CLOCK_TIMER3, (uint8_t) RESET_TIMER3},
+	{LPC_TIMER4_BASE, (uint8_t) SYSCON_CLOCK_TIMER4, (uint8_t) RESET_TIMER4}
+};
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Return index into tbaseToTimerIDs for timers 0-4 */
+static int GetClockID(LPC_TIMER_T *pTMR)
+{
+	int timerId = LAST_TIMER;
+
+	while (timerId >= 0) {
+		if (pTMR == (LPC_TIMER_T *) tbaseToTimerIDs[timerId].base) {
+			return timerId;
+		}
+
+		timerId--;
+	}
+
+	/* Waill return timer 0 if no timer match */
+	return 0;
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize a timer */
+void Chip_TIMER_Init(LPC_TIMER_T *pTMR)
+{
+	int clockId = GetClockID(pTMR);
+
+	Chip_Clock_EnablePeriphClock((CHIP_SYSCON_CLOCK_T) tbaseToTimerIDs[clockId].clockID);
+	Chip_SYSCON_PeriphReset((CHIP_SYSCON_PERIPH_RESET_T) tbaseToTimerIDs[clockId].resetID);
+}
+
+/*	Shutdown a timer */
+void Chip_TIMER_DeInit(LPC_TIMER_T *pTMR)
+{
+	int clockId = GetClockID(pTMR);
+
+	Chip_Clock_DisablePeriphClock((CHIP_SYSCON_CLOCK_T) tbaseToTimerIDs[clockId].clockID);
+}
+
+/* Resets the timer counter and prescale counts to 0 */
+void Chip_TIMER_Reset(LPC_TIMER_T *pTMR)
+{
+	uint32_t reg;
+
+	/* Disable timer, set terminal count to non-0 */
+	reg = pTMR->TCR;
+	pTMR->TCR = 0;
+	pTMR->TC = 1;
+
+	/* Reset timer counter */
+	pTMR->TCR = TIMER_RESET;
+
+	/* Wait for terminal count to clear */
+	while (pTMR->TC != 0) {}
+
+	/* Restore timer state */
+	pTMR->TCR = reg;
+}
+
+/* Sets external match control (MATn.matchnum) pin control */
+void Chip_TIMER_ExtMatchControlSet(LPC_TIMER_T *pTMR, int8_t initial_state,
+								   TIMER_PIN_MATCH_STATE_T matchState, int8_t matchnum)
+{
+	uint32_t mask, reg;
+
+	/* Clear bits corresponding to selected match register */
+	mask = (1 << matchnum) | (0x03 << (4 + (matchnum * 2)));
+	/* Also mask reserved bits */
+	reg = (pTMR->EMR & TIMER_EMR_MASK) & ~mask;
+
+	/* Set new configuration for selected match register */
+	pTMR->EMR = reg | (((uint32_t) initial_state) << matchnum) |
+				(((uint32_t) matchState) << (4 + (matchnum * 2)));
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/uart_5410x.c ./chip/src/uart_5410x.c
--- a_tnusFF/chip/src/uart_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/uart_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,364 @@
+/*
+ * @brief LPC5410X UART driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2015
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licenser disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/* Return UART clock ID from the UART register address */
+static CHIP_SYSCON_CLOCK_T getUARTClockID(LPC_USART_T *pUART)
+{
+	if (pUART == LPC_USART0) {
+		return SYSCON_CLOCK_USART0;
+	}
+	else if (pUART == LPC_USART1) {
+		return SYSCON_CLOCK_USART1;
+	}
+	else if (pUART == LPC_USART2) {
+		return SYSCON_CLOCK_USART2;
+	}
+	return SYSCON_CLOCK_USART3;
+}
+
+/* PRIVATE: Division logic to divide without integer overflow */
+static uint32_t _UART_DivClk(uint32_t pclk, uint32_t m)
+{
+	uint32_t q, r, u = pclk >> 24, l = pclk << 8;
+	m = m + 256;
+	q = (1 << 24) / m;
+	r = (1 << 24) - (q * m);
+	return ((q * u) << 8) + (((r * u) << 8) + l) / m;
+}
+
+/* PRIVATE: Get highest Over sampling value */
+static uint32_t _UART_GetHighDiv(uint32_t val, uint8_t strict)
+{
+	int32_t i, max = strict ? 16 : 5;
+	for (i = 16; i >= max; i--) {
+		if (!(val % i)) {
+			return i;
+		}
+	}
+	return 0;
+}
+
+/* Calculate error difference */
+static int32_t _CalcErr(uint32_t n, uint32_t d, uint32_t *prev)
+{
+	uint32_t err = n - (n / d) * d;
+	uint32_t herr = ((n / d) + 1) * d - n;
+	if (herr < err) {
+		err = herr;
+	}
+
+	if (*prev <= err) {
+		return 0;
+	}
+	*prev = err;
+	return (herr == err) + 1;
+}
+
+/* Calculate the base DIV value */
+static ErrorCode_t _UART_CalcDiv(UART_BAUD_T *ub)
+{
+	int32_t i = 0;
+	uint32_t perr = ~0UL;
+
+	if (!ub->div) {
+		i = ub->ovr ? ub->ovr : 16;
+	}
+
+	for (; i > 4; i--) {
+		int32_t tmp = _CalcErr(ub->clk, ub->baud * i, &perr);
+
+		/* Continue when no improvement seen in err value */
+		if (!tmp) {
+			continue;
+		}
+
+		ub->div = tmp - 1;
+		if (ub->ovr == i) {
+			break;
+		}
+		ub->ovr = i;
+	}
+
+	if (!ub->ovr) {
+		return ERR_UART_BAUDRATE;
+	}
+
+	ub->div += ub->clk / (ub->baud * ub->ovr);
+	if (!ub->div) {
+		return ERR_UART_BAUDRATE;
+	}
+
+	ub->baud = ub->clk / (ub->div * ub->ovr);
+	return LPC_OK;
+}
+
+/* Calculate the best MUL value */
+static void _UART_CalcMul(UART_BAUD_T *ub)
+{
+	uint32_t m, perr = ~0UL, pclk = ub->clk, ovr = ub->ovr;
+
+	/* If clock is UART's base clock calculate only the divider */
+	for (m = 0; m < 256; m++) {
+		uint32_t ov = ovr, x, v, tmp;
+
+		/* Get clock and calculate error */
+		x = _UART_DivClk(pclk, m);
+		tmp = _CalcErr(x, ub->baud, &perr);
+		v = (x / ub->baud) + tmp - 1;
+
+		/* Update if new error is better than previous best */
+		if (!tmp || (ovr && (v % ovr)) ||
+			(!ovr && ((ov = _UART_GetHighDiv(v, ovr)) == 0))) {
+			continue;
+		}
+
+		ub->ovr = ov;
+		ub->mul = m;
+		ub->clk = x;
+		ub->div = tmp - 1;
+	}
+}
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Function to calculate UART Baud rate */
+uint32_t Chip_UART_CalcBaud(LPC_USART_T *pUART, UART_BAUD_T *pBaud)
+{
+	if (!pBaud->mul) {
+		_UART_CalcMul(pBaud);
+	}
+
+	return _UART_CalcDiv(pBaud);
+}
+
+/* Initialize the UART peripheral */
+void Chip_UART_Init(LPC_USART_T *pUART)
+{
+	/* Enable USART clock */
+	Chip_Clock_EnablePeriphClock(getUARTClockID(pUART));
+
+	/* UART reset */
+	if (pUART == LPC_USART0) {
+		/* Peripheral reset control to USART0 */
+		Chip_SYSCON_PeriphReset(RESET_USART0);
+	}
+	else if (pUART == LPC_USART1) {
+		/* Peripheral reset control to USART1 */
+		Chip_SYSCON_PeriphReset(RESET_USART1);
+	}
+	else if (pUART == LPC_USART2) {
+		/* Peripheral reset control to USART2 */
+		Chip_SYSCON_PeriphReset(RESET_USART2);
+	}
+	else if (pUART == LPC_USART3) {
+		/* Peripheral reset control to USART3 */
+		Chip_SYSCON_PeriphReset(RESET_USART3);
+	}
+
+}
+
+/* Initialize the UART peripheral */
+void Chip_UART_DeInit(LPC_USART_T *pUART)
+{
+	/* Enable USART clock */
+	Chip_Clock_DisablePeriphClock(getUARTClockID(pUART));
+}
+
+/* Transmit a byte array through the UART peripheral (non-blocking) */
+int Chip_UART_Send(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+	int sent = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Send until the transmit FIFO is full or out of bytes */
+	while ((sent < numBytes) &&
+		   ((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0)) {
+		Chip_UART_SendByte(pUART, *p8);
+		p8++;
+		sent++;
+	}
+
+	return sent;
+}
+
+/* Transmit a byte array through the UART peripheral (blocking) */
+int Chip_UART_SendBlocking(LPC_USART_T *pUART, const void *data, int numBytes)
+{
+	int pass, sent = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	while (numBytes > 0) {
+		pass = Chip_UART_Send(pUART, p8, numBytes);
+		numBytes -= pass;
+		sent += pass;
+		p8 += pass;
+	}
+
+	return sent;
+}
+
+/* Read data through the UART peripheral (non-blocking) */
+int Chip_UART_Read(LPC_USART_T *pUART, void *data, int numBytes)
+{
+	int readBytes = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Send until the transmit FIFO is full or out of bytes */
+	while ((readBytes < numBytes) &&
+		   ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0)) {
+		*p8 = Chip_UART_ReadByte(pUART);
+		p8++;
+		readBytes++;
+	}
+
+	return readBytes;
+}
+
+/* Read data through the UART peripheral (blocking) */
+int Chip_UART_ReadBlocking(LPC_USART_T *pUART, void *data, int numBytes)
+{
+	int pass, readBytes = 0;
+	uint8_t *p8 = (uint8_t *) data;
+
+	while (readBytes < numBytes) {
+		pass = Chip_UART_Read(pUART, p8, numBytes);
+		numBytes -= pass;
+		readBytes += pass;
+		p8 += pass;
+	}
+
+	return readBytes;
+}
+
+/* Set baud rate for UART */
+void Chip_UART_SetBaud(LPC_USART_T *pUART, uint32_t baudrate)
+{
+	UART_BAUD_T baud;
+
+	/* Set up baudrate parameters */
+	baud.clk = Chip_Clock_GetAsyncSyscon_ClockRate();	/* Clock frequency */
+	baud.baud = baudrate;	/* Required baud rate */
+	baud.ovr = 0;	/* Set the oversampling to the recommended rate */
+	baud.mul = baud.div = 0;
+	Chip_UART_CalcBaud(pUART, &baud);
+
+	/* Enable register clock to the fractional divider */
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_FRG);
+
+	/* Set fractional control register */
+	Chip_SYSCON_SetUSARTFRGCtrl(baud.mul, 0xFF);
+	Chip_UART_Div(pUART, baud.div, baud.ovr);
+}
+
+/* UART receive-only interrupt handler for ring buffers */
+void Chip_UART_RXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+	/* New data will be ignored if data not popped in time */
+	while ((Chip_UART_GetStatus(pUART) & UART_STAT_RXRDY) != 0) {
+		uint8_t ch = Chip_UART_ReadByte(pUART);
+		RingBuffer_Insert(pRB, &ch);
+	}
+}
+
+/* UART transmit-only interrupt handler for ring buffers */
+void Chip_UART_TXIntHandlerRB(LPC_USART_T *pUART, RINGBUFF_T *pRB)
+{
+	uint8_t ch;
+
+	/* Fill FIFO until full or until TX ring buffer is empty */
+	while (((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0) &&
+		   RingBuffer_Pop(pRB, &ch)) {
+		Chip_UART_SendByte(pUART, ch);
+	}
+}
+
+/* Populate a transmit ring buffer and start UART transmit */
+uint32_t Chip_UART_SendRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, const void *data, int count)
+{
+	uint32_t ret;
+	uint8_t *p8 = (uint8_t *) data;
+
+	/* Don't let UART transmit ring buffer change in the UART IRQ handler */
+	Chip_UART_IntDisable(pUART, UART_INTEN_TXRDY);
+
+	/* Move as much data as possible into transmit ring buffer */
+	ret = RingBuffer_InsertMult(pRB, p8, count);
+	Chip_UART_TXIntHandlerRB(pUART, pRB);
+
+	/* Add additional data to transmit ring buffer if possible */
+	ret += RingBuffer_InsertMult(pRB, (p8 + ret), (count - ret));
+
+	/* Enable UART transmit interrupt */
+	Chip_UART_IntEnable(pUART, UART_INTEN_TXRDY);
+
+	return ret;
+}
+
+/* Copy data from a receive ring buffer */
+int Chip_UART_ReadRB(LPC_USART_T *pUART, RINGBUFF_T *pRB, void *data, int bytes)
+{
+	(void) pUART;
+
+	return RingBuffer_PopMult(pRB, (uint8_t *) data, bytes);
+}
+
+/* UART receive/transmit interrupt handler for ring buffers */
+void Chip_UART_IRQRBHandler(LPC_USART_T *pUART, RINGBUFF_T *pRXRB, RINGBUFF_T *pTXRB)
+{
+	/* Handle transmit interrupt if enabled */
+	if ((Chip_UART_GetStatus(pUART) & UART_STAT_TXRDY) != 0) {
+		Chip_UART_TXIntHandlerRB(pUART, pTXRB);
+
+		/* Disable transmit interrupt if the ring buffer is empty */
+		if (RingBuffer_IsEmpty(pTXRB)) {
+			Chip_UART_IntDisable(pUART, UART_INTEN_TXRDY);
+		}
+	}
+
+	/* Handle receive interrupt */
+	Chip_UART_RXIntHandlerRB(pUART, pRXRB);
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/chip/src/wwdt_5410x.c ./chip/src/wwdt_5410x.c
--- a_tnusFF/chip/src/wwdt_5410x.c	1969-12-31 21:00:00.000000000 -0300
+++ ./chip/src/wwdt_5410x.c	2016-10-22 23:17:43.584840278 -0300
@@ -0,0 +1,61 @@
+/*
+ * @brief LPC5410X WWDT chip driver
+ *
+ * @note
+ * Copyright(C) NXP Semiconductors, 2014
+ * All rights reserved.
+ *
+ * @par
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * LPC products.  This software is supplied "AS IS" without any warranties of
+ * any kind, and NXP Semiconductors and its licensor disclaim any and
+ * all warranties, express or implied, including all implied warranties of
+ * merchantability, fitness for a particular purpose and non-infringement of
+ * intellectual property rights.  NXP Semiconductors assumes no responsibility
+ * or liability for the use of the software, conveys no license or rights under any
+ * patent, copyright, mask work right, or any other intellectual property rights in
+ * or to any products. NXP Semiconductors reserves the right to make changes
+ * in the software without notification. NXP Semiconductors also makes no
+ * representation or warranty that such application will be suitable for the
+ * specified use without further testing or modification.
+ *
+ * @par
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, under NXP Semiconductors' and its
+ * licensor's relevant copyrights in the software, without fee, provided that it
+ * is used in conjunction with NXP Semiconductors microcontrollers.  This
+ * copyright, permission, and disclaimer notice must appear in all copies of
+ * this code.
+ */
+
+#include "chip.h"
+
+/*****************************************************************************
+ * Private types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public types/enumerations/variables
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Private functions
+ ****************************************************************************/
+
+/*****************************************************************************
+ * Public functions
+ ****************************************************************************/
+
+/* Initialize the Watchdog timer */
+void Chip_WWDT_Init(LPC_WWDT_T *pWWDT)
+{
+	Chip_Clock_EnablePeriphClock(SYSCON_CLOCK_WWDT);
+	Chip_SYSCON_PeriphReset(RESET_WWDT);
+
+	/* Disable watchdog */
+	pWWDT->MOD       = 0;
+	pWWDT->TC        = 0xFF;
+	pWWDT->WARNINT   = 0x3FF;
+	pWWDT->WINDOW    = 0xFFFFFF;
+}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/config.mk ./config.mk
--- a_tnusFF/config.mk	1969-12-31 21:00:00.000000000 -0300
+++ ./config.mk	2016-10-22 23:24:26.052851056 -0300
@@ -0,0 +1,12 @@
+# Executable name
+APP=${{Program_Name string:blinking}}
+
+MODULES=app base board chip
+DEFINES=CORE_M4 __USE_LPCOPEN __USE_NEWLIB __LPC5410X__ __CODE_RED
+LIBRARY=power_m4f_hard
+
+# Verbose Build: no|yes
+VERBOSE=${{Verbose_Build items:no|yes}}
+
+# Optimization Level: debug|none|basic|standar|full|size|speed
+OPT_LEVEL=${{Optimization_Level items:debug|none|basic|standar|full|size|speed}}
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/linker.ld ./linker.ld
--- a_tnusFF/linker.ld	1969-12-31 21:00:00.000000000 -0300
+++ ./linker.ld	2016-10-22 23:17:43.588840279 -0300
@@ -0,0 +1,253 @@
+
+MEMORY
+{
+  /* Define each memory region */
+  MFlash512 (rx) : ORIGIN = 0x0, LENGTH = 0x80000 /* 512K bytes (alias Flash) */  
+  Ram0_64 (rwx) : ORIGIN = 0x2000000, LENGTH = 0xffe0 /* 64K - 32 bytes (alias RAM) */  
+  Ram1_32 (rwx) : ORIGIN = 0x2010000, LENGTH = 0x8000 /* 32K bytes (alias RAM2) */  
+  Ram2_8 (rwx) : ORIGIN = 0x3400000, LENGTH = 0x2000 /* 8K bytes (alias RAM3) */  
+}
+
+  /* Define a symbol for the top of each memory region */
+  __base_MFlash512 = 0x0  ; /* MFlash512 */  
+  __base_Flash = 0x0 ; /* Flash */  
+  __top_MFlash512 = 0x0 + 0x80000 ; /* 512K bytes */  
+  __top_Flash = 0x0 + 0x80000 ; /* 512K bytes */  
+  __base_Ram0_64 = 0x2000000  ; /* Ram0_64 */  
+  __base_RAM = 0x2000000 ; /* RAM */  
+  __top_Ram0_64 = 0x2000000 + 0x10000 ; /* 64K bytes */  
+  __top_RAM = 0x2000000 + 0x10000 - 32 ; /* 64K bytes */  
+  __base_Ram1_32 = 0x2010000  ; /* Ram1_32 */  
+  __base_RAM2 = 0x2010000 ; /* RAM2 */  
+  __top_Ram1_32 = 0x2010000 + 0x8000 ; /* 32K bytes */  
+  __top_RAM2 = 0x2010000 + 0x8000 ; /* 32K bytes */  
+  __base_Ram2_8 = 0x3400000  ; /* Ram2_8 */  
+  __base_RAM3 = 0x3400000 ; /* RAM3 */  
+  __top_Ram2_8 = 0x3400000 + 0x2000 ; /* 8K bytes */  
+  __top_RAM3 = 0x3400000 + 0x2000 ; /* 8K bytes */  
+
+ENTRY(ResetISR)
+
+SECTIONS
+{
+    /* MAIN TEXT SECTION */
+    .text : ALIGN(4)
+    {
+        FILL(0xff)
+        __vectors_start__ = ABSOLUTE(.) ;
+        KEEP(*(.isr_vector))
+        /* Global Section Table */
+        . = ALIGN(4) ; 
+        __section_table_start = .;
+        __data_section_table = .;
+        LONG(LOADADDR(.data));
+        LONG(    ADDR(.data));
+        LONG(  SIZEOF(.data));
+        LONG(LOADADDR(.data_RAM2_core_m0slave_text));
+        LONG(    ADDR(.data_RAM2_core_m0slave_text));
+        LONG(  SIZEOF(.data_RAM2_core_m0slave_text));
+        LONG(LOADADDR(.data_RAM2_core_m0slave_ARM_extab));
+        LONG(    ADDR(.data_RAM2_core_m0slave_ARM_extab));
+        LONG(  SIZEOF(.data_RAM2_core_m0slave_ARM_extab));
+        LONG(LOADADDR(.data_RAM2_core_m0slave_ARM_exidx));
+        LONG(    ADDR(.data_RAM2_core_m0slave_ARM_exidx));
+        LONG(  SIZEOF(.data_RAM2_core_m0slave_ARM_exidx));
+        LONG(LOADADDR(.data_RAM2_core_m0slave_data));
+        LONG(    ADDR(.data_RAM2_core_m0slave_data));
+        LONG(  SIZEOF(.data_RAM2_core_m0slave_data));
+        LONG(LOADADDR(.data_RAM2));
+        LONG(    ADDR(.data_RAM2));
+        LONG(  SIZEOF(.data_RAM2));
+        LONG(LOADADDR(.data_RAM3));
+        LONG(    ADDR(.data_RAM3));
+        LONG(  SIZEOF(.data_RAM3));
+        __data_section_table_end = .;
+        __bss_section_table = .;
+        LONG(    ADDR(.bss));
+        LONG(  SIZEOF(.bss));
+        LONG(    ADDR(.bss_RAM2));
+        LONG(  SIZEOF(.bss_RAM2));
+        LONG(    ADDR(.bss_RAM3));
+        LONG(  SIZEOF(.bss_RAM3));
+        __bss_section_table_end = .;
+        __section_table_end = . ;
+	    /* End of Global Section Table */
+
+        *(.after_vectors*)
+
+    } >MFlash512
+
+    .text : ALIGN(4)    
+    {
+        *(.text*)
+        *(.rodata .rodata.* .constdata .constdata.*)
+        . = ALIGN(4);
+    } > MFlash512
+    /*
+     * for exception handling/unwind - some Newlib functions (in common
+     * with C++ and STDC++) use this. 
+     */
+    .ARM.extab : ALIGN(4) 
+    {
+        *(.ARM.extab* .gnu.linkonce.armextab.*)
+    } > MFlash512
+    __exidx_start = .;
+
+    .ARM.exidx : ALIGN(4)
+    {
+        *(.ARM.exidx* .gnu.linkonce.armexidx.*)
+    } > MFlash512
+    __exidx_end = .;
+
+    _etext = .;
+        
+    /* DATA section for Ram1_32 */
+  
+    .data_RAM2_core_m0slave_text : SUBALIGN(4)
+    {
+       FILL(0xff)
+       PROVIDE(__start_data_RAM2 = .) ;
+       __core_m0slave_START__ = .; /* start of slave image */
+       KEEP(*(.core_m0slave))
+    } > Ram1_32 AT>MFlash512
+
+    /* M0SLAVE extab and exidx sections */
+    .data_RAM2_core_m0slave_ARM_extab . : SUBALIGN(4)
+    {
+        FILL(0xff)
+        KEEP(*(.core_m0slave.ARM.extab))
+    } > Ram1_32 AT>MFlash512 
+
+    .data_RAM2_core_m0slave_ARM_exidx . : SUBALIGN(4)
+    {
+        FILL(0xff)
+        KEEP(*(.core_m0slave.ARM.exidx))
+    } > Ram1_32 AT>MFlash512 
+
+    /* M0SLAVE data section */
+    .data_RAM2_core_m0slave_data . : SUBALIGN(4)
+    {
+        FILL(0xff)
+        KEEP(*(.core_m0slave.data_*)) KEEP(*(.core_m0slave.data))
+        __core_m0slave_END__ = .; /* end of slave image */
+
+        /* perform some simple sanity checks */
+        /*
+        ASSERT(!(__core_m0slave_START__ == __core_m0slave_END__), "No slave code for _core_m0slave");
+        ASSERT( (ABSOLUTE(__core_m0slave_START__) == __vectors_start___core_m0slave), "M0SLAVE execute address differs from address provided in source image");
+        */
+    } > Ram1_32 AT>MFlash512 
+    .data_RAM2 : ALIGN(4)
+    {
+        FILL(0xff)
+        *(.ramfunc.$RAM2)
+        *(.ramfunc.$Ram1_32)
+        *(.data.$RAM2*)
+        *(.data.$Ram1_32*)
+        . = ALIGN(4) ;
+        PROVIDE(__end_data_RAM2 = .) ;
+     } > Ram1_32 AT>MFlash512
+
+    /* DATA section for Ram2_8 */
+  
+    .data_RAM3 : ALIGN(4)
+    {
+        FILL(0xff)
+        PROVIDE(__start_data_RAM3 = .) ;
+        *(.ramfunc.$RAM3)
+        *(.ramfunc.$Ram2_8)
+        *(.data.$RAM3*)
+        *(.data.$Ram2_8*)
+        . = ALIGN(4) ;
+        PROVIDE(__end_data_RAM3 = .) ;
+     } > Ram2_8 AT>MFlash512
+
+    /* MAIN DATA SECTION */
+    .uninit_RESERVED : ALIGN(4)
+    {
+        KEEP(*(.bss.$RESERVED*))
+        . = ALIGN(4) ;
+        _end_uninit_RESERVED = .;
+    } > Ram0_64
+    /* Main DATA section (Ram0_64) */
+    .data : ALIGN(4)
+    {
+       FILL(0xff)
+       _data = . ;
+       *(vtable)
+       *(.ramfunc*)
+       *(.data*)
+       . = ALIGN(4) ;
+       _edata = . ;
+    } > Ram0_64 AT>MFlash512
+    /* BSS section for Ram1_32 */
+    .bss_RAM2 : ALIGN(4)
+    {
+       PROVIDE(__start_bss_RAM2 = .) ;
+       *(.bss.$RAM2*)
+       *(.bss.$Ram1_32*)
+       . = ALIGN (. != 0 ? 4 : 1) ; /* avoid empty segment */
+       PROVIDE(__end_bss_RAM2 = .) ;
+    } > Ram1_32 
+    /* BSS section for Ram2_8 */
+    .bss_RAM3 : ALIGN(4)
+    {
+       PROVIDE(__start_bss_RAM3 = .) ;
+       *(.bss.$RAM3*)
+       *(.bss.$Ram2_8*)
+       . = ALIGN (. != 0 ? 4 : 1) ; /* avoid empty segment */
+       PROVIDE(__end_bss_RAM3 = .) ;
+    } > Ram2_8 
+    /* MAIN BSS SECTION */
+    .bss : ALIGN(4)
+    {
+        _bss = .;
+        *(.bss*)
+        *(COMMON)
+        . = ALIGN(4) ;
+        _ebss = .;
+        PROVIDE(end = .);
+    } > Ram0_64
+    /* NOINIT section for Ram1_32 */
+    .noinit_RAM2 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM2*)
+       *(.noinit.$Ram1_32*)
+       . = ALIGN(4) ;
+    } > Ram1_32 
+    /* NOINIT section for Ram2_8 */
+    .noinit_RAM3 (NOLOAD) : ALIGN(4)
+    {
+       *(.noinit.$RAM3*)
+       *(.noinit.$Ram2_8*)
+       . = ALIGN(4) ;
+    } > Ram2_8 
+    /* DEFAULT NOINIT SECTION */
+    .noinit (NOLOAD): ALIGN(4)
+    {
+        _noinit = .;
+        *(.noinit*) 
+         . = ALIGN(4) ;
+        _end_noinit = .;
+    } > Ram0_64
+
+    PROVIDE(_pvHeapStart = DEFINED(__user_heap_base) ? __user_heap_base : .);
+    PROVIDE(_vStackTop = DEFINED(__user_stack_top) ? __user_stack_top : __top_Ram0_64);
+
+    /* ## Create checksum value (used in startup) ## */
+    PROVIDE(__valid_user_code_checksum = 0 - 
+                                         (_vStackTop 
+                                         + (ResetISR + 1) 
+                                         + (NMI_Handler + 1) 
+                                         + (HardFault_Handler + 1) 
+                                         + (( DEFINED(MemManage_Handler) ? MemManage_Handler : 0 ) + 1)   /* MemManage_Handler may not be defined */
+                                         + (( DEFINED(BusFault_Handler) ? BusFault_Handler : 0 ) + 1)     /* BusFault_Handler may not be defined */
+                                         + (( DEFINED(UsageFault_Handler) ? UsageFault_Handler : 0 ) + 1) /* UsageFault_Handler may not be defined */
+                                         ) );
+}
+
+GROUP(
+ libgcc.a
+ libc.a
+ libm.a
+)
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/Makefile ./Makefile
--- a_tnusFF/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ ./Makefile	2016-10-22 23:17:43.588840279 -0300
@@ -0,0 +1,105 @@
+include config.mk
+
+SRC=$(foreach m, $(MODULES), $(wildcard $(m)/src/*.c))
+INCLUDES=$(foreach m, $(MODULES), -I$(m)/inc)
+_DEFINES=$(foreach m, $(DEFINES), -D$(m))
+LIBPATHS=$(foreach m, $(MODULES), $(if $(wildcard $(m)/libs/*.a), -L$(m)/libs,))
+LIBFLAGS=$(foreach l, $(LIBRARY), -l$(l))
+
+LIBSDEPS=$(addsuffix .a, $(basename $(foreach l, $(LIBRARY), $(foreach m, $(MODULES), $(wildcard $(m)/libs/lib$(l).hex) ) )))
+
+OBJECTS=$(SRC:.c=.o)
+DEPS=$(SRC:.c=.d)
+LDSCRIPT=linker.ld
+
+ARCH_FLAGS=-mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard
+
+ifeq ($(OPT_LEVEL),debug)
+OPT_FLAGS=-Og
+else ifeq ($(OPT_LEVEL),none)
+OPT_FLAGS=-O0
+else ifeq ($(OPT_LEVEL),basic)
+OPT_FLAGS=-O1
+else ifeq ($(OPT_LEVEL),standar)
+OPT_FLAGS=-O2
+else ifeq ($(OPT_LEVEL),full)
+OPT_FLAGS=-O3
+else ifeq ($(OPT_LEVEL),size)
+OPT_FLAGS=-Os
+else ifeq ($(OPT_LEVEL),speed)
+OPT_FLAGS=-Ofast
+endif
+
+CFLAGS=$(ARCH_FLAGS) $(INCLUDES) $(_DEFINES) -g3 $(OPT_FLAGS) -ffunction-sections -fdata-sections
+LDFLAGS=$(ARCH_FLAGS) -T$(LDSCRIPT) -nostartfiles -Wl,-gc-sections
+LDFLAGS+=--specs=nano.specs
+#LDFLAGS+=--specs=rdimon.specs
+
+CROSS=arm-none-eabi-
+CC=$(CROSS)gcc
+LD=$(CROSS)gcc
+SIZE=$(CROSS)size
+LIST=$(CROSS)objdump -xdSs
+OBJCOPY=$(CROSS)objcopy
+GDB=$(CROSS)gdb
+OOCD=openocd
+OOCD_SCRIPT?=oocd.cfg
+ifeq ($(VERBOSE),yes)
+Q=
+else
+Q=@
+endif
+
+TARGET=$(APP).elf
+TARGET_BIN=$(basename $(TARGET)).bin
+TARGET_LST=$(basename $(TARGET)).lst
+
+all: $(TARGET) $(TARGET_BIN) $(TARGET_LST) size
+
+-include $(DEPS)
+
+%.o: %.c
+	@echo CC $<
+	$(Q)$(CC) -MMD $(CFLAGS) -c -o $@ $<
+
+%.a: %.hex
+	@echo DEBLOB $@
+	$(Q)$(OBJCOPY) -I ihex $< -O binary $@
+
+#%.hex: %.a
+#	@echo BLOB $<
+#	$(Q)$(OBJCOPY) -I binary $< -O ihex $@
+
+$(TARGET): $(OBJECTS) $(LIBSDEPS)
+	@echo LD $@
+	$(Q)$(LD) $(LDFLAGS) -o $@ $(OBJECTS) $(LIBSDEPS)
+	
+$(TARGET_BIN): $(TARGET)
+	@echo BIN
+	$(Q)$(OBJCOPY) -v -O binary $< $@
+	
+$(TARGET_LST): $(TARGET)
+	@echo LIST
+	$(Q)$(LIST) $< > $@
+
+size: $(TARGET)
+	$(Q)$(SIZE) $<
+
+program: $(TARGET_BIN)
+	@echo PROG
+	$(Q)$(OOCD) -f $(OOCD_SCRIPT) \
+		-c "init" \
+		-c "reset halt" \
+		-c "flash write_image erase unlock $< 0x00000000 bin" \
+		-c "reset run" \
+		-c "shutdown" 2>&1
+
+erase:
+	$(Q)openocd -f $(OOCD_SCRIPT) \
+		-c "init" -c "reset halt" -c "flash erase_sector 0 0 last" -c "shutdown" 2>&1
+
+clean:
+	@echo CLEAN
+	$(Q)rm -fR $(OBJECTS) $(TARGET) $(TARGET_BIN) $(TARGET_LST) $(DEPS) $(LIBSDEPS)
+
+.PHONY: all size clean program
diff -aur --unidirectional-new-file -x '.git*' -x '*.o' -x '*.d' -x '*.elf' -x '*.lst' -x '*.map' -x '.config*' -x '*.conf' -x autoconf.h a_tnusFF/oocd.cfg ./oocd.cfg
--- a_tnusFF/oocd.cfg	1969-12-31 21:00:00.000000000 -0300
+++ ./oocd.cfg	2016-10-22 23:17:43.588840279 -0300
@@ -0,0 +1,90 @@
+###############################################################################
+#
+# Copyright 2014, Juan Cecconi (UTN-FRBA, Numetron)
+# Copyright 2016, Pablo Ridolfi
+#
+# This file is part of CIAA Firmware.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#
+# 1. Redistributions of source code must retain the above copyright notice,
+#    this list of conditions and the following disclaimer.
+#
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution.
+#
+# 3. Neither the name of the copyright holder nor the names of its
+#    contributors may be used to endorse or promote products derived from this
+#    software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+###############################################################################
+#OpenOCD configuration (target and interface) for LPC54102 using CMSIS-DAP
+
+interface cmsis-dap
+cmsis_dap_vid_pid 0x1FC9 0x0081
+
+adapter_khz 1000
+
+if { [info exists CCLK] } {
+	set _CCLK $CCLK
+} else {
+	set _CCLK 4000
+}
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME lpc54102
+}
+
+#
+# M4 SWD mode TAP
+#
+if { [info exists M4_SWD_TAPID] } {
+	set _M4_SWD_TAPID $M4_SWD_TAPID
+} else {
+	set _M4_SWD_TAPID 0x2ba01477
+}
+
+#
+# M0 SWD mode TAP
+#
+if { [info exists M0_SWD_TAPID] } {
+	set _M0_SWD_TAPID $M0_SWD_TAPID
+} else {
+	set _M0_SWD_TAPID 0x2ba01477
+}
+
+swd newdap $_CHIPNAME m4 -expected-id $_M4_SWD_TAPID
+swd newdap $_CHIPNAME m0 -expected-id $_M0_SWD_TAPID
+
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+#target create $_CHIPNAME.m0 cortex_m -chain-position $_CHIPNAME.m0
+
+set _WORKAREASIZE 0x10000
+$_CHIPNAME.m4 configure -work-area-phys 0x02000000 -work-area-size $_WORKAREASIZE
+
+set _FLASHNAME $_CHIPNAME.flash
+flash bank $_FLASHNAME lpc2000 0x00000000 0x80000 0 0 $_CHIPNAME.m4 lpc54100 $_CCLK calc_checksum
+
+reset_config srst_only
+cortex_m reset_config vectreset
+
+$_CHIPNAME.m4 configure -event gdb-attach {
+   echo "Halting target"
+   halt
+}
